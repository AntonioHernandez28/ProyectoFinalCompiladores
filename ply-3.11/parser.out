Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMPARE
    END
    FROM
    MODA
    PLOTXY
    SIMPLEREGRESSION
    VARIANZA

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMMICOLON addProgram program1
Rule 2     addProgram -> <empty>
Rule 3     program1 -> vars functions program2
Rule 4     program1 -> vars functions
Rule 5     program1 -> program2
Rule 6     program2 -> principal
Rule 7     principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY
Rule 8     statements -> assign SEMMICOLON statements
Rule 9     statements -> functionCall SEMMICOLON statements
Rule 10    statements -> read statements SEMMICOLON statements
Rule 11    statements -> write statements SEMMICOLON statements
Rule 12    statements -> for statements
Rule 13    statements -> while statements
Rule 14    statements -> if statements
Rule 15    statements -> return statements
Rule 16    statements -> empty
Rule 17    assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad
Rule 18    assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
Rule 19    generateAssignQuad -> <empty>
Rule 20    add_id -> <empty>
Rule 21    add_id2 -> <empty>
Rule 22    functionCall -> ID LPAREN exp RPAREN
Rule 23    read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN
Rule 24    operatorRead -> <empty>
Rule 25    media -> MEDIA LPAREN arr RPAREN SEMMICOLON
Rule 26    write -> WRITE LPAREN write1 RPAREN
Rule 27    write1 -> write2 COMMA write2
Rule 28    write1 -> write2
Rule 29    write2 -> COMILLA CTESTRING COMILLA
Rule 30    write2 -> CTEI saveCTE generateQuadPRINT
Rule 31    write2 -> CTEF saveCTE generateQuadPRINT
Rule 32    write2 -> exp
Rule 33    for -> FOR assign TO CTEI DO LCURLY statements RCURLY
Rule 34    while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
Rule 35    if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
Rule 36    else -> ELSE LCURLY statements RCURLY
Rule 37    else -> empty
Rule 38    generateQuadOR -> <empty>
Rule 39    generateQuadAND -> <empty>
Rule 40    generateQuadCOMPARE -> <empty>
Rule 41    generateQuadIF -> <empty>
Rule 42    generateQuadSUM -> <empty>
Rule 43    generateQuadMUL -> <empty>
Rule 44    generateQuadPRINT -> <empty>
Rule 45    generateQuadREAD -> <empty>
Rule 46    saveCTE -> <empty>
Rule 47    exp -> nexp generateQuadOR
Rule 48    exp -> nexp generateQuadOR OR saveOperator nexp
Rule 49    nexp -> compexp generateQuadAND
Rule 50    nexp -> compexp generateQuadAND AND saveOperator compexp
Rule 51    compexp -> sumexp
Rule 52    compexp -> compexp1 sumexp
Rule 53    compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE
Rule 54    compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE
Rule 55    compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE
Rule 56    compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE
Rule 57    compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE
Rule 58    sumexp -> mulexp
Rule 59    sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM
Rule 60    sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM
Rule 61    mulexp -> pexp
Rule 62    mulexp -> pexp MUL saveOperator pexp generateQuadMUL
Rule 63    mulexp -> pexp DIV saveOperator pexp generateQuadMUL
Rule 64    pexp -> var1 add_id
Rule 65    pexp -> CTEI saveCTE
Rule 66    pexp -> CTEF saveCTE
Rule 67    pexp -> CTEC saveCTE
Rule 68    pexp -> CTESTRING saveCTE
Rule 69    pexp -> functionCall
Rule 70    pexp -> LPAREN exp RPAREN
Rule 71    saveOperator -> <empty>
Rule 72    vars -> var
Rule 73    vars -> empty
Rule 74    var -> VARS var2
Rule 75    var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar
Rule 76    var2 -> empty
Rule 77    var1 -> ID
Rule 78    var1 -> ID COMMA var1 addVar
Rule 79    var1 -> ID arr
Rule 80    var1 -> ID arr COMMA var1 addVar
Rule 81    var1 -> empty
Rule 82    addVar -> <empty>
Rule 83    saveTypeVar -> <empty>
Rule 84    type -> INT saveTypeVar
Rule 85    type -> CHAR saveTypeVar
Rule 86    type -> FLOAT saveTypeVar
Rule 87    arr -> LBRACKET CTEI RBRACKET
Rule 88    arr -> LBRACKET exp RBRACKET
Rule 89    functions -> FUNCTION INT functions1 functions
Rule 90    functions -> FUNCTION CHAR functions1 functions
Rule 91    functions -> FUNCTION FLOAT functions1 functions
Rule 92    functions -> FUNCTION VOID functions1 functions
Rule 93    functions -> empty
Rule 94    functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
Rule 95    functions1 -> empty
Rule 96    saveFunction -> <empty>
Rule 97    args -> type TWOPOINTS args1
Rule 98    args -> empty
Rule 99    args1 -> ID
Rule 100   args1 -> ID COMMA args1
Rule 101   args1 -> empty
Rule 102   return -> RETURN LPAREN exp RPAREN SEMMICOLON
Rule 103   return -> RETURN LPAREN exp RPAREN
Rule 104   empty -> <empty>

Terminals, with rules where they appear

AND                  : 50
CHAR                 : 85 90
COMILLA              : 29 29
COMMA                : 27 78 80 100
COMPARE              : 
CTEC                 : 67
CTEF                 : 31 66
CTEI                 : 30 33 65 87
CTESTRING            : 29 68
DIV                  : 63
DO                   : 33 34
ELSE                 : 36
END                  : 
EQUALS               : 17 18
FLOAT                : 86 91
FOR                  : 33
FROM                 : 
FUNCTION             : 89 90 91 92
GT                   : 53
GTE                  : 55
ID                   : 1 17 18 22 77 78 79 80 94 99 100
IF                   : 35
INT                  : 84 89
LBRACKET             : 87 88
LCURLY               : 7 33 34 35 36 94
LPAREN               : 7 22 23 25 26 34 35 70 94 102 103
LT                   : 54
LTE                  : 56
MEDIA                : 25
MINUS                : 60
MODA                 : 
MUL                  : 62
NE                   : 57
OR                   : 48
PLOTXY               : 
PLUS                 : 59
PRINCIPAL            : 7
PROGRAM              : 1
RBRACKET             : 87 88
RCURLY               : 7 33 34 35 36 94
READ                 : 23
RETURN               : 102 103
RPAREN               : 7 22 23 25 26 34 35 70 94 102 103
SEMMICOLON           : 1 8 9 10 11 25 75 102
SIMPLEREGRESSION     : 
THEN                 : 35
TO                   : 33
TWOPOINTS            : 75 97
VARIANZA             : 
VARS                 : 74
VOID                 : 92
WHILE                : 34
WRITE                : 26
error                : 

Nonterminals, with rules where they appear

addProgram           : 1
addVar               : 75 78 80
add_id               : 64
add_id2              : 17 18
args                 : 94
args1                : 97 100
arr                  : 18 25 79 80
assign               : 8 33
compexp              : 49 50 50
compexp1             : 52
else                 : 35
empty                : 16 37 73 76 81 93 95 98 101
exp                  : 17 18 22 32 34 35 70 88 102 103
for                  : 12
functionCall         : 9 69
functions            : 3 4 89 90 91 92
functions1           : 89 90 91 92
generateAssignQuad   : 17 18
generateQuadAND      : 49 50
generateQuadCOMPARE  : 53 54 55 56 57
generateQuadIF       : 
generateQuadMUL      : 62 63
generateQuadOR       : 47 48
generateQuadPRINT    : 30 31
generateQuadREAD     : 23
generateQuadSUM      : 59 60
if                   : 14
media                : 
mulexp               : 58 59 59 60 60
nexp                 : 47 48 48
operatorRead         : 23
pexp                 : 61 62 62 63 63
principal            : 6
program              : 0
program1             : 1
program2             : 3 5
read                 : 10
return               : 15
saveCTE              : 30 31 65 66 67 68
saveFunction         : 94
saveOperator         : 17 18 48 50 53 54 55 56 57 59 60 62 63
saveTypeVar          : 84 85 86
statements           : 7 8 9 10 10 11 11 12 13 14 15 33 34 35 36 94
sumexp               : 51 52 53 53 54 54 55 55 56 56 57 57
type                 : 75 97
var                  : 72
var1                 : 23 64 75 78 80
var2                 : 74 75
vars                 : 3 4 7 94
while                : 13
write                : 11
write1               : 26
write2               : 27 27 28

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMMICOLON addProgram program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMMICOLON addProgram program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMMICOLON addProgram program1

    SEMMICOLON      shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMMICOLON . addProgram program1
    (2) addProgram -> .

    VARS            reduce using rule 2 (addProgram -> .)
    PRINCIPAL       reduce using rule 2 (addProgram -> .)
    FUNCTION        reduce using rule 2 (addProgram -> .)
    $end            reduce using rule 2 (addProgram -> .)

    addProgram                     shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMMICOLON addProgram . program1
    (3) program1 -> . vars functions program2
    (4) program1 -> . vars functions
    (5) program1 -> . program2
    (72) vars -> . var
    (73) vars -> . empty
    (6) program2 -> . principal
    (74) var -> . VARS var2
    (104) empty -> .
    (7) principal -> . PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY

  ! shift/reduce conflict for PRINCIPAL resolved as shift
    VARS            shift and go to state 12
    FUNCTION        reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)
    PRINCIPAL       shift and go to state 13

  ! PRINCIPAL       [ reduce using rule 104 (empty -> .) ]

    program1                       shift and go to state 6
    vars                           shift and go to state 7
    program2                       shift and go to state 8
    var                            shift and go to state 9
    empty                          shift and go to state 10
    principal                      shift and go to state 11

state 6

    (1) program -> PROGRAM ID SEMMICOLON addProgram program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMMICOLON addProgram program1 .)


state 7

    (3) program1 -> vars . functions program2
    (4) program1 -> vars . functions
    (89) functions -> . FUNCTION INT functions1 functions
    (90) functions -> . FUNCTION CHAR functions1 functions
    (91) functions -> . FUNCTION FLOAT functions1 functions
    (92) functions -> . FUNCTION VOID functions1 functions
    (93) functions -> . empty
    (104) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    functions                      shift and go to state 14
    empty                          shift and go to state 16

state 8

    (5) program1 -> program2 .

    $end            reduce using rule 5 (program1 -> program2 .)


state 9

    (72) vars -> var .

    FUNCTION        reduce using rule 72 (vars -> var .)
    PRINCIPAL       reduce using rule 72 (vars -> var .)
    $end            reduce using rule 72 (vars -> var .)
    ID              reduce using rule 72 (vars -> var .)
    READ            reduce using rule 72 (vars -> var .)
    WRITE           reduce using rule 72 (vars -> var .)
    FOR             reduce using rule 72 (vars -> var .)
    WHILE           reduce using rule 72 (vars -> var .)
    IF              reduce using rule 72 (vars -> var .)
    RETURN          reduce using rule 72 (vars -> var .)
    RCURLY          reduce using rule 72 (vars -> var .)
    LCURLY          reduce using rule 72 (vars -> var .)


state 10

    (73) vars -> empty .

    FUNCTION        reduce using rule 73 (vars -> empty .)
    PRINCIPAL       reduce using rule 73 (vars -> empty .)
    $end            reduce using rule 73 (vars -> empty .)
    ID              reduce using rule 73 (vars -> empty .)
    READ            reduce using rule 73 (vars -> empty .)
    WRITE           reduce using rule 73 (vars -> empty .)
    FOR             reduce using rule 73 (vars -> empty .)
    WHILE           reduce using rule 73 (vars -> empty .)
    IF              reduce using rule 73 (vars -> empty .)
    RETURN          reduce using rule 73 (vars -> empty .)
    RCURLY          reduce using rule 73 (vars -> empty .)
    LCURLY          reduce using rule 73 (vars -> empty .)


state 11

    (6) program2 -> principal .

    $end            reduce using rule 6 (program2 -> principal .)


state 12

    (74) var -> VARS . var2
    (75) var2 -> . var2 type TWOPOINTS var1 SEMMICOLON addVar
    (76) var2 -> . empty
    (104) empty -> .

    INT             reduce using rule 104 (empty -> .)
    CHAR            reduce using rule 104 (empty -> .)
    FLOAT           reduce using rule 104 (empty -> .)
    FUNCTION        reduce using rule 104 (empty -> .)
    PRINCIPAL       reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)
    ID              reduce using rule 104 (empty -> .)
    READ            reduce using rule 104 (empty -> .)
    WRITE           reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    WHILE           reduce using rule 104 (empty -> .)
    IF              reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    RCURLY          reduce using rule 104 (empty -> .)
    LCURLY          reduce using rule 104 (empty -> .)

    var2                           shift and go to state 17
    empty                          shift and go to state 18

state 13

    (7) principal -> PRINCIPAL . LPAREN RPAREN LCURLY vars statements RCURLY

    LPAREN          shift and go to state 19


state 14

    (3) program1 -> vars functions . program2
    (4) program1 -> vars functions .
    (6) program2 -> . principal
    (7) principal -> . PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY

    $end            reduce using rule 4 (program1 -> vars functions .)
    PRINCIPAL       shift and go to state 13

    program2                       shift and go to state 20
    principal                      shift and go to state 11

state 15

    (89) functions -> FUNCTION . INT functions1 functions
    (90) functions -> FUNCTION . CHAR functions1 functions
    (91) functions -> FUNCTION . FLOAT functions1 functions
    (92) functions -> FUNCTION . VOID functions1 functions

    INT             shift and go to state 21
    CHAR            shift and go to state 22
    FLOAT           shift and go to state 23
    VOID            shift and go to state 24


state 16

    (93) functions -> empty .

    PRINCIPAL       reduce using rule 93 (functions -> empty .)
    $end            reduce using rule 93 (functions -> empty .)


state 17

    (74) var -> VARS var2 .
    (75) var2 -> var2 . type TWOPOINTS var1 SEMMICOLON addVar
    (84) type -> . INT saveTypeVar
    (85) type -> . CHAR saveTypeVar
    (86) type -> . FLOAT saveTypeVar

    FUNCTION        reduce using rule 74 (var -> VARS var2 .)
    PRINCIPAL       reduce using rule 74 (var -> VARS var2 .)
    $end            reduce using rule 74 (var -> VARS var2 .)
    ID              reduce using rule 74 (var -> VARS var2 .)
    READ            reduce using rule 74 (var -> VARS var2 .)
    WRITE           reduce using rule 74 (var -> VARS var2 .)
    FOR             reduce using rule 74 (var -> VARS var2 .)
    WHILE           reduce using rule 74 (var -> VARS var2 .)
    IF              reduce using rule 74 (var -> VARS var2 .)
    RETURN          reduce using rule 74 (var -> VARS var2 .)
    RCURLY          reduce using rule 74 (var -> VARS var2 .)
    LCURLY          reduce using rule 74 (var -> VARS var2 .)
    INT             shift and go to state 26
    CHAR            shift and go to state 27
    FLOAT           shift and go to state 28

    type                           shift and go to state 25

state 18

    (76) var2 -> empty .

    INT             reduce using rule 76 (var2 -> empty .)
    CHAR            reduce using rule 76 (var2 -> empty .)
    FLOAT           reduce using rule 76 (var2 -> empty .)
    FUNCTION        reduce using rule 76 (var2 -> empty .)
    PRINCIPAL       reduce using rule 76 (var2 -> empty .)
    $end            reduce using rule 76 (var2 -> empty .)
    ID              reduce using rule 76 (var2 -> empty .)
    READ            reduce using rule 76 (var2 -> empty .)
    WRITE           reduce using rule 76 (var2 -> empty .)
    FOR             reduce using rule 76 (var2 -> empty .)
    WHILE           reduce using rule 76 (var2 -> empty .)
    IF              reduce using rule 76 (var2 -> empty .)
    RETURN          reduce using rule 76 (var2 -> empty .)
    RCURLY          reduce using rule 76 (var2 -> empty .)
    LCURLY          reduce using rule 76 (var2 -> empty .)


state 19

    (7) principal -> PRINCIPAL LPAREN . RPAREN LCURLY vars statements RCURLY

    RPAREN          shift and go to state 29


state 20

    (3) program1 -> vars functions program2 .

    $end            reduce using rule 3 (program1 -> vars functions program2 .)


state 21

    (89) functions -> FUNCTION INT . functions1 functions
    (94) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (95) functions1 -> . empty
    (104) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 104 (empty -> .)
    PRINCIPAL       reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    functions1                     shift and go to state 30
    empty                          shift and go to state 32

state 22

    (90) functions -> FUNCTION CHAR . functions1 functions
    (94) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (95) functions1 -> . empty
    (104) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 104 (empty -> .)
    PRINCIPAL       reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    functions1                     shift and go to state 33
    empty                          shift and go to state 32

state 23

    (91) functions -> FUNCTION FLOAT . functions1 functions
    (94) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (95) functions1 -> . empty
    (104) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 104 (empty -> .)
    PRINCIPAL       reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    functions1                     shift and go to state 34
    empty                          shift and go to state 32

state 24

    (92) functions -> FUNCTION VOID . functions1 functions
    (94) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (95) functions1 -> . empty
    (104) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 104 (empty -> .)
    PRINCIPAL       reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    functions1                     shift and go to state 35
    empty                          shift and go to state 32

state 25

    (75) var2 -> var2 type . TWOPOINTS var1 SEMMICOLON addVar

    TWOPOINTS       shift and go to state 36


state 26

    (84) type -> INT . saveTypeVar
    (83) saveTypeVar -> .

    TWOPOINTS       reduce using rule 83 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 37

state 27

    (85) type -> CHAR . saveTypeVar
    (83) saveTypeVar -> .

    TWOPOINTS       reduce using rule 83 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 38

state 28

    (86) type -> FLOAT . saveTypeVar
    (83) saveTypeVar -> .

    TWOPOINTS       reduce using rule 83 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 39

state 29

    (7) principal -> PRINCIPAL LPAREN RPAREN . LCURLY vars statements RCURLY

    LCURLY          shift and go to state 40


state 30

    (89) functions -> FUNCTION INT functions1 . functions
    (89) functions -> . FUNCTION INT functions1 functions
    (90) functions -> . FUNCTION CHAR functions1 functions
    (91) functions -> . FUNCTION FLOAT functions1 functions
    (92) functions -> . FUNCTION VOID functions1 functions
    (93) functions -> . empty
    (104) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    functions                      shift and go to state 41
    empty                          shift and go to state 16

state 31

    (94) functions1 -> ID . saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (96) saveFunction -> .

    LPAREN          reduce using rule 96 (saveFunction -> .)

    saveFunction                   shift and go to state 42

state 32

    (95) functions1 -> empty .

    FUNCTION        reduce using rule 95 (functions1 -> empty .)
    PRINCIPAL       reduce using rule 95 (functions1 -> empty .)
    $end            reduce using rule 95 (functions1 -> empty .)


state 33

    (90) functions -> FUNCTION CHAR functions1 . functions
    (89) functions -> . FUNCTION INT functions1 functions
    (90) functions -> . FUNCTION CHAR functions1 functions
    (91) functions -> . FUNCTION FLOAT functions1 functions
    (92) functions -> . FUNCTION VOID functions1 functions
    (93) functions -> . empty
    (104) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    functions                      shift and go to state 43
    empty                          shift and go to state 16

state 34

    (91) functions -> FUNCTION FLOAT functions1 . functions
    (89) functions -> . FUNCTION INT functions1 functions
    (90) functions -> . FUNCTION CHAR functions1 functions
    (91) functions -> . FUNCTION FLOAT functions1 functions
    (92) functions -> . FUNCTION VOID functions1 functions
    (93) functions -> . empty
    (104) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    functions                      shift and go to state 44
    empty                          shift and go to state 16

state 35

    (92) functions -> FUNCTION VOID functions1 . functions
    (89) functions -> . FUNCTION INT functions1 functions
    (90) functions -> . FUNCTION CHAR functions1 functions
    (91) functions -> . FUNCTION FLOAT functions1 functions
    (92) functions -> . FUNCTION VOID functions1 functions
    (93) functions -> . empty
    (104) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 104 (empty -> .)
    $end            reduce using rule 104 (empty -> .)

    functions                      shift and go to state 45
    empty                          shift and go to state 16

state 36

    (75) var2 -> var2 type TWOPOINTS . var1 SEMMICOLON addVar
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (104) empty -> .

    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 104 (empty -> .)

    var1                           shift and go to state 46
    empty                          shift and go to state 48

state 37

    (84) type -> INT saveTypeVar .

    TWOPOINTS       reduce using rule 84 (type -> INT saveTypeVar .)


state 38

    (85) type -> CHAR saveTypeVar .

    TWOPOINTS       reduce using rule 85 (type -> CHAR saveTypeVar .)


state 39

    (86) type -> FLOAT saveTypeVar .

    TWOPOINTS       reduce using rule 86 (type -> FLOAT saveTypeVar .)


state 40

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY . vars statements RCURLY
    (72) vars -> . var
    (73) vars -> . empty
    (74) var -> . VARS var2
    (104) empty -> .

    VARS            shift and go to state 12
    ID              reduce using rule 104 (empty -> .)
    READ            reduce using rule 104 (empty -> .)
    WRITE           reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    WHILE           reduce using rule 104 (empty -> .)
    IF              reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    RCURLY          reduce using rule 104 (empty -> .)

    vars                           shift and go to state 49
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 41

    (89) functions -> FUNCTION INT functions1 functions .

    PRINCIPAL       reduce using rule 89 (functions -> FUNCTION INT functions1 functions .)
    $end            reduce using rule 89 (functions -> FUNCTION INT functions1 functions .)


state 42

    (94) functions1 -> ID saveFunction . LPAREN args RPAREN vars LCURLY statements RCURLY

    LPAREN          shift and go to state 50


state 43

    (90) functions -> FUNCTION CHAR functions1 functions .

    PRINCIPAL       reduce using rule 90 (functions -> FUNCTION CHAR functions1 functions .)
    $end            reduce using rule 90 (functions -> FUNCTION CHAR functions1 functions .)


state 44

    (91) functions -> FUNCTION FLOAT functions1 functions .

    PRINCIPAL       reduce using rule 91 (functions -> FUNCTION FLOAT functions1 functions .)
    $end            reduce using rule 91 (functions -> FUNCTION FLOAT functions1 functions .)


state 45

    (92) functions -> FUNCTION VOID functions1 functions .

    PRINCIPAL       reduce using rule 92 (functions -> FUNCTION VOID functions1 functions .)
    $end            reduce using rule 92 (functions -> FUNCTION VOID functions1 functions .)


state 46

    (75) var2 -> var2 type TWOPOINTS var1 . SEMMICOLON addVar

    SEMMICOLON      shift and go to state 51


state 47

    (77) var1 -> ID .
    (78) var1 -> ID . COMMA var1 addVar
    (79) var1 -> ID . arr
    (80) var1 -> ID . arr COMMA var1 addVar
    (87) arr -> . LBRACKET CTEI RBRACKET
    (88) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 77 (var1 -> ID .)
    MUL             reduce using rule 77 (var1 -> ID .)
    DIV             reduce using rule 77 (var1 -> ID .)
    PLUS            reduce using rule 77 (var1 -> ID .)
    MINUS           reduce using rule 77 (var1 -> ID .)
    GT              reduce using rule 77 (var1 -> ID .)
    LT              reduce using rule 77 (var1 -> ID .)
    GTE             reduce using rule 77 (var1 -> ID .)
    LTE             reduce using rule 77 (var1 -> ID .)
    NE              reduce using rule 77 (var1 -> ID .)
    AND             reduce using rule 77 (var1 -> ID .)
    OR              reduce using rule 77 (var1 -> ID .)
    RBRACKET        reduce using rule 77 (var1 -> ID .)
    RPAREN          reduce using rule 77 (var1 -> ID .)
    TO              reduce using rule 77 (var1 -> ID .)
    CTEI            reduce using rule 77 (var1 -> ID .)
    CTEF            reduce using rule 77 (var1 -> ID .)
    CTEC            reduce using rule 77 (var1 -> ID .)
    CTESTRING       reduce using rule 77 (var1 -> ID .)
    LPAREN          reduce using rule 77 (var1 -> ID .)
    ID              reduce using rule 77 (var1 -> ID .)
    COMMA           shift and go to state 52
    LBRACKET        shift and go to state 54

  ! COMMA           [ reduce using rule 77 (var1 -> ID .) ]

    arr                            shift and go to state 53

state 48

    (81) var1 -> empty .

    SEMMICOLON      reduce using rule 81 (var1 -> empty .)
    MUL             reduce using rule 81 (var1 -> empty .)
    DIV             reduce using rule 81 (var1 -> empty .)
    PLUS            reduce using rule 81 (var1 -> empty .)
    MINUS           reduce using rule 81 (var1 -> empty .)
    GT              reduce using rule 81 (var1 -> empty .)
    LT              reduce using rule 81 (var1 -> empty .)
    GTE             reduce using rule 81 (var1 -> empty .)
    LTE             reduce using rule 81 (var1 -> empty .)
    NE              reduce using rule 81 (var1 -> empty .)
    AND             reduce using rule 81 (var1 -> empty .)
    OR              reduce using rule 81 (var1 -> empty .)
    RBRACKET        reduce using rule 81 (var1 -> empty .)
    RPAREN          reduce using rule 81 (var1 -> empty .)
    COMMA           reduce using rule 81 (var1 -> empty .)
    TO              reduce using rule 81 (var1 -> empty .)
    CTEI            reduce using rule 81 (var1 -> empty .)
    CTEF            reduce using rule 81 (var1 -> empty .)
    CTEC            reduce using rule 81 (var1 -> empty .)
    CTESTRING       reduce using rule 81 (var1 -> empty .)
    LPAREN          reduce using rule 81 (var1 -> empty .)
    ID              reduce using rule 81 (var1 -> empty .)


state 49

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY vars . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)

    statements                     shift and go to state 55
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 50

    (94) functions1 -> ID saveFunction LPAREN . args RPAREN vars LCURLY statements RCURLY
    (97) args -> . type TWOPOINTS args1
    (98) args -> . empty
    (84) type -> . INT saveTypeVar
    (85) type -> . CHAR saveTypeVar
    (86) type -> . FLOAT saveTypeVar
    (104) empty -> .

    INT             shift and go to state 26
    CHAR            shift and go to state 27
    FLOAT           shift and go to state 28
    RPAREN          reduce using rule 104 (empty -> .)

    args                           shift and go to state 72
    type                           shift and go to state 73
    empty                          shift and go to state 74

state 51

    (75) var2 -> var2 type TWOPOINTS var1 SEMMICOLON . addVar
    (82) addVar -> .

    INT             reduce using rule 82 (addVar -> .)
    CHAR            reduce using rule 82 (addVar -> .)
    FLOAT           reduce using rule 82 (addVar -> .)
    FUNCTION        reduce using rule 82 (addVar -> .)
    PRINCIPAL       reduce using rule 82 (addVar -> .)
    $end            reduce using rule 82 (addVar -> .)
    ID              reduce using rule 82 (addVar -> .)
    READ            reduce using rule 82 (addVar -> .)
    WRITE           reduce using rule 82 (addVar -> .)
    FOR             reduce using rule 82 (addVar -> .)
    WHILE           reduce using rule 82 (addVar -> .)
    IF              reduce using rule 82 (addVar -> .)
    RETURN          reduce using rule 82 (addVar -> .)
    RCURLY          reduce using rule 82 (addVar -> .)
    LCURLY          reduce using rule 82 (addVar -> .)

    addVar                         shift and go to state 75

state 52

    (78) var1 -> ID COMMA . var1 addVar
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (104) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 104 (empty -> .)
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)
    CTEI            reduce using rule 104 (empty -> .)
    CTEF            reduce using rule 104 (empty -> .)
    CTEC            reduce using rule 104 (empty -> .)
    CTESTRING       reduce using rule 104 (empty -> .)
    LPAREN          reduce using rule 104 (empty -> .)

  ! ID              [ reduce using rule 104 (empty -> .) ]

    var1                           shift and go to state 76
    empty                          shift and go to state 48

state 53

    (79) var1 -> ID arr .
    (80) var1 -> ID arr . COMMA var1 addVar

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 79 (var1 -> ID arr .)
    MUL             reduce using rule 79 (var1 -> ID arr .)
    DIV             reduce using rule 79 (var1 -> ID arr .)
    PLUS            reduce using rule 79 (var1 -> ID arr .)
    MINUS           reduce using rule 79 (var1 -> ID arr .)
    GT              reduce using rule 79 (var1 -> ID arr .)
    LT              reduce using rule 79 (var1 -> ID arr .)
    GTE             reduce using rule 79 (var1 -> ID arr .)
    LTE             reduce using rule 79 (var1 -> ID arr .)
    NE              reduce using rule 79 (var1 -> ID arr .)
    AND             reduce using rule 79 (var1 -> ID arr .)
    OR              reduce using rule 79 (var1 -> ID arr .)
    RBRACKET        reduce using rule 79 (var1 -> ID arr .)
    RPAREN          reduce using rule 79 (var1 -> ID arr .)
    TO              reduce using rule 79 (var1 -> ID arr .)
    CTEI            reduce using rule 79 (var1 -> ID arr .)
    CTEF            reduce using rule 79 (var1 -> ID arr .)
    CTEC            reduce using rule 79 (var1 -> ID arr .)
    CTESTRING       reduce using rule 79 (var1 -> ID arr .)
    LPAREN          reduce using rule 79 (var1 -> ID arr .)
    ID              reduce using rule 79 (var1 -> ID arr .)
    COMMA           shift and go to state 77

  ! COMMA           [ reduce using rule 79 (var1 -> ID arr .) ]


state 54

    (87) arr -> LBRACKET . CTEI RBRACKET
    (88) arr -> LBRACKET . exp RBRACKET
    (47) exp -> . nexp generateQuadOR
    (48) exp -> . nexp generateQuadOR OR saveOperator nexp
    (49) nexp -> . compexp generateQuadAND
    (50) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    CTEI            shift and go to state 78
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)

    exp                            shift and go to state 79
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 55

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements . RCURLY

    RCURLY          shift and go to state 93


state 56

    (8) statements -> assign . SEMMICOLON statements

    SEMMICOLON      shift and go to state 94


state 57

    (9) statements -> functionCall . SEMMICOLON statements

    SEMMICOLON      shift and go to state 95


state 58

    (10) statements -> read . statements SEMMICOLON statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    SEMMICOLON      reduce using rule 104 (empty -> .)

    read                           shift and go to state 58
    statements                     shift and go to state 96
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 59

    (11) statements -> write . statements SEMMICOLON statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    SEMMICOLON      reduce using rule 104 (empty -> .)

    write                          shift and go to state 59
    statements                     shift and go to state 97
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 60

    (12) statements -> for . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)

    for                            shift and go to state 60
    statements                     shift and go to state 98
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 61

    (13) statements -> while . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)

    while                          shift and go to state 61
    statements                     shift and go to state 99
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 62

    (14) statements -> if . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)

    if                             shift and go to state 62
    statements                     shift and go to state 100
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 63

    (15) statements -> return . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)

    return                         shift and go to state 63
    statements                     shift and go to state 101
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    empty                          shift and go to state 64

state 64

    (16) statements -> empty .

    RCURLY          reduce using rule 16 (statements -> empty .)
    SEMMICOLON      reduce using rule 16 (statements -> empty .)


state 65

    (17) assign -> ID . add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> ID . add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> ID . LPAREN exp RPAREN
    (21) add_id2 -> .

    LPAREN          shift and go to state 103
    EQUALS          reduce using rule 21 (add_id2 -> .)
    LBRACKET        reduce using rule 21 (add_id2 -> .)

    add_id2                        shift and go to state 102

state 66

    (23) read -> READ . operatorRead LPAREN var1 generateQuadREAD RPAREN
    (24) operatorRead -> .

    LPAREN          reduce using rule 24 (operatorRead -> .)

    operatorRead                   shift and go to state 104

state 67

    (26) write -> WRITE . LPAREN write1 RPAREN

    LPAREN          shift and go to state 105


state 68

    (33) for -> FOR . assign TO CTEI DO LCURLY statements RCURLY
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad

    ID              shift and go to state 107

    assign                         shift and go to state 106

state 69

    (34) while -> WHILE . LPAREN exp RPAREN DO LCURLY statements RCURLY

    LPAREN          shift and go to state 108


state 70

    (35) if -> IF . LPAREN exp RPAREN THEN LCURLY statements RCURLY else

    LPAREN          shift and go to state 109


state 71

    (102) return -> RETURN . LPAREN exp RPAREN SEMMICOLON
    (103) return -> RETURN . LPAREN exp RPAREN

    LPAREN          shift and go to state 110


state 72

    (94) functions1 -> ID saveFunction LPAREN args . RPAREN vars LCURLY statements RCURLY

    RPAREN          shift and go to state 111


state 73

    (97) args -> type . TWOPOINTS args1

    TWOPOINTS       shift and go to state 112


state 74

    (98) args -> empty .

    RPAREN          reduce using rule 98 (args -> empty .)


state 75

    (75) var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .

    INT             reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    CHAR            reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FLOAT           reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FUNCTION        reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    PRINCIPAL       reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    $end            reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    ID              reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    READ            reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WRITE           reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FOR             reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WHILE           reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    IF              reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    RETURN          reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    RCURLY          reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    LCURLY          reduce using rule 75 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)


state 76

    (78) var1 -> ID COMMA var1 . addVar
    (82) addVar -> .

    SEMMICOLON      reduce using rule 82 (addVar -> .)
    MUL             reduce using rule 82 (addVar -> .)
    DIV             reduce using rule 82 (addVar -> .)
    PLUS            reduce using rule 82 (addVar -> .)
    MINUS           reduce using rule 82 (addVar -> .)
    GT              reduce using rule 82 (addVar -> .)
    LT              reduce using rule 82 (addVar -> .)
    GTE             reduce using rule 82 (addVar -> .)
    LTE             reduce using rule 82 (addVar -> .)
    NE              reduce using rule 82 (addVar -> .)
    AND             reduce using rule 82 (addVar -> .)
    OR              reduce using rule 82 (addVar -> .)
    RBRACKET        reduce using rule 82 (addVar -> .)
    RPAREN          reduce using rule 82 (addVar -> .)
    COMMA           reduce using rule 82 (addVar -> .)
    TO              reduce using rule 82 (addVar -> .)
    CTEI            reduce using rule 82 (addVar -> .)
    CTEF            reduce using rule 82 (addVar -> .)
    CTEC            reduce using rule 82 (addVar -> .)
    CTESTRING       reduce using rule 82 (addVar -> .)
    LPAREN          reduce using rule 82 (addVar -> .)
    ID              reduce using rule 82 (addVar -> .)

    addVar                         shift and go to state 113

state 77

    (80) var1 -> ID arr COMMA . var1 addVar
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (104) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 104 (empty -> .)
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)
    CTEI            reduce using rule 104 (empty -> .)
    CTEF            reduce using rule 104 (empty -> .)
    CTEC            reduce using rule 104 (empty -> .)
    CTESTRING       reduce using rule 104 (empty -> .)
    LPAREN          reduce using rule 104 (empty -> .)

  ! ID              [ reduce using rule 104 (empty -> .) ]

    var1                           shift and go to state 114
    empty                          shift and go to state 48

state 78

    (87) arr -> LBRACKET CTEI . RBRACKET
    (65) pexp -> CTEI . saveCTE
    (46) saveCTE -> .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 115
    MUL             reduce using rule 46 (saveCTE -> .)
    DIV             reduce using rule 46 (saveCTE -> .)
    PLUS            reduce using rule 46 (saveCTE -> .)
    MINUS           reduce using rule 46 (saveCTE -> .)
    GT              reduce using rule 46 (saveCTE -> .)
    LT              reduce using rule 46 (saveCTE -> .)
    GTE             reduce using rule 46 (saveCTE -> .)
    LTE             reduce using rule 46 (saveCTE -> .)
    NE              reduce using rule 46 (saveCTE -> .)
    AND             reduce using rule 46 (saveCTE -> .)
    OR              reduce using rule 46 (saveCTE -> .)

  ! RBRACKET        [ reduce using rule 46 (saveCTE -> .) ]

    saveCTE                        shift and go to state 116

state 79

    (88) arr -> LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 117


state 80

    (47) exp -> nexp . generateQuadOR
    (48) exp -> nexp . generateQuadOR OR saveOperator nexp
    (38) generateQuadOR -> .

    OR              reduce using rule 38 (generateQuadOR -> .)
    RBRACKET        reduce using rule 38 (generateQuadOR -> .)
    RPAREN          reduce using rule 38 (generateQuadOR -> .)
    COMMA           reduce using rule 38 (generateQuadOR -> .)
    SEMMICOLON      reduce using rule 38 (generateQuadOR -> .)
    TO              reduce using rule 38 (generateQuadOR -> .)

    generateQuadOR                 shift and go to state 118

state 81

    (49) nexp -> compexp . generateQuadAND
    (50) nexp -> compexp . generateQuadAND AND saveOperator compexp
    (39) generateQuadAND -> .

    AND             reduce using rule 39 (generateQuadAND -> .)
    OR              reduce using rule 39 (generateQuadAND -> .)
    RBRACKET        reduce using rule 39 (generateQuadAND -> .)
    RPAREN          reduce using rule 39 (generateQuadAND -> .)
    COMMA           reduce using rule 39 (generateQuadAND -> .)
    SEMMICOLON      reduce using rule 39 (generateQuadAND -> .)
    TO              reduce using rule 39 (generateQuadAND -> .)

    generateQuadAND                shift and go to state 119

state 82

    (51) compexp -> sumexp .
    (53) compexp1 -> sumexp . GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> sumexp . LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> sumexp . GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> sumexp . LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> sumexp . NE saveOperator sumexp generateQuadCOMPARE

    AND             reduce using rule 51 (compexp -> sumexp .)
    OR              reduce using rule 51 (compexp -> sumexp .)
    RBRACKET        reduce using rule 51 (compexp -> sumexp .)
    RPAREN          reduce using rule 51 (compexp -> sumexp .)
    COMMA           reduce using rule 51 (compexp -> sumexp .)
    SEMMICOLON      reduce using rule 51 (compexp -> sumexp .)
    TO              reduce using rule 51 (compexp -> sumexp .)
    GT              shift and go to state 120
    LT              shift and go to state 121
    GTE             shift and go to state 122
    LTE             shift and go to state 123
    NE              shift and go to state 124


state 83

    (52) compexp -> compexp1 . sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)

    sumexp                         shift and go to state 125
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 84

    (58) sumexp -> mulexp .
    (59) sumexp -> mulexp . PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> mulexp . MINUS saveOperator mulexp generateQuadSUM

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    GT              reduce using rule 58 (sumexp -> mulexp .)
    LT              reduce using rule 58 (sumexp -> mulexp .)
    GTE             reduce using rule 58 (sumexp -> mulexp .)
    LTE             reduce using rule 58 (sumexp -> mulexp .)
    NE              reduce using rule 58 (sumexp -> mulexp .)
    AND             reduce using rule 58 (sumexp -> mulexp .)
    OR              reduce using rule 58 (sumexp -> mulexp .)
    RBRACKET        reduce using rule 58 (sumexp -> mulexp .)
    RPAREN          reduce using rule 58 (sumexp -> mulexp .)
    COMMA           reduce using rule 58 (sumexp -> mulexp .)
    SEMMICOLON      reduce using rule 58 (sumexp -> mulexp .)
    TO              reduce using rule 58 (sumexp -> mulexp .)
    CTEI            reduce using rule 58 (sumexp -> mulexp .)
    CTEF            reduce using rule 58 (sumexp -> mulexp .)
    CTEC            reduce using rule 58 (sumexp -> mulexp .)
    CTESTRING       reduce using rule 58 (sumexp -> mulexp .)
    LPAREN          reduce using rule 58 (sumexp -> mulexp .)
    ID              reduce using rule 58 (sumexp -> mulexp .)
    MUL             reduce using rule 58 (sumexp -> mulexp .)
    DIV             reduce using rule 58 (sumexp -> mulexp .)
    PLUS            shift and go to state 127
    MINUS           shift and go to state 128

  ! PLUS            [ reduce using rule 58 (sumexp -> mulexp .) ]
  ! MINUS           [ reduce using rule 58 (sumexp -> mulexp .) ]


state 85

    (61) mulexp -> pexp .
    (62) mulexp -> pexp . MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> pexp . DIV saveOperator pexp generateQuadMUL

  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    PLUS            reduce using rule 61 (mulexp -> pexp .)
    MINUS           reduce using rule 61 (mulexp -> pexp .)
    GT              reduce using rule 61 (mulexp -> pexp .)
    LT              reduce using rule 61 (mulexp -> pexp .)
    GTE             reduce using rule 61 (mulexp -> pexp .)
    LTE             reduce using rule 61 (mulexp -> pexp .)
    NE              reduce using rule 61 (mulexp -> pexp .)
    AND             reduce using rule 61 (mulexp -> pexp .)
    OR              reduce using rule 61 (mulexp -> pexp .)
    RBRACKET        reduce using rule 61 (mulexp -> pexp .)
    RPAREN          reduce using rule 61 (mulexp -> pexp .)
    COMMA           reduce using rule 61 (mulexp -> pexp .)
    SEMMICOLON      reduce using rule 61 (mulexp -> pexp .)
    TO              reduce using rule 61 (mulexp -> pexp .)
    CTEI            reduce using rule 61 (mulexp -> pexp .)
    CTEF            reduce using rule 61 (mulexp -> pexp .)
    CTEC            reduce using rule 61 (mulexp -> pexp .)
    CTESTRING       reduce using rule 61 (mulexp -> pexp .)
    LPAREN          reduce using rule 61 (mulexp -> pexp .)
    ID              reduce using rule 61 (mulexp -> pexp .)
    MUL             shift and go to state 129
    DIV             shift and go to state 130

  ! MUL             [ reduce using rule 61 (mulexp -> pexp .) ]
  ! DIV             [ reduce using rule 61 (mulexp -> pexp .) ]


state 86

    (64) pexp -> var1 . add_id
    (20) add_id -> .

    MUL             reduce using rule 20 (add_id -> .)
    DIV             reduce using rule 20 (add_id -> .)
    PLUS            reduce using rule 20 (add_id -> .)
    MINUS           reduce using rule 20 (add_id -> .)
    GT              reduce using rule 20 (add_id -> .)
    LT              reduce using rule 20 (add_id -> .)
    GTE             reduce using rule 20 (add_id -> .)
    LTE             reduce using rule 20 (add_id -> .)
    NE              reduce using rule 20 (add_id -> .)
    AND             reduce using rule 20 (add_id -> .)
    OR              reduce using rule 20 (add_id -> .)
    RBRACKET        reduce using rule 20 (add_id -> .)
    RPAREN          reduce using rule 20 (add_id -> .)
    COMMA           reduce using rule 20 (add_id -> .)
    SEMMICOLON      reduce using rule 20 (add_id -> .)
    TO              reduce using rule 20 (add_id -> .)
    CTEI            reduce using rule 20 (add_id -> .)
    CTEF            reduce using rule 20 (add_id -> .)
    CTEC            reduce using rule 20 (add_id -> .)
    CTESTRING       reduce using rule 20 (add_id -> .)
    LPAREN          reduce using rule 20 (add_id -> .)
    ID              reduce using rule 20 (add_id -> .)

    add_id                         shift and go to state 131

state 87

    (66) pexp -> CTEF . saveCTE
    (46) saveCTE -> .

    MUL             reduce using rule 46 (saveCTE -> .)
    DIV             reduce using rule 46 (saveCTE -> .)
    PLUS            reduce using rule 46 (saveCTE -> .)
    MINUS           reduce using rule 46 (saveCTE -> .)
    GT              reduce using rule 46 (saveCTE -> .)
    LT              reduce using rule 46 (saveCTE -> .)
    GTE             reduce using rule 46 (saveCTE -> .)
    LTE             reduce using rule 46 (saveCTE -> .)
    NE              reduce using rule 46 (saveCTE -> .)
    AND             reduce using rule 46 (saveCTE -> .)
    OR              reduce using rule 46 (saveCTE -> .)
    RBRACKET        reduce using rule 46 (saveCTE -> .)
    RPAREN          reduce using rule 46 (saveCTE -> .)
    COMMA           reduce using rule 46 (saveCTE -> .)
    SEMMICOLON      reduce using rule 46 (saveCTE -> .)
    TO              reduce using rule 46 (saveCTE -> .)
    CTEI            reduce using rule 46 (saveCTE -> .)
    CTEF            reduce using rule 46 (saveCTE -> .)
    CTEC            reduce using rule 46 (saveCTE -> .)
    CTESTRING       reduce using rule 46 (saveCTE -> .)
    LPAREN          reduce using rule 46 (saveCTE -> .)
    ID              reduce using rule 46 (saveCTE -> .)

    saveCTE                        shift and go to state 132

state 88

    (67) pexp -> CTEC . saveCTE
    (46) saveCTE -> .

    MUL             reduce using rule 46 (saveCTE -> .)
    DIV             reduce using rule 46 (saveCTE -> .)
    PLUS            reduce using rule 46 (saveCTE -> .)
    MINUS           reduce using rule 46 (saveCTE -> .)
    GT              reduce using rule 46 (saveCTE -> .)
    LT              reduce using rule 46 (saveCTE -> .)
    GTE             reduce using rule 46 (saveCTE -> .)
    LTE             reduce using rule 46 (saveCTE -> .)
    NE              reduce using rule 46 (saveCTE -> .)
    AND             reduce using rule 46 (saveCTE -> .)
    OR              reduce using rule 46 (saveCTE -> .)
    RBRACKET        reduce using rule 46 (saveCTE -> .)
    RPAREN          reduce using rule 46 (saveCTE -> .)
    COMMA           reduce using rule 46 (saveCTE -> .)
    SEMMICOLON      reduce using rule 46 (saveCTE -> .)
    TO              reduce using rule 46 (saveCTE -> .)
    CTEI            reduce using rule 46 (saveCTE -> .)
    CTEF            reduce using rule 46 (saveCTE -> .)
    CTEC            reduce using rule 46 (saveCTE -> .)
    CTESTRING       reduce using rule 46 (saveCTE -> .)
    LPAREN          reduce using rule 46 (saveCTE -> .)
    ID              reduce using rule 46 (saveCTE -> .)

    saveCTE                        shift and go to state 133

state 89

    (68) pexp -> CTESTRING . saveCTE
    (46) saveCTE -> .

    MUL             reduce using rule 46 (saveCTE -> .)
    DIV             reduce using rule 46 (saveCTE -> .)
    PLUS            reduce using rule 46 (saveCTE -> .)
    MINUS           reduce using rule 46 (saveCTE -> .)
    GT              reduce using rule 46 (saveCTE -> .)
    LT              reduce using rule 46 (saveCTE -> .)
    GTE             reduce using rule 46 (saveCTE -> .)
    LTE             reduce using rule 46 (saveCTE -> .)
    NE              reduce using rule 46 (saveCTE -> .)
    AND             reduce using rule 46 (saveCTE -> .)
    OR              reduce using rule 46 (saveCTE -> .)
    RBRACKET        reduce using rule 46 (saveCTE -> .)
    RPAREN          reduce using rule 46 (saveCTE -> .)
    COMMA           reduce using rule 46 (saveCTE -> .)
    SEMMICOLON      reduce using rule 46 (saveCTE -> .)
    TO              reduce using rule 46 (saveCTE -> .)
    CTEI            reduce using rule 46 (saveCTE -> .)
    CTEF            reduce using rule 46 (saveCTE -> .)
    CTEC            reduce using rule 46 (saveCTE -> .)
    CTESTRING       reduce using rule 46 (saveCTE -> .)
    LPAREN          reduce using rule 46 (saveCTE -> .)
    ID              reduce using rule 46 (saveCTE -> .)

    saveCTE                        shift and go to state 134

state 90

    (69) pexp -> functionCall .

    MUL             reduce using rule 69 (pexp -> functionCall .)
    DIV             reduce using rule 69 (pexp -> functionCall .)
    PLUS            reduce using rule 69 (pexp -> functionCall .)
    MINUS           reduce using rule 69 (pexp -> functionCall .)
    GT              reduce using rule 69 (pexp -> functionCall .)
    LT              reduce using rule 69 (pexp -> functionCall .)
    GTE             reduce using rule 69 (pexp -> functionCall .)
    LTE             reduce using rule 69 (pexp -> functionCall .)
    NE              reduce using rule 69 (pexp -> functionCall .)
    AND             reduce using rule 69 (pexp -> functionCall .)
    OR              reduce using rule 69 (pexp -> functionCall .)
    RBRACKET        reduce using rule 69 (pexp -> functionCall .)
    RPAREN          reduce using rule 69 (pexp -> functionCall .)
    COMMA           reduce using rule 69 (pexp -> functionCall .)
    SEMMICOLON      reduce using rule 69 (pexp -> functionCall .)
    TO              reduce using rule 69 (pexp -> functionCall .)
    CTEI            reduce using rule 69 (pexp -> functionCall .)
    CTEF            reduce using rule 69 (pexp -> functionCall .)
    CTEC            reduce using rule 69 (pexp -> functionCall .)
    CTESTRING       reduce using rule 69 (pexp -> functionCall .)
    LPAREN          reduce using rule 69 (pexp -> functionCall .)
    ID              reduce using rule 69 (pexp -> functionCall .)


state 91

    (70) pexp -> LPAREN . exp RPAREN
    (47) exp -> . nexp generateQuadOR
    (48) exp -> . nexp generateQuadOR OR saveOperator nexp
    (49) nexp -> . compexp generateQuadAND
    (50) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    exp                            shift and go to state 135
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 92

    (77) var1 -> ID .
    (78) var1 -> ID . COMMA var1 addVar
    (79) var1 -> ID . arr
    (80) var1 -> ID . arr COMMA var1 addVar
    (22) functionCall -> ID . LPAREN exp RPAREN
    (87) arr -> . LBRACKET CTEI RBRACKET
    (88) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    MUL             reduce using rule 77 (var1 -> ID .)
    DIV             reduce using rule 77 (var1 -> ID .)
    PLUS            reduce using rule 77 (var1 -> ID .)
    MINUS           reduce using rule 77 (var1 -> ID .)
    GT              reduce using rule 77 (var1 -> ID .)
    LT              reduce using rule 77 (var1 -> ID .)
    GTE             reduce using rule 77 (var1 -> ID .)
    LTE             reduce using rule 77 (var1 -> ID .)
    NE              reduce using rule 77 (var1 -> ID .)
    AND             reduce using rule 77 (var1 -> ID .)
    OR              reduce using rule 77 (var1 -> ID .)
    RBRACKET        reduce using rule 77 (var1 -> ID .)
    RPAREN          reduce using rule 77 (var1 -> ID .)
    SEMMICOLON      reduce using rule 77 (var1 -> ID .)
    TO              reduce using rule 77 (var1 -> ID .)
    CTEI            reduce using rule 77 (var1 -> ID .)
    CTEF            reduce using rule 77 (var1 -> ID .)
    CTEC            reduce using rule 77 (var1 -> ID .)
    CTESTRING       reduce using rule 77 (var1 -> ID .)
    ID              reduce using rule 77 (var1 -> ID .)
    COMMA           shift and go to state 52
    LPAREN          shift and go to state 103
    LBRACKET        shift and go to state 54

  ! COMMA           [ reduce using rule 77 (var1 -> ID .) ]
  ! LPAREN          [ reduce using rule 77 (var1 -> ID .) ]

    arr                            shift and go to state 53

state 93

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY .

    $end            reduce using rule 7 (principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY .)


state 94

    (8) statements -> assign SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)

    assign                         shift and go to state 56
    statements                     shift and go to state 136
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 95

    (9) statements -> functionCall SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)

    functionCall                   shift and go to state 57
    statements                     shift and go to state 137
    assign                         shift and go to state 56
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 96

    (10) statements -> read statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 138


state 97

    (11) statements -> write statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 139


state 98

    (12) statements -> for statements .

    RCURLY          reduce using rule 12 (statements -> for statements .)
    SEMMICOLON      reduce using rule 12 (statements -> for statements .)


state 99

    (13) statements -> while statements .

    RCURLY          reduce using rule 13 (statements -> while statements .)
    SEMMICOLON      reduce using rule 13 (statements -> while statements .)


state 100

    (14) statements -> if statements .

    RCURLY          reduce using rule 14 (statements -> if statements .)
    SEMMICOLON      reduce using rule 14 (statements -> if statements .)


state 101

    (15) statements -> return statements .

    RCURLY          reduce using rule 15 (statements -> return statements .)
    SEMMICOLON      reduce using rule 15 (statements -> return statements .)


state 102

    (17) assign -> ID add_id2 . EQUALS saveOperator exp generateAssignQuad
    (18) assign -> ID add_id2 . arr EQUALS saveOperator exp generateAssignQuad
    (87) arr -> . LBRACKET CTEI RBRACKET
    (88) arr -> . LBRACKET exp RBRACKET

    EQUALS          shift and go to state 140
    LBRACKET        shift and go to state 54

    arr                            shift and go to state 141

state 103

    (22) functionCall -> ID LPAREN . exp RPAREN
    (47) exp -> . nexp generateQuadOR
    (48) exp -> . nexp generateQuadOR OR saveOperator nexp
    (49) nexp -> . compexp generateQuadAND
    (50) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    exp                            shift and go to state 142
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 104

    (23) read -> READ operatorRead . LPAREN var1 generateQuadREAD RPAREN

    LPAREN          shift and go to state 143


state 105

    (26) write -> WRITE LPAREN . write1 RPAREN
    (27) write1 -> . write2 COMMA write2
    (28) write1 -> . write2
    (29) write2 -> . COMILLA CTESTRING COMILLA
    (30) write2 -> . CTEI saveCTE generateQuadPRINT
    (31) write2 -> . CTEF saveCTE generateQuadPRINT
    (32) write2 -> . exp
    (47) exp -> . nexp generateQuadOR
    (48) exp -> . nexp generateQuadOR OR saveOperator nexp
    (49) nexp -> . compexp generateQuadAND
    (50) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    COMILLA         shift and go to state 146
    CTEI            shift and go to state 147
    CTEF            shift and go to state 148
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    write1                         shift and go to state 144
    write2                         shift and go to state 145
    exp                            shift and go to state 149
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 106

    (33) for -> FOR assign . TO CTEI DO LCURLY statements RCURLY

    TO              shift and go to state 150


state 107

    (17) assign -> ID . add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> ID . add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (21) add_id2 -> .

    EQUALS          reduce using rule 21 (add_id2 -> .)
    LBRACKET        reduce using rule 21 (add_id2 -> .)

    add_id2                        shift and go to state 102

state 108

    (34) while -> WHILE LPAREN . exp RPAREN DO LCURLY statements RCURLY
    (47) exp -> . nexp generateQuadOR
    (48) exp -> . nexp generateQuadOR OR saveOperator nexp
    (49) nexp -> . compexp generateQuadAND
    (50) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    exp                            shift and go to state 151
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 109

    (35) if -> IF LPAREN . exp RPAREN THEN LCURLY statements RCURLY else
    (47) exp -> . nexp generateQuadOR
    (48) exp -> . nexp generateQuadOR OR saveOperator nexp
    (49) nexp -> . compexp generateQuadAND
    (50) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    exp                            shift and go to state 152
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 110

    (102) return -> RETURN LPAREN . exp RPAREN SEMMICOLON
    (103) return -> RETURN LPAREN . exp RPAREN
    (47) exp -> . nexp generateQuadOR
    (48) exp -> . nexp generateQuadOR OR saveOperator nexp
    (49) nexp -> . compexp generateQuadAND
    (50) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    exp                            shift and go to state 153
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 111

    (94) functions1 -> ID saveFunction LPAREN args RPAREN . vars LCURLY statements RCURLY
    (72) vars -> . var
    (73) vars -> . empty
    (74) var -> . VARS var2
    (104) empty -> .

    VARS            shift and go to state 12
    LCURLY          reduce using rule 104 (empty -> .)

    vars                           shift and go to state 154
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 112

    (97) args -> type TWOPOINTS . args1
    (99) args1 -> . ID
    (100) args1 -> . ID COMMA args1
    (101) args1 -> . empty
    (104) empty -> .

    ID              shift and go to state 156
    RPAREN          reduce using rule 104 (empty -> .)

    args1                          shift and go to state 155
    empty                          shift and go to state 157

state 113

    (78) var1 -> ID COMMA var1 addVar .

    SEMMICOLON      reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    MUL             reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    DIV             reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    PLUS            reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    MINUS           reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    GT              reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    LT              reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    GTE             reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    LTE             reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    NE              reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    AND             reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    OR              reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    RBRACKET        reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    RPAREN          reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    COMMA           reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    TO              reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    CTEI            reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    CTEF            reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    CTEC            reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    CTESTRING       reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    LPAREN          reduce using rule 78 (var1 -> ID COMMA var1 addVar .)
    ID              reduce using rule 78 (var1 -> ID COMMA var1 addVar .)


state 114

    (80) var1 -> ID arr COMMA var1 . addVar
    (82) addVar -> .

    SEMMICOLON      reduce using rule 82 (addVar -> .)
    MUL             reduce using rule 82 (addVar -> .)
    DIV             reduce using rule 82 (addVar -> .)
    PLUS            reduce using rule 82 (addVar -> .)
    MINUS           reduce using rule 82 (addVar -> .)
    GT              reduce using rule 82 (addVar -> .)
    LT              reduce using rule 82 (addVar -> .)
    GTE             reduce using rule 82 (addVar -> .)
    LTE             reduce using rule 82 (addVar -> .)
    NE              reduce using rule 82 (addVar -> .)
    AND             reduce using rule 82 (addVar -> .)
    OR              reduce using rule 82 (addVar -> .)
    RBRACKET        reduce using rule 82 (addVar -> .)
    RPAREN          reduce using rule 82 (addVar -> .)
    COMMA           reduce using rule 82 (addVar -> .)
    TO              reduce using rule 82 (addVar -> .)
    CTEI            reduce using rule 82 (addVar -> .)
    CTEF            reduce using rule 82 (addVar -> .)
    CTEC            reduce using rule 82 (addVar -> .)
    CTESTRING       reduce using rule 82 (addVar -> .)
    LPAREN          reduce using rule 82 (addVar -> .)
    ID              reduce using rule 82 (addVar -> .)

    addVar                         shift and go to state 158

state 115

    (87) arr -> LBRACKET CTEI RBRACKET .

    COMMA           reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    SEMMICOLON      reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    MUL             reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    DIV             reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    PLUS            reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    MINUS           reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    GT              reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    LT              reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    GTE             reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    LTE             reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    NE              reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    AND             reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    OR              reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    RBRACKET        reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    RPAREN          reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    TO              reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    CTEI            reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    CTEF            reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    CTEC            reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    CTESTRING       reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    LPAREN          reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    ID              reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)
    EQUALS          reduce using rule 87 (arr -> LBRACKET CTEI RBRACKET .)


state 116

    (65) pexp -> CTEI saveCTE .

    MUL             reduce using rule 65 (pexp -> CTEI saveCTE .)
    DIV             reduce using rule 65 (pexp -> CTEI saveCTE .)
    PLUS            reduce using rule 65 (pexp -> CTEI saveCTE .)
    MINUS           reduce using rule 65 (pexp -> CTEI saveCTE .)
    GT              reduce using rule 65 (pexp -> CTEI saveCTE .)
    LT              reduce using rule 65 (pexp -> CTEI saveCTE .)
    GTE             reduce using rule 65 (pexp -> CTEI saveCTE .)
    LTE             reduce using rule 65 (pexp -> CTEI saveCTE .)
    NE              reduce using rule 65 (pexp -> CTEI saveCTE .)
    AND             reduce using rule 65 (pexp -> CTEI saveCTE .)
    OR              reduce using rule 65 (pexp -> CTEI saveCTE .)
    RBRACKET        reduce using rule 65 (pexp -> CTEI saveCTE .)
    RPAREN          reduce using rule 65 (pexp -> CTEI saveCTE .)
    COMMA           reduce using rule 65 (pexp -> CTEI saveCTE .)
    SEMMICOLON      reduce using rule 65 (pexp -> CTEI saveCTE .)
    TO              reduce using rule 65 (pexp -> CTEI saveCTE .)
    CTEI            reduce using rule 65 (pexp -> CTEI saveCTE .)
    CTEF            reduce using rule 65 (pexp -> CTEI saveCTE .)
    CTEC            reduce using rule 65 (pexp -> CTEI saveCTE .)
    CTESTRING       reduce using rule 65 (pexp -> CTEI saveCTE .)
    LPAREN          reduce using rule 65 (pexp -> CTEI saveCTE .)
    ID              reduce using rule 65 (pexp -> CTEI saveCTE .)


state 117

    (88) arr -> LBRACKET exp RBRACKET .

    COMMA           reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    SEMMICOLON      reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    MUL             reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    DIV             reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    GT              reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    LT              reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    GTE             reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    LTE             reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    NE              reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    AND             reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    OR              reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    TO              reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    CTEI            reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    CTEF            reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    CTEC            reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    CTESTRING       reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    ID              reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 88 (arr -> LBRACKET exp RBRACKET .)


state 118

    (47) exp -> nexp generateQuadOR .
    (48) exp -> nexp generateQuadOR . OR saveOperator nexp

    RBRACKET        reduce using rule 47 (exp -> nexp generateQuadOR .)
    RPAREN          reduce using rule 47 (exp -> nexp generateQuadOR .)
    COMMA           reduce using rule 47 (exp -> nexp generateQuadOR .)
    SEMMICOLON      reduce using rule 47 (exp -> nexp generateQuadOR .)
    TO              reduce using rule 47 (exp -> nexp generateQuadOR .)
    OR              shift and go to state 159


state 119

    (49) nexp -> compexp generateQuadAND .
    (50) nexp -> compexp generateQuadAND . AND saveOperator compexp

    OR              reduce using rule 49 (nexp -> compexp generateQuadAND .)
    RBRACKET        reduce using rule 49 (nexp -> compexp generateQuadAND .)
    RPAREN          reduce using rule 49 (nexp -> compexp generateQuadAND .)
    COMMA           reduce using rule 49 (nexp -> compexp generateQuadAND .)
    SEMMICOLON      reduce using rule 49 (nexp -> compexp generateQuadAND .)
    TO              reduce using rule 49 (nexp -> compexp generateQuadAND .)
    AND             shift and go to state 160


state 120

    (53) compexp1 -> sumexp GT . saveOperator sumexp generateQuadCOMPARE
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    RBRACKET        reduce using rule 71 (saveOperator -> .)
    RPAREN          reduce using rule 71 (saveOperator -> .)
    COMMA           reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 161

state 121

    (54) compexp1 -> sumexp LT . saveOperator sumexp generateQuadCOMPARE
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    RBRACKET        reduce using rule 71 (saveOperator -> .)
    RPAREN          reduce using rule 71 (saveOperator -> .)
    COMMA           reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 162

state 122

    (55) compexp1 -> sumexp GTE . saveOperator sumexp generateQuadCOMPARE
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    RBRACKET        reduce using rule 71 (saveOperator -> .)
    RPAREN          reduce using rule 71 (saveOperator -> .)
    COMMA           reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 163

state 123

    (56) compexp1 -> sumexp LTE . saveOperator sumexp generateQuadCOMPARE
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    RBRACKET        reduce using rule 71 (saveOperator -> .)
    RPAREN          reduce using rule 71 (saveOperator -> .)
    COMMA           reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 164

state 124

    (57) compexp1 -> sumexp NE . saveOperator sumexp generateQuadCOMPARE
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    RBRACKET        reduce using rule 71 (saveOperator -> .)
    RPAREN          reduce using rule 71 (saveOperator -> .)
    COMMA           reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 165

state 125

    (52) compexp -> compexp1 sumexp .

    AND             reduce using rule 52 (compexp -> compexp1 sumexp .)
    OR              reduce using rule 52 (compexp -> compexp1 sumexp .)
    RBRACKET        reduce using rule 52 (compexp -> compexp1 sumexp .)
    RPAREN          reduce using rule 52 (compexp -> compexp1 sumexp .)
    COMMA           reduce using rule 52 (compexp -> compexp1 sumexp .)
    SEMMICOLON      reduce using rule 52 (compexp -> compexp1 sumexp .)
    TO              reduce using rule 52 (compexp -> compexp1 sumexp .)


state 126

    (65) pexp -> CTEI . saveCTE
    (46) saveCTE -> .

    MUL             reduce using rule 46 (saveCTE -> .)
    DIV             reduce using rule 46 (saveCTE -> .)
    PLUS            reduce using rule 46 (saveCTE -> .)
    MINUS           reduce using rule 46 (saveCTE -> .)
    AND             reduce using rule 46 (saveCTE -> .)
    OR              reduce using rule 46 (saveCTE -> .)
    RBRACKET        reduce using rule 46 (saveCTE -> .)
    RPAREN          reduce using rule 46 (saveCTE -> .)
    COMMA           reduce using rule 46 (saveCTE -> .)
    SEMMICOLON      reduce using rule 46 (saveCTE -> .)
    TO              reduce using rule 46 (saveCTE -> .)
    GT              reduce using rule 46 (saveCTE -> .)
    LT              reduce using rule 46 (saveCTE -> .)
    GTE             reduce using rule 46 (saveCTE -> .)
    LTE             reduce using rule 46 (saveCTE -> .)
    NE              reduce using rule 46 (saveCTE -> .)
    CTEI            reduce using rule 46 (saveCTE -> .)
    CTEF            reduce using rule 46 (saveCTE -> .)
    CTEC            reduce using rule 46 (saveCTE -> .)
    CTESTRING       reduce using rule 46 (saveCTE -> .)
    LPAREN          reduce using rule 46 (saveCTE -> .)
    ID              reduce using rule 46 (saveCTE -> .)

    saveCTE                        shift and go to state 116

state 127

    (59) sumexp -> mulexp PLUS . saveOperator mulexp generateQuadSUM
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)
    GT              reduce using rule 71 (saveOperator -> .)
    LT              reduce using rule 71 (saveOperator -> .)
    GTE             reduce using rule 71 (saveOperator -> .)
    LTE             reduce using rule 71 (saveOperator -> .)
    NE              reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    RBRACKET        reduce using rule 71 (saveOperator -> .)
    RPAREN          reduce using rule 71 (saveOperator -> .)
    COMMA           reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 166

state 128

    (60) sumexp -> mulexp MINUS . saveOperator mulexp generateQuadSUM
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)
    GT              reduce using rule 71 (saveOperator -> .)
    LT              reduce using rule 71 (saveOperator -> .)
    GTE             reduce using rule 71 (saveOperator -> .)
    LTE             reduce using rule 71 (saveOperator -> .)
    NE              reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    RBRACKET        reduce using rule 71 (saveOperator -> .)
    RPAREN          reduce using rule 71 (saveOperator -> .)
    COMMA           reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 167

state 129

    (62) mulexp -> pexp MUL . saveOperator pexp generateQuadMUL
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)
    GT              reduce using rule 71 (saveOperator -> .)
    LT              reduce using rule 71 (saveOperator -> .)
    GTE             reduce using rule 71 (saveOperator -> .)
    LTE             reduce using rule 71 (saveOperator -> .)
    NE              reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    RBRACKET        reduce using rule 71 (saveOperator -> .)
    RPAREN          reduce using rule 71 (saveOperator -> .)
    COMMA           reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 168

state 130

    (63) mulexp -> pexp DIV . saveOperator pexp generateQuadMUL
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)
    GT              reduce using rule 71 (saveOperator -> .)
    LT              reduce using rule 71 (saveOperator -> .)
    GTE             reduce using rule 71 (saveOperator -> .)
    LTE             reduce using rule 71 (saveOperator -> .)
    NE              reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    RBRACKET        reduce using rule 71 (saveOperator -> .)
    RPAREN          reduce using rule 71 (saveOperator -> .)
    COMMA           reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 169

state 131

    (64) pexp -> var1 add_id .

    MUL             reduce using rule 64 (pexp -> var1 add_id .)
    DIV             reduce using rule 64 (pexp -> var1 add_id .)
    PLUS            reduce using rule 64 (pexp -> var1 add_id .)
    MINUS           reduce using rule 64 (pexp -> var1 add_id .)
    GT              reduce using rule 64 (pexp -> var1 add_id .)
    LT              reduce using rule 64 (pexp -> var1 add_id .)
    GTE             reduce using rule 64 (pexp -> var1 add_id .)
    LTE             reduce using rule 64 (pexp -> var1 add_id .)
    NE              reduce using rule 64 (pexp -> var1 add_id .)
    AND             reduce using rule 64 (pexp -> var1 add_id .)
    OR              reduce using rule 64 (pexp -> var1 add_id .)
    RBRACKET        reduce using rule 64 (pexp -> var1 add_id .)
    RPAREN          reduce using rule 64 (pexp -> var1 add_id .)
    COMMA           reduce using rule 64 (pexp -> var1 add_id .)
    SEMMICOLON      reduce using rule 64 (pexp -> var1 add_id .)
    TO              reduce using rule 64 (pexp -> var1 add_id .)
    CTEI            reduce using rule 64 (pexp -> var1 add_id .)
    CTEF            reduce using rule 64 (pexp -> var1 add_id .)
    CTEC            reduce using rule 64 (pexp -> var1 add_id .)
    CTESTRING       reduce using rule 64 (pexp -> var1 add_id .)
    LPAREN          reduce using rule 64 (pexp -> var1 add_id .)
    ID              reduce using rule 64 (pexp -> var1 add_id .)


state 132

    (66) pexp -> CTEF saveCTE .

    MUL             reduce using rule 66 (pexp -> CTEF saveCTE .)
    DIV             reduce using rule 66 (pexp -> CTEF saveCTE .)
    PLUS            reduce using rule 66 (pexp -> CTEF saveCTE .)
    MINUS           reduce using rule 66 (pexp -> CTEF saveCTE .)
    GT              reduce using rule 66 (pexp -> CTEF saveCTE .)
    LT              reduce using rule 66 (pexp -> CTEF saveCTE .)
    GTE             reduce using rule 66 (pexp -> CTEF saveCTE .)
    LTE             reduce using rule 66 (pexp -> CTEF saveCTE .)
    NE              reduce using rule 66 (pexp -> CTEF saveCTE .)
    AND             reduce using rule 66 (pexp -> CTEF saveCTE .)
    OR              reduce using rule 66 (pexp -> CTEF saveCTE .)
    RBRACKET        reduce using rule 66 (pexp -> CTEF saveCTE .)
    RPAREN          reduce using rule 66 (pexp -> CTEF saveCTE .)
    COMMA           reduce using rule 66 (pexp -> CTEF saveCTE .)
    SEMMICOLON      reduce using rule 66 (pexp -> CTEF saveCTE .)
    TO              reduce using rule 66 (pexp -> CTEF saveCTE .)
    CTEI            reduce using rule 66 (pexp -> CTEF saveCTE .)
    CTEF            reduce using rule 66 (pexp -> CTEF saveCTE .)
    CTEC            reduce using rule 66 (pexp -> CTEF saveCTE .)
    CTESTRING       reduce using rule 66 (pexp -> CTEF saveCTE .)
    LPAREN          reduce using rule 66 (pexp -> CTEF saveCTE .)
    ID              reduce using rule 66 (pexp -> CTEF saveCTE .)


state 133

    (67) pexp -> CTEC saveCTE .

    MUL             reduce using rule 67 (pexp -> CTEC saveCTE .)
    DIV             reduce using rule 67 (pexp -> CTEC saveCTE .)
    PLUS            reduce using rule 67 (pexp -> CTEC saveCTE .)
    MINUS           reduce using rule 67 (pexp -> CTEC saveCTE .)
    GT              reduce using rule 67 (pexp -> CTEC saveCTE .)
    LT              reduce using rule 67 (pexp -> CTEC saveCTE .)
    GTE             reduce using rule 67 (pexp -> CTEC saveCTE .)
    LTE             reduce using rule 67 (pexp -> CTEC saveCTE .)
    NE              reduce using rule 67 (pexp -> CTEC saveCTE .)
    AND             reduce using rule 67 (pexp -> CTEC saveCTE .)
    OR              reduce using rule 67 (pexp -> CTEC saveCTE .)
    RBRACKET        reduce using rule 67 (pexp -> CTEC saveCTE .)
    RPAREN          reduce using rule 67 (pexp -> CTEC saveCTE .)
    COMMA           reduce using rule 67 (pexp -> CTEC saveCTE .)
    SEMMICOLON      reduce using rule 67 (pexp -> CTEC saveCTE .)
    TO              reduce using rule 67 (pexp -> CTEC saveCTE .)
    CTEI            reduce using rule 67 (pexp -> CTEC saveCTE .)
    CTEF            reduce using rule 67 (pexp -> CTEC saveCTE .)
    CTEC            reduce using rule 67 (pexp -> CTEC saveCTE .)
    CTESTRING       reduce using rule 67 (pexp -> CTEC saveCTE .)
    LPAREN          reduce using rule 67 (pexp -> CTEC saveCTE .)
    ID              reduce using rule 67 (pexp -> CTEC saveCTE .)


state 134

    (68) pexp -> CTESTRING saveCTE .

    MUL             reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    DIV             reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    PLUS            reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    MINUS           reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    GT              reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    LT              reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    GTE             reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    LTE             reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    NE              reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    AND             reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    OR              reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    RBRACKET        reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    RPAREN          reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    COMMA           reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    SEMMICOLON      reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    TO              reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    CTEI            reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    CTEF            reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    CTEC            reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    CTESTRING       reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    LPAREN          reduce using rule 68 (pexp -> CTESTRING saveCTE .)
    ID              reduce using rule 68 (pexp -> CTESTRING saveCTE .)


state 135

    (70) pexp -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 170


state 136

    (8) statements -> assign SEMMICOLON statements .

    RCURLY          reduce using rule 8 (statements -> assign SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 8 (statements -> assign SEMMICOLON statements .)


state 137

    (9) statements -> functionCall SEMMICOLON statements .

    RCURLY          reduce using rule 9 (statements -> functionCall SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 9 (statements -> functionCall SEMMICOLON statements .)


state 138

    (10) statements -> read statements SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)

    read                           shift and go to state 58
    statements                     shift and go to state 171
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 139

    (11) statements -> write statements SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)

    write                          shift and go to state 59
    statements                     shift and go to state 172
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 140

    (17) assign -> ID add_id2 EQUALS . saveOperator exp generateAssignQuad
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    GT              reduce using rule 71 (saveOperator -> .)
    LT              reduce using rule 71 (saveOperator -> .)
    GTE             reduce using rule 71 (saveOperator -> .)
    LTE             reduce using rule 71 (saveOperator -> .)
    NE              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 173

state 141

    (18) assign -> ID add_id2 arr . EQUALS saveOperator exp generateAssignQuad

    EQUALS          shift and go to state 174


state 142

    (22) functionCall -> ID LPAREN exp . RPAREN

    RPAREN          shift and go to state 175


state 143

    (23) read -> READ operatorRead LPAREN . var1 generateQuadREAD RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (104) empty -> .

    ID              shift and go to state 47
    RPAREN          reduce using rule 104 (empty -> .)

    var1                           shift and go to state 176
    empty                          shift and go to state 48

state 144

    (26) write -> WRITE LPAREN write1 . RPAREN

    RPAREN          shift and go to state 177


state 145

    (27) write1 -> write2 . COMMA write2
    (28) write1 -> write2 .

    COMMA           shift and go to state 178
    RPAREN          reduce using rule 28 (write1 -> write2 .)


state 146

    (29) write2 -> COMILLA . CTESTRING COMILLA

    CTESTRING       shift and go to state 179


state 147

    (30) write2 -> CTEI . saveCTE generateQuadPRINT
    (65) pexp -> CTEI . saveCTE
    (46) saveCTE -> .

    COMMA           reduce using rule 46 (saveCTE -> .)
    RPAREN          reduce using rule 46 (saveCTE -> .)
    MUL             reduce using rule 46 (saveCTE -> .)
    DIV             reduce using rule 46 (saveCTE -> .)
    PLUS            reduce using rule 46 (saveCTE -> .)
    MINUS           reduce using rule 46 (saveCTE -> .)
    GT              reduce using rule 46 (saveCTE -> .)
    LT              reduce using rule 46 (saveCTE -> .)
    GTE             reduce using rule 46 (saveCTE -> .)
    LTE             reduce using rule 46 (saveCTE -> .)
    NE              reduce using rule 46 (saveCTE -> .)
    AND             reduce using rule 46 (saveCTE -> .)
    OR              reduce using rule 46 (saveCTE -> .)

    saveCTE                        shift and go to state 180

state 148

    (31) write2 -> CTEF . saveCTE generateQuadPRINT
    (66) pexp -> CTEF . saveCTE
    (46) saveCTE -> .

    COMMA           reduce using rule 46 (saveCTE -> .)
    RPAREN          reduce using rule 46 (saveCTE -> .)
    MUL             reduce using rule 46 (saveCTE -> .)
    DIV             reduce using rule 46 (saveCTE -> .)
    PLUS            reduce using rule 46 (saveCTE -> .)
    MINUS           reduce using rule 46 (saveCTE -> .)
    GT              reduce using rule 46 (saveCTE -> .)
    LT              reduce using rule 46 (saveCTE -> .)
    GTE             reduce using rule 46 (saveCTE -> .)
    LTE             reduce using rule 46 (saveCTE -> .)
    NE              reduce using rule 46 (saveCTE -> .)
    AND             reduce using rule 46 (saveCTE -> .)
    OR              reduce using rule 46 (saveCTE -> .)

    saveCTE                        shift and go to state 181

state 149

    (32) write2 -> exp .

    COMMA           reduce using rule 32 (write2 -> exp .)
    RPAREN          reduce using rule 32 (write2 -> exp .)


state 150

    (33) for -> FOR assign TO . CTEI DO LCURLY statements RCURLY

    CTEI            shift and go to state 182


state 151

    (34) while -> WHILE LPAREN exp . RPAREN DO LCURLY statements RCURLY

    RPAREN          shift and go to state 183


state 152

    (35) if -> IF LPAREN exp . RPAREN THEN LCURLY statements RCURLY else

    RPAREN          shift and go to state 184


state 153

    (102) return -> RETURN LPAREN exp . RPAREN SEMMICOLON
    (103) return -> RETURN LPAREN exp . RPAREN

    RPAREN          shift and go to state 185


state 154

    (94) functions1 -> ID saveFunction LPAREN args RPAREN vars . LCURLY statements RCURLY

    LCURLY          shift and go to state 186


state 155

    (97) args -> type TWOPOINTS args1 .

    RPAREN          reduce using rule 97 (args -> type TWOPOINTS args1 .)


state 156

    (99) args1 -> ID .
    (100) args1 -> ID . COMMA args1

    RPAREN          reduce using rule 99 (args1 -> ID .)
    COMMA           shift and go to state 187


state 157

    (101) args1 -> empty .

    RPAREN          reduce using rule 101 (args1 -> empty .)


state 158

    (80) var1 -> ID arr COMMA var1 addVar .

    SEMMICOLON      reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    MUL             reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    DIV             reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    PLUS            reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    MINUS           reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    GT              reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    LT              reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    GTE             reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    LTE             reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    NE              reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    AND             reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    OR              reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    RBRACKET        reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    RPAREN          reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    COMMA           reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    TO              reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    CTEI            reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    CTEF            reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    CTEC            reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    CTESTRING       reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    LPAREN          reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)
    ID              reduce using rule 80 (var1 -> ID arr COMMA var1 addVar .)


state 159

    (48) exp -> nexp generateQuadOR OR . saveOperator nexp
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    GT              reduce using rule 71 (saveOperator -> .)
    LT              reduce using rule 71 (saveOperator -> .)
    GTE             reduce using rule 71 (saveOperator -> .)
    LTE             reduce using rule 71 (saveOperator -> .)
    NE              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)
    RBRACKET        reduce using rule 71 (saveOperator -> .)
    RPAREN          reduce using rule 71 (saveOperator -> .)
    COMMA           reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 188

state 160

    (50) nexp -> compexp generateQuadAND AND . saveOperator compexp
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    GT              reduce using rule 71 (saveOperator -> .)
    LT              reduce using rule 71 (saveOperator -> .)
    GTE             reduce using rule 71 (saveOperator -> .)
    LTE             reduce using rule 71 (saveOperator -> .)
    NE              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    RBRACKET        reduce using rule 71 (saveOperator -> .)
    RPAREN          reduce using rule 71 (saveOperator -> .)
    COMMA           reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 189

state 161

    (53) compexp1 -> sumexp GT saveOperator . sumexp generateQuadCOMPARE
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)

  ! CTEI            [ reduce using rule 104 (empty -> .) ]
  ! CTEF            [ reduce using rule 104 (empty -> .) ]
  ! CTEC            [ reduce using rule 104 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 104 (empty -> .) ]
  ! LPAREN          [ reduce using rule 104 (empty -> .) ]
  ! ID              [ reduce using rule 104 (empty -> .) ]

    sumexp                         shift and go to state 190
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 162

    (54) compexp1 -> sumexp LT saveOperator . sumexp generateQuadCOMPARE
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)

  ! CTEI            [ reduce using rule 104 (empty -> .) ]
  ! CTEF            [ reduce using rule 104 (empty -> .) ]
  ! CTEC            [ reduce using rule 104 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 104 (empty -> .) ]
  ! LPAREN          [ reduce using rule 104 (empty -> .) ]
  ! ID              [ reduce using rule 104 (empty -> .) ]

    sumexp                         shift and go to state 191
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 163

    (55) compexp1 -> sumexp GTE saveOperator . sumexp generateQuadCOMPARE
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)

  ! CTEI            [ reduce using rule 104 (empty -> .) ]
  ! CTEF            [ reduce using rule 104 (empty -> .) ]
  ! CTEC            [ reduce using rule 104 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 104 (empty -> .) ]
  ! LPAREN          [ reduce using rule 104 (empty -> .) ]
  ! ID              [ reduce using rule 104 (empty -> .) ]

    sumexp                         shift and go to state 192
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 164

    (56) compexp1 -> sumexp LTE saveOperator . sumexp generateQuadCOMPARE
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)

  ! CTEI            [ reduce using rule 104 (empty -> .) ]
  ! CTEF            [ reduce using rule 104 (empty -> .) ]
  ! CTEC            [ reduce using rule 104 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 104 (empty -> .) ]
  ! LPAREN          [ reduce using rule 104 (empty -> .) ]
  ! ID              [ reduce using rule 104 (empty -> .) ]

    sumexp                         shift and go to state 193
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 165

    (57) compexp1 -> sumexp NE saveOperator . sumexp generateQuadCOMPARE
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)

  ! CTEI            [ reduce using rule 104 (empty -> .) ]
  ! CTEF            [ reduce using rule 104 (empty -> .) ]
  ! CTEC            [ reduce using rule 104 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 104 (empty -> .) ]
  ! LPAREN          [ reduce using rule 104 (empty -> .) ]
  ! ID              [ reduce using rule 104 (empty -> .) ]

    sumexp                         shift and go to state 194
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 166

    (59) sumexp -> mulexp PLUS saveOperator . mulexp generateQuadSUM
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)

  ! CTEI            [ reduce using rule 104 (empty -> .) ]
  ! CTEF            [ reduce using rule 104 (empty -> .) ]
  ! CTEC            [ reduce using rule 104 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 104 (empty -> .) ]
  ! LPAREN          [ reduce using rule 104 (empty -> .) ]
  ! ID              [ reduce using rule 104 (empty -> .) ]

    mulexp                         shift and go to state 195
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 167

    (60) sumexp -> mulexp MINUS saveOperator . mulexp generateQuadSUM
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)

  ! CTEI            [ reduce using rule 104 (empty -> .) ]
  ! CTEF            [ reduce using rule 104 (empty -> .) ]
  ! CTEC            [ reduce using rule 104 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 104 (empty -> .) ]
  ! LPAREN          [ reduce using rule 104 (empty -> .) ]
  ! ID              [ reduce using rule 104 (empty -> .) ]

    mulexp                         shift and go to state 196
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 168

    (62) mulexp -> pexp MUL saveOperator . pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)

  ! CTEI            [ reduce using rule 104 (empty -> .) ]
  ! CTEF            [ reduce using rule 104 (empty -> .) ]
  ! CTEC            [ reduce using rule 104 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 104 (empty -> .) ]
  ! LPAREN          [ reduce using rule 104 (empty -> .) ]
  ! ID              [ reduce using rule 104 (empty -> .) ]

    pexp                           shift and go to state 197
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 169

    (63) mulexp -> pexp DIV saveOperator . pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)

  ! CTEI            [ reduce using rule 104 (empty -> .) ]
  ! CTEF            [ reduce using rule 104 (empty -> .) ]
  ! CTEC            [ reduce using rule 104 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 104 (empty -> .) ]
  ! LPAREN          [ reduce using rule 104 (empty -> .) ]
  ! ID              [ reduce using rule 104 (empty -> .) ]

    pexp                           shift and go to state 198
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 170

    (70) pexp -> LPAREN exp RPAREN .

    MUL             reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    DIV             reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    AND             reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    OR              reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    SEMMICOLON      reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    TO              reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    CTEI            reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    CTEF            reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    CTEC            reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    CTESTRING       reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 70 (pexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 70 (pexp -> LPAREN exp RPAREN .)


state 171

    (10) statements -> read statements SEMMICOLON statements .

    RCURLY          reduce using rule 10 (statements -> read statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 10 (statements -> read statements SEMMICOLON statements .)


state 172

    (11) statements -> write statements SEMMICOLON statements .

    RCURLY          reduce using rule 11 (statements -> write statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 11 (statements -> write statements SEMMICOLON statements .)


state 173

    (17) assign -> ID add_id2 EQUALS saveOperator . exp generateAssignQuad
    (47) exp -> . nexp generateQuadOR
    (48) exp -> . nexp generateQuadOR OR saveOperator nexp
    (49) nexp -> . compexp generateQuadAND
    (50) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)

    exp                            shift and go to state 199
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 174

    (18) assign -> ID add_id2 arr EQUALS . saveOperator exp generateAssignQuad
    (71) saveOperator -> .

    CTEI            reduce using rule 71 (saveOperator -> .)
    CTEF            reduce using rule 71 (saveOperator -> .)
    CTEC            reduce using rule 71 (saveOperator -> .)
    CTESTRING       reduce using rule 71 (saveOperator -> .)
    LPAREN          reduce using rule 71 (saveOperator -> .)
    ID              reduce using rule 71 (saveOperator -> .)
    OR              reduce using rule 71 (saveOperator -> .)
    AND             reduce using rule 71 (saveOperator -> .)
    GT              reduce using rule 71 (saveOperator -> .)
    LT              reduce using rule 71 (saveOperator -> .)
    GTE             reduce using rule 71 (saveOperator -> .)
    LTE             reduce using rule 71 (saveOperator -> .)
    NE              reduce using rule 71 (saveOperator -> .)
    PLUS            reduce using rule 71 (saveOperator -> .)
    MINUS           reduce using rule 71 (saveOperator -> .)
    MUL             reduce using rule 71 (saveOperator -> .)
    DIV             reduce using rule 71 (saveOperator -> .)
    SEMMICOLON      reduce using rule 71 (saveOperator -> .)
    TO              reduce using rule 71 (saveOperator -> .)

    saveOperator                   shift and go to state 200

state 175

    (22) functionCall -> ID LPAREN exp RPAREN .

    SEMMICOLON      reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    MUL             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    DIV             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    PLUS            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    MINUS           reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    GT              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    LT              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    GTE             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    LTE             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    NE              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    AND             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    OR              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    RPAREN          reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    COMMA           reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    TO              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTEI            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTEF            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTEC            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTESTRING       reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    LPAREN          reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    ID              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)


state 176

    (23) read -> READ operatorRead LPAREN var1 . generateQuadREAD RPAREN
    (45) generateQuadREAD -> .

    RPAREN          reduce using rule 45 (generateQuadREAD -> .)

    generateQuadREAD               shift and go to state 201

state 177

    (26) write -> WRITE LPAREN write1 RPAREN .

    ID              reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    READ            reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    WRITE           reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    FOR             reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    WHILE           reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    IF              reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    RETURN          reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    SEMMICOLON      reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)


state 178

    (27) write1 -> write2 COMMA . write2
    (29) write2 -> . COMILLA CTESTRING COMILLA
    (30) write2 -> . CTEI saveCTE generateQuadPRINT
    (31) write2 -> . CTEF saveCTE generateQuadPRINT
    (32) write2 -> . exp
    (47) exp -> . nexp generateQuadOR
    (48) exp -> . nexp generateQuadOR OR saveOperator nexp
    (49) nexp -> . compexp generateQuadAND
    (50) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    COMILLA         shift and go to state 146
    CTEI            shift and go to state 147
    CTEF            shift and go to state 148
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    write2                         shift and go to state 202
    exp                            shift and go to state 149
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 179

    (29) write2 -> COMILLA CTESTRING . COMILLA

    COMILLA         shift and go to state 203


state 180

    (30) write2 -> CTEI saveCTE . generateQuadPRINT
    (65) pexp -> CTEI saveCTE .
    (44) generateQuadPRINT -> .

  ! reduce/reduce conflict for COMMA resolved using rule 44 (generateQuadPRINT -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 44 (generateQuadPRINT -> .)
    MUL             reduce using rule 65 (pexp -> CTEI saveCTE .)
    DIV             reduce using rule 65 (pexp -> CTEI saveCTE .)
    PLUS            reduce using rule 65 (pexp -> CTEI saveCTE .)
    MINUS           reduce using rule 65 (pexp -> CTEI saveCTE .)
    GT              reduce using rule 65 (pexp -> CTEI saveCTE .)
    LT              reduce using rule 65 (pexp -> CTEI saveCTE .)
    GTE             reduce using rule 65 (pexp -> CTEI saveCTE .)
    LTE             reduce using rule 65 (pexp -> CTEI saveCTE .)
    NE              reduce using rule 65 (pexp -> CTEI saveCTE .)
    AND             reduce using rule 65 (pexp -> CTEI saveCTE .)
    OR              reduce using rule 65 (pexp -> CTEI saveCTE .)
    COMMA           reduce using rule 44 (generateQuadPRINT -> .)
    RPAREN          reduce using rule 44 (generateQuadPRINT -> .)

  ! COMMA           [ reduce using rule 65 (pexp -> CTEI saveCTE .) ]
  ! RPAREN          [ reduce using rule 65 (pexp -> CTEI saveCTE .) ]

    generateQuadPRINT              shift and go to state 204

state 181

    (31) write2 -> CTEF saveCTE . generateQuadPRINT
    (66) pexp -> CTEF saveCTE .
    (44) generateQuadPRINT -> .

  ! reduce/reduce conflict for COMMA resolved using rule 44 (generateQuadPRINT -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 44 (generateQuadPRINT -> .)
    MUL             reduce using rule 66 (pexp -> CTEF saveCTE .)
    DIV             reduce using rule 66 (pexp -> CTEF saveCTE .)
    PLUS            reduce using rule 66 (pexp -> CTEF saveCTE .)
    MINUS           reduce using rule 66 (pexp -> CTEF saveCTE .)
    GT              reduce using rule 66 (pexp -> CTEF saveCTE .)
    LT              reduce using rule 66 (pexp -> CTEF saveCTE .)
    GTE             reduce using rule 66 (pexp -> CTEF saveCTE .)
    LTE             reduce using rule 66 (pexp -> CTEF saveCTE .)
    NE              reduce using rule 66 (pexp -> CTEF saveCTE .)
    AND             reduce using rule 66 (pexp -> CTEF saveCTE .)
    OR              reduce using rule 66 (pexp -> CTEF saveCTE .)
    COMMA           reduce using rule 44 (generateQuadPRINT -> .)
    RPAREN          reduce using rule 44 (generateQuadPRINT -> .)

  ! COMMA           [ reduce using rule 66 (pexp -> CTEF saveCTE .) ]
  ! RPAREN          [ reduce using rule 66 (pexp -> CTEF saveCTE .) ]

    generateQuadPRINT              shift and go to state 205

state 182

    (33) for -> FOR assign TO CTEI . DO LCURLY statements RCURLY

    DO              shift and go to state 206


state 183

    (34) while -> WHILE LPAREN exp RPAREN . DO LCURLY statements RCURLY

    DO              shift and go to state 207


state 184

    (35) if -> IF LPAREN exp RPAREN . THEN LCURLY statements RCURLY else

    THEN            shift and go to state 208


state 185

    (102) return -> RETURN LPAREN exp RPAREN . SEMMICOLON
    (103) return -> RETURN LPAREN exp RPAREN .

  ! shift/reduce conflict for SEMMICOLON resolved as shift
    SEMMICOLON      shift and go to state 209
    ID              reduce using rule 103 (return -> RETURN LPAREN exp RPAREN .)
    READ            reduce using rule 103 (return -> RETURN LPAREN exp RPAREN .)
    WRITE           reduce using rule 103 (return -> RETURN LPAREN exp RPAREN .)
    FOR             reduce using rule 103 (return -> RETURN LPAREN exp RPAREN .)
    WHILE           reduce using rule 103 (return -> RETURN LPAREN exp RPAREN .)
    IF              reduce using rule 103 (return -> RETURN LPAREN exp RPAREN .)
    RETURN          reduce using rule 103 (return -> RETURN LPAREN exp RPAREN .)
    RCURLY          reduce using rule 103 (return -> RETURN LPAREN exp RPAREN .)

  ! SEMMICOLON      [ reduce using rule 103 (return -> RETURN LPAREN exp RPAREN .) ]


state 186

    (94) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)

    statements                     shift and go to state 210
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 187

    (100) args1 -> ID COMMA . args1
    (99) args1 -> . ID
    (100) args1 -> . ID COMMA args1
    (101) args1 -> . empty
    (104) empty -> .

    ID              shift and go to state 156
    RPAREN          reduce using rule 104 (empty -> .)

    args1                          shift and go to state 211
    empty                          shift and go to state 157

state 188

    (48) exp -> nexp generateQuadOR OR saveOperator . nexp
    (49) nexp -> . compexp generateQuadAND
    (50) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)

    nexp                           shift and go to state 212
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 189

    (50) nexp -> compexp generateQuadAND AND saveOperator . compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)
    COMMA           reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)

    compexp                        shift and go to state 213
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 190

    (53) compexp1 -> sumexp GT saveOperator sumexp . generateQuadCOMPARE
    (40) generateQuadCOMPARE -> .

    CTEI            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 40 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 40 (generateQuadCOMPARE -> .)
    ID              reduce using rule 40 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 40 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 40 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 40 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 40 (generateQuadCOMPARE -> .)
    AND             reduce using rule 40 (generateQuadCOMPARE -> .)
    OR              reduce using rule 40 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 40 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 40 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 40 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 40 (generateQuadCOMPARE -> .)
    TO              reduce using rule 40 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 214

state 191

    (54) compexp1 -> sumexp LT saveOperator sumexp . generateQuadCOMPARE
    (40) generateQuadCOMPARE -> .

    CTEI            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 40 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 40 (generateQuadCOMPARE -> .)
    ID              reduce using rule 40 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 40 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 40 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 40 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 40 (generateQuadCOMPARE -> .)
    AND             reduce using rule 40 (generateQuadCOMPARE -> .)
    OR              reduce using rule 40 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 40 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 40 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 40 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 40 (generateQuadCOMPARE -> .)
    TO              reduce using rule 40 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 215

state 192

    (55) compexp1 -> sumexp GTE saveOperator sumexp . generateQuadCOMPARE
    (40) generateQuadCOMPARE -> .

    CTEI            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 40 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 40 (generateQuadCOMPARE -> .)
    ID              reduce using rule 40 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 40 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 40 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 40 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 40 (generateQuadCOMPARE -> .)
    AND             reduce using rule 40 (generateQuadCOMPARE -> .)
    OR              reduce using rule 40 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 40 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 40 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 40 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 40 (generateQuadCOMPARE -> .)
    TO              reduce using rule 40 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 216

state 193

    (56) compexp1 -> sumexp LTE saveOperator sumexp . generateQuadCOMPARE
    (40) generateQuadCOMPARE -> .

    CTEI            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 40 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 40 (generateQuadCOMPARE -> .)
    ID              reduce using rule 40 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 40 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 40 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 40 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 40 (generateQuadCOMPARE -> .)
    AND             reduce using rule 40 (generateQuadCOMPARE -> .)
    OR              reduce using rule 40 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 40 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 40 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 40 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 40 (generateQuadCOMPARE -> .)
    TO              reduce using rule 40 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 217

state 194

    (57) compexp1 -> sumexp NE saveOperator sumexp . generateQuadCOMPARE
    (40) generateQuadCOMPARE -> .

    CTEI            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 40 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 40 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 40 (generateQuadCOMPARE -> .)
    ID              reduce using rule 40 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 40 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 40 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 40 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 40 (generateQuadCOMPARE -> .)
    AND             reduce using rule 40 (generateQuadCOMPARE -> .)
    OR              reduce using rule 40 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 40 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 40 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 40 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 40 (generateQuadCOMPARE -> .)
    TO              reduce using rule 40 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 218

state 195

    (59) sumexp -> mulexp PLUS saveOperator mulexp . generateQuadSUM
    (42) generateQuadSUM -> .

    GT              reduce using rule 42 (generateQuadSUM -> .)
    LT              reduce using rule 42 (generateQuadSUM -> .)
    GTE             reduce using rule 42 (generateQuadSUM -> .)
    LTE             reduce using rule 42 (generateQuadSUM -> .)
    NE              reduce using rule 42 (generateQuadSUM -> .)
    AND             reduce using rule 42 (generateQuadSUM -> .)
    OR              reduce using rule 42 (generateQuadSUM -> .)
    RBRACKET        reduce using rule 42 (generateQuadSUM -> .)
    RPAREN          reduce using rule 42 (generateQuadSUM -> .)
    COMMA           reduce using rule 42 (generateQuadSUM -> .)
    SEMMICOLON      reduce using rule 42 (generateQuadSUM -> .)
    TO              reduce using rule 42 (generateQuadSUM -> .)
    CTEI            reduce using rule 42 (generateQuadSUM -> .)
    CTEF            reduce using rule 42 (generateQuadSUM -> .)
    CTEC            reduce using rule 42 (generateQuadSUM -> .)
    CTESTRING       reduce using rule 42 (generateQuadSUM -> .)
    LPAREN          reduce using rule 42 (generateQuadSUM -> .)
    ID              reduce using rule 42 (generateQuadSUM -> .)
    PLUS            reduce using rule 42 (generateQuadSUM -> .)
    MINUS           reduce using rule 42 (generateQuadSUM -> .)
    MUL             reduce using rule 42 (generateQuadSUM -> .)
    DIV             reduce using rule 42 (generateQuadSUM -> .)

    generateQuadSUM                shift and go to state 219

state 196

    (60) sumexp -> mulexp MINUS saveOperator mulexp . generateQuadSUM
    (42) generateQuadSUM -> .

    GT              reduce using rule 42 (generateQuadSUM -> .)
    LT              reduce using rule 42 (generateQuadSUM -> .)
    GTE             reduce using rule 42 (generateQuadSUM -> .)
    LTE             reduce using rule 42 (generateQuadSUM -> .)
    NE              reduce using rule 42 (generateQuadSUM -> .)
    AND             reduce using rule 42 (generateQuadSUM -> .)
    OR              reduce using rule 42 (generateQuadSUM -> .)
    RBRACKET        reduce using rule 42 (generateQuadSUM -> .)
    RPAREN          reduce using rule 42 (generateQuadSUM -> .)
    COMMA           reduce using rule 42 (generateQuadSUM -> .)
    SEMMICOLON      reduce using rule 42 (generateQuadSUM -> .)
    TO              reduce using rule 42 (generateQuadSUM -> .)
    CTEI            reduce using rule 42 (generateQuadSUM -> .)
    CTEF            reduce using rule 42 (generateQuadSUM -> .)
    CTEC            reduce using rule 42 (generateQuadSUM -> .)
    CTESTRING       reduce using rule 42 (generateQuadSUM -> .)
    LPAREN          reduce using rule 42 (generateQuadSUM -> .)
    ID              reduce using rule 42 (generateQuadSUM -> .)
    PLUS            reduce using rule 42 (generateQuadSUM -> .)
    MINUS           reduce using rule 42 (generateQuadSUM -> .)
    MUL             reduce using rule 42 (generateQuadSUM -> .)
    DIV             reduce using rule 42 (generateQuadSUM -> .)

    generateQuadSUM                shift and go to state 220

state 197

    (62) mulexp -> pexp MUL saveOperator pexp . generateQuadMUL
    (43) generateQuadMUL -> .

    PLUS            reduce using rule 43 (generateQuadMUL -> .)
    MINUS           reduce using rule 43 (generateQuadMUL -> .)
    GT              reduce using rule 43 (generateQuadMUL -> .)
    LT              reduce using rule 43 (generateQuadMUL -> .)
    GTE             reduce using rule 43 (generateQuadMUL -> .)
    LTE             reduce using rule 43 (generateQuadMUL -> .)
    NE              reduce using rule 43 (generateQuadMUL -> .)
    AND             reduce using rule 43 (generateQuadMUL -> .)
    OR              reduce using rule 43 (generateQuadMUL -> .)
    RBRACKET        reduce using rule 43 (generateQuadMUL -> .)
    RPAREN          reduce using rule 43 (generateQuadMUL -> .)
    COMMA           reduce using rule 43 (generateQuadMUL -> .)
    SEMMICOLON      reduce using rule 43 (generateQuadMUL -> .)
    TO              reduce using rule 43 (generateQuadMUL -> .)
    CTEI            reduce using rule 43 (generateQuadMUL -> .)
    CTEF            reduce using rule 43 (generateQuadMUL -> .)
    CTEC            reduce using rule 43 (generateQuadMUL -> .)
    CTESTRING       reduce using rule 43 (generateQuadMUL -> .)
    LPAREN          reduce using rule 43 (generateQuadMUL -> .)
    ID              reduce using rule 43 (generateQuadMUL -> .)
    MUL             reduce using rule 43 (generateQuadMUL -> .)
    DIV             reduce using rule 43 (generateQuadMUL -> .)

    generateQuadMUL                shift and go to state 221

state 198

    (63) mulexp -> pexp DIV saveOperator pexp . generateQuadMUL
    (43) generateQuadMUL -> .

    PLUS            reduce using rule 43 (generateQuadMUL -> .)
    MINUS           reduce using rule 43 (generateQuadMUL -> .)
    GT              reduce using rule 43 (generateQuadMUL -> .)
    LT              reduce using rule 43 (generateQuadMUL -> .)
    GTE             reduce using rule 43 (generateQuadMUL -> .)
    LTE             reduce using rule 43 (generateQuadMUL -> .)
    NE              reduce using rule 43 (generateQuadMUL -> .)
    AND             reduce using rule 43 (generateQuadMUL -> .)
    OR              reduce using rule 43 (generateQuadMUL -> .)
    RBRACKET        reduce using rule 43 (generateQuadMUL -> .)
    RPAREN          reduce using rule 43 (generateQuadMUL -> .)
    COMMA           reduce using rule 43 (generateQuadMUL -> .)
    SEMMICOLON      reduce using rule 43 (generateQuadMUL -> .)
    TO              reduce using rule 43 (generateQuadMUL -> .)
    CTEI            reduce using rule 43 (generateQuadMUL -> .)
    CTEF            reduce using rule 43 (generateQuadMUL -> .)
    CTEC            reduce using rule 43 (generateQuadMUL -> .)
    CTESTRING       reduce using rule 43 (generateQuadMUL -> .)
    LPAREN          reduce using rule 43 (generateQuadMUL -> .)
    ID              reduce using rule 43 (generateQuadMUL -> .)
    MUL             reduce using rule 43 (generateQuadMUL -> .)
    DIV             reduce using rule 43 (generateQuadMUL -> .)

    generateQuadMUL                shift and go to state 222

state 199

    (17) assign -> ID add_id2 EQUALS saveOperator exp . generateAssignQuad
    (19) generateAssignQuad -> .

    SEMMICOLON      reduce using rule 19 (generateAssignQuad -> .)
    TO              reduce using rule 19 (generateAssignQuad -> .)

    generateAssignQuad             shift and go to state 223

state 200

    (18) assign -> ID add_id2 arr EQUALS saveOperator . exp generateAssignQuad
    (47) exp -> . nexp generateQuadOR
    (48) exp -> . nexp generateQuadOR OR saveOperator nexp
    (49) nexp -> . compexp generateQuadAND
    (50) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (51) compexp -> . sumexp
    (52) compexp -> . compexp1 sumexp
    (58) sumexp -> . mulexp
    (59) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (60) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (53) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (54) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (55) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (56) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (57) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (61) mulexp -> . pexp
    (62) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (63) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (64) pexp -> . var1 add_id
    (65) pexp -> . CTEI saveCTE
    (66) pexp -> . CTEF saveCTE
    (67) pexp -> . CTEC saveCTE
    (68) pexp -> . CTESTRING saveCTE
    (69) pexp -> . functionCall
    (70) pexp -> . LPAREN exp RPAREN
    (77) var1 -> . ID
    (78) var1 -> . ID COMMA var1 addVar
    (79) var1 -> . ID arr
    (80) var1 -> . ID arr COMMA var1 addVar
    (81) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (104) empty -> .

    CTEI            shift and go to state 126
    CTEF            shift and go to state 87
    CTEC            shift and go to state 88
    CTESTRING       shift and go to state 89
    LPAREN          shift and go to state 91
    ID              shift and go to state 92
    MUL             reduce using rule 104 (empty -> .)
    DIV             reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    GT              reduce using rule 104 (empty -> .)
    LT              reduce using rule 104 (empty -> .)
    GTE             reduce using rule 104 (empty -> .)
    LTE             reduce using rule 104 (empty -> .)
    NE              reduce using rule 104 (empty -> .)
    AND             reduce using rule 104 (empty -> .)
    OR              reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)
    TO              reduce using rule 104 (empty -> .)

    exp                            shift and go to state 224
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 90
    empty                          shift and go to state 48

state 201

    (23) read -> READ operatorRead LPAREN var1 generateQuadREAD . RPAREN

    RPAREN          shift and go to state 225


state 202

    (27) write1 -> write2 COMMA write2 .

    RPAREN          reduce using rule 27 (write1 -> write2 COMMA write2 .)


state 203

    (29) write2 -> COMILLA CTESTRING COMILLA .

    COMMA           reduce using rule 29 (write2 -> COMILLA CTESTRING COMILLA .)
    RPAREN          reduce using rule 29 (write2 -> COMILLA CTESTRING COMILLA .)


state 204

    (30) write2 -> CTEI saveCTE generateQuadPRINT .

    COMMA           reduce using rule 30 (write2 -> CTEI saveCTE generateQuadPRINT .)
    RPAREN          reduce using rule 30 (write2 -> CTEI saveCTE generateQuadPRINT .)


state 205

    (31) write2 -> CTEF saveCTE generateQuadPRINT .

    COMMA           reduce using rule 31 (write2 -> CTEF saveCTE generateQuadPRINT .)
    RPAREN          reduce using rule 31 (write2 -> CTEF saveCTE generateQuadPRINT .)


state 206

    (33) for -> FOR assign TO CTEI DO . LCURLY statements RCURLY

    LCURLY          shift and go to state 226


state 207

    (34) while -> WHILE LPAREN exp RPAREN DO . LCURLY statements RCURLY

    LCURLY          shift and go to state 227


state 208

    (35) if -> IF LPAREN exp RPAREN THEN . LCURLY statements RCURLY else

    LCURLY          shift and go to state 228


state 209

    (102) return -> RETURN LPAREN exp RPAREN SEMMICOLON .

    ID              reduce using rule 102 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    READ            reduce using rule 102 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WRITE           reduce using rule 102 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    FOR             reduce using rule 102 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WHILE           reduce using rule 102 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    IF              reduce using rule 102 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RETURN          reduce using rule 102 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RCURLY          reduce using rule 102 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    SEMMICOLON      reduce using rule 102 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)


state 210

    (94) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements . RCURLY

    RCURLY          shift and go to state 229


state 211

    (100) args1 -> ID COMMA args1 .

    RPAREN          reduce using rule 100 (args1 -> ID COMMA args1 .)


state 212

    (48) exp -> nexp generateQuadOR OR saveOperator nexp .

    RBRACKET        reduce using rule 48 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    RPAREN          reduce using rule 48 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    COMMA           reduce using rule 48 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    SEMMICOLON      reduce using rule 48 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    TO              reduce using rule 48 (exp -> nexp generateQuadOR OR saveOperator nexp .)


state 213

    (50) nexp -> compexp generateQuadAND AND saveOperator compexp .

    OR              reduce using rule 50 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    RBRACKET        reduce using rule 50 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    RPAREN          reduce using rule 50 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    COMMA           reduce using rule 50 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    SEMMICOLON      reduce using rule 50 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    TO              reduce using rule 50 (nexp -> compexp generateQuadAND AND saveOperator compexp .)


state 214

    (53) compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 53 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)


state 215

    (54) compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 54 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)


state 216

    (55) compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 55 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)


state 217

    (56) compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 56 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)


state 218

    (57) compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 57 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)


state 219

    (59) sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .

    GT              reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LT              reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    GTE             reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LTE             reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    NE              reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    AND             reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    OR              reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    RBRACKET        reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    RPAREN          reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    COMMA           reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    SEMMICOLON      reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    TO              reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEI            reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEF            reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEC            reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTESTRING       reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LPAREN          reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    ID              reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    PLUS            reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    MINUS           reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    MUL             reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    DIV             reduce using rule 59 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)


state 220

    (60) sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .

    GT              reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LT              reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    GTE             reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LTE             reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    NE              reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    AND             reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    OR              reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    RBRACKET        reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    RPAREN          reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    COMMA           reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    SEMMICOLON      reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    TO              reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEI            reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEF            reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEC            reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTESTRING       reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LPAREN          reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    ID              reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    PLUS            reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    MINUS           reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    MUL             reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    DIV             reduce using rule 60 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)


state 221

    (62) mulexp -> pexp MUL saveOperator pexp generateQuadMUL .

    PLUS            reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    MINUS           reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    GT              reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LT              reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    GTE             reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LTE             reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    NE              reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    AND             reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    OR              reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    RBRACKET        reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    RPAREN          reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    COMMA           reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    SEMMICOLON      reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    TO              reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEI            reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEF            reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEC            reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTESTRING       reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LPAREN          reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    ID              reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    MUL             reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    DIV             reduce using rule 62 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)


state 222

    (63) mulexp -> pexp DIV saveOperator pexp generateQuadMUL .

    PLUS            reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    MINUS           reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    GT              reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LT              reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    GTE             reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LTE             reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    NE              reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    AND             reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    OR              reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    RBRACKET        reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    RPAREN          reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    COMMA           reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    SEMMICOLON      reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    TO              reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEI            reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEF            reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEC            reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTESTRING       reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LPAREN          reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    ID              reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    MUL             reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    DIV             reduce using rule 63 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)


state 223

    (17) assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .

    SEMMICOLON      reduce using rule 17 (assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .)
    TO              reduce using rule 17 (assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .)


state 224

    (18) assign -> ID add_id2 arr EQUALS saveOperator exp . generateAssignQuad
    (19) generateAssignQuad -> .

    SEMMICOLON      reduce using rule 19 (generateAssignQuad -> .)
    TO              reduce using rule 19 (generateAssignQuad -> .)

    generateAssignQuad             shift and go to state 230

state 225

    (23) read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .

    ID              reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    READ            reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    WRITE           reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    FOR             reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    WHILE           reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    IF              reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    RETURN          reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    SEMMICOLON      reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)


state 226

    (33) for -> FOR assign TO CTEI DO LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)

    assign                         shift and go to state 56
    statements                     shift and go to state 231
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 227

    (34) while -> WHILE LPAREN exp RPAREN DO LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)

    statements                     shift and go to state 232
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 228

    (35) if -> IF LPAREN exp RPAREN THEN LCURLY . statements RCURLY else
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)

    statements                     shift and go to state 233
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 229

    (94) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .

    FUNCTION        reduce using rule 94 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .)
    PRINCIPAL       reduce using rule 94 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .)
    $end            reduce using rule 94 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .)


state 230

    (18) assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .

    SEMMICOLON      reduce using rule 18 (assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .)
    TO              reduce using rule 18 (assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .)


state 231

    (33) for -> FOR assign TO CTEI DO LCURLY statements . RCURLY

    RCURLY          shift and go to state 234


state 232

    (34) while -> WHILE LPAREN exp RPAREN DO LCURLY statements . RCURLY

    RCURLY          shift and go to state 235


state 233

    (35) if -> IF LPAREN exp RPAREN THEN LCURLY statements . RCURLY else

    RCURLY          shift and go to state 236


state 234

    (33) for -> FOR assign TO CTEI DO LCURLY statements RCURLY .

    ID              reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    READ            reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    WRITE           reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    FOR             reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    WHILE           reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    IF              reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    RETURN          reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    RCURLY          reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)


state 235

    (34) while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .

    ID              reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    READ            reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    WRITE           reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    FOR             reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    WHILE           reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    IF              reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    RETURN          reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    RCURLY          reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)


state 236

    (35) if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY . else
    (36) else -> . ELSE LCURLY statements RCURLY
    (37) else -> . empty
    (104) empty -> .

    ELSE            shift and go to state 238
    ID              reduce using rule 104 (empty -> .)
    READ            reduce using rule 104 (empty -> .)
    WRITE           reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    WHILE           reduce using rule 104 (empty -> .)
    IF              reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    RCURLY          reduce using rule 104 (empty -> .)
    SEMMICOLON      reduce using rule 104 (empty -> .)

    else                           shift and go to state 237
    empty                          shift and go to state 239

state 237

    (35) if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .

    ID              reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    READ            reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    WRITE           reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    FOR             reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    WHILE           reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    IF              reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    RETURN          reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    RCURLY          reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    SEMMICOLON      reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)


state 238

    (36) else -> ELSE . LCURLY statements RCURLY

    LCURLY          shift and go to state 240


state 239

    (37) else -> empty .

    ID              reduce using rule 37 (else -> empty .)
    READ            reduce using rule 37 (else -> empty .)
    WRITE           reduce using rule 37 (else -> empty .)
    FOR             reduce using rule 37 (else -> empty .)
    WHILE           reduce using rule 37 (else -> empty .)
    IF              reduce using rule 37 (else -> empty .)
    RETURN          reduce using rule 37 (else -> empty .)
    RCURLY          reduce using rule 37 (else -> empty .)
    SEMMICOLON      reduce using rule 37 (else -> empty .)


state 240

    (36) else -> ELSE LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (102) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (103) return -> . RETURN LPAREN exp RPAREN
    (104) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 104 (empty -> .)

    statements                     shift and go to state 241
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 241

    (36) else -> ELSE LCURLY statements . RCURLY

    RCURLY          shift and go to state 242


state 242

    (36) else -> ELSE LCURLY statements RCURLY .

    ID              reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    READ            reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    WRITE           reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    FOR             reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    WHILE           reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    IF              reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    RETURN          reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    RCURLY          reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PRINCIPAL in state 5 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 47 resolved as shift
WARNING: shift/reduce conflict for ID in state 52 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 53 resolved as shift
WARNING: shift/reduce conflict for ID in state 77 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 78 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MUL in state 85 resolved as shift
WARNING: shift/reduce conflict for DIV in state 85 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 92 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 92 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 161 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 161 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 161 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 161 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 161 resolved as shift
WARNING: shift/reduce conflict for ID in state 161 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 162 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 162 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 162 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 162 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 162 resolved as shift
WARNING: shift/reduce conflict for ID in state 162 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 163 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 163 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 163 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 163 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 163 resolved as shift
WARNING: shift/reduce conflict for ID in state 163 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 164 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 164 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 164 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 164 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 164 resolved as shift
WARNING: shift/reduce conflict for ID in state 164 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 165 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 165 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 165 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 165 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 165 resolved as shift
WARNING: shift/reduce conflict for ID in state 165 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 166 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 166 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 166 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 166 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 166 resolved as shift
WARNING: shift/reduce conflict for ID in state 166 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 167 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 167 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 167 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 167 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 167 resolved as shift
WARNING: shift/reduce conflict for ID in state 167 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 168 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 168 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 168 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 168 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 168 resolved as shift
WARNING: shift/reduce conflict for ID in state 168 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 169 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 169 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 169 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 169 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 169 resolved as shift
WARNING: shift/reduce conflict for ID in state 169 resolved as shift
WARNING: shift/reduce conflict for SEMMICOLON in state 185 resolved as shift
WARNING: reduce/reduce conflict in state 180 resolved using rule (generateQuadPRINT -> <empty>)
WARNING: rejected rule (pexp -> CTEI saveCTE) in state 180
WARNING: reduce/reduce conflict in state 181 resolved using rule (generateQuadPRINT -> <empty>)
WARNING: rejected rule (pexp -> CTEF saveCTE) in state 181
