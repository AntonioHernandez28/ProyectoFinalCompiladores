Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMPARE
    END
    FROM
    MODA
    PLOTXY
    SIMPLEREGRESSION
    VARIANZA

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMMICOLON addProgram program1
Rule 2     addProgram -> <empty>
Rule 3     program1 -> vars functions program2
Rule 4     program1 -> vars functions
Rule 5     program1 -> program2
Rule 6     program2 -> principal
Rule 7     principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY
Rule 8     statements -> assign SEMMICOLON statements
Rule 9     statements -> functionCall SEMMICOLON statements
Rule 10    statements -> read statements SEMMICOLON statements
Rule 11    statements -> write statements SEMMICOLON statements
Rule 12    statements -> for statements
Rule 13    statements -> while statements
Rule 14    statements -> if statements
Rule 15    statements -> return statements
Rule 16    statements -> empty
Rule 17    assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad
Rule 18    assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
Rule 19    generateAssignQuad -> <empty>
Rule 20    add_id -> <empty>
Rule 21    add_id2 -> <empty>
Rule 22    functionCall -> ID LPAREN exp RPAREN
Rule 23    read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN
Rule 24    operatorRead -> <empty>
Rule 25    media -> MEDIA LPAREN arr RPAREN SEMMICOLON
Rule 26    write -> WRITE LPAREN write1 RPAREN
Rule 27    write1 -> write2 COMMA write2
Rule 28    write1 -> write2
Rule 29    write2 -> COMILLA CTESTRING COMILLA
Rule 30    write2 -> CTEI saveCTE generateQuadPRINT
Rule 31    write2 -> CTEF saveCTE generateQuadPRINT
Rule 32    write2 -> exp
Rule 33    for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
Rule 34    forOP -> <empty>
Rule 35    generateQuadFOR -> <empty>
Rule 36    LoopEnd -> <empty>
Rule 37    while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
Rule 38    whileOP -> <empty>
Rule 39    generateQuadWHILE -> <empty>
Rule 40    if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
Rule 41    else -> ELSE generateQuadELSE LCURLY statements RCURLY
Rule 42    else -> empty
Rule 43    generateQuadOR -> <empty>
Rule 44    generateQuadAND -> <empty>
Rule 45    generateQuadCOMPARE -> <empty>
Rule 46    generateQuadIF -> <empty>
Rule 47    generateQuadSUM -> <empty>
Rule 48    generateQuadMUL -> <empty>
Rule 49    generateQuadPRINT -> <empty>
Rule 50    generateQuadREAD -> <empty>
Rule 51    endIF -> <empty>
Rule 52    generateQuadELSE -> <empty>
Rule 53    saveCTE -> <empty>
Rule 54    exp -> nexp generateQuadOR
Rule 55    exp -> nexp generateQuadOR OR saveOperator nexp
Rule 56    nexp -> compexp generateQuadAND
Rule 57    nexp -> compexp generateQuadAND AND saveOperator compexp
Rule 58    compexp -> sumexp
Rule 59    compexp -> compexp1 sumexp
Rule 60    compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE
Rule 61    compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE
Rule 62    compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE
Rule 63    compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE
Rule 64    compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE
Rule 65    sumexp -> mulexp
Rule 66    sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM
Rule 67    sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM
Rule 68    mulexp -> pexp
Rule 69    mulexp -> pexp MUL saveOperator pexp generateQuadMUL
Rule 70    mulexp -> pexp DIV saveOperator pexp generateQuadMUL
Rule 71    pexp -> var1 add_id
Rule 72    pexp -> CTEI saveCTE
Rule 73    pexp -> CTEF saveCTE
Rule 74    pexp -> CTEC saveCTE
Rule 75    pexp -> CTESTRING saveCTE
Rule 76    pexp -> functionCall
Rule 77    pexp -> LPAREN exp RPAREN
Rule 78    saveOperator -> <empty>
Rule 79    vars -> var
Rule 80    vars -> empty
Rule 81    var -> VARS var2
Rule 82    var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar
Rule 83    var2 -> empty
Rule 84    var1 -> ID
Rule 85    var1 -> ID COMMA var1 addVar
Rule 86    var1 -> ID arr
Rule 87    var1 -> ID arr COMMA var1 addVar
Rule 88    var1 -> empty
Rule 89    addVar -> <empty>
Rule 90    saveTypeVar -> <empty>
Rule 91    type -> INT saveTypeVar
Rule 92    type -> CHAR saveTypeVar
Rule 93    type -> FLOAT saveTypeVar
Rule 94    arr -> LBRACKET CTEI RBRACKET
Rule 95    arr -> LBRACKET exp RBRACKET
Rule 96    functions -> FUNCTION INT functions1 functions
Rule 97    functions -> FUNCTION CHAR functions1 functions
Rule 98    functions -> FUNCTION FLOAT functions1 functions
Rule 99    functions -> FUNCTION VOID functions1 functions
Rule 100   functions -> empty
Rule 101   functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
Rule 102   functions1 -> empty
Rule 103   saveFunction -> <empty>
Rule 104   args -> args type TWOPOINTS var1 addVar
Rule 105   args -> empty
Rule 106   args1 -> ID addVar
Rule 107   args1 -> ID COMMA args1
Rule 108   args1 -> empty
Rule 109   return -> RETURN LPAREN exp RPAREN SEMMICOLON
Rule 110   return -> RETURN LPAREN exp RPAREN
Rule 111   empty -> <empty>

Terminals, with rules where they appear

AND                  : 57
CHAR                 : 92 97
COMILLA              : 29 29
COMMA                : 27 85 87 107
COMPARE              : 
CTEC                 : 74
CTEF                 : 31 73
CTEI                 : 30 33 72 94
CTESTRING            : 29 75
DIV                  : 70
DO                   : 33 37
ELSE                 : 41
END                  : 
EQUALS               : 17 18
FLOAT                : 93 98
FOR                  : 33
FROM                 : 
FUNCTION             : 96 97 98 99
GT                   : 60
GTE                  : 62
ID                   : 1 17 18 22 84 85 86 87 101 106 107
IF                   : 40
INT                  : 91 96
LBRACKET             : 94 95
LCURLY               : 7 33 37 40 41 101
LPAREN               : 7 22 23 25 26 37 40 77 101 109 110
LT                   : 61
LTE                  : 63
MEDIA                : 25
MINUS                : 67
MODA                 : 
MUL                  : 69
NE                   : 64
OR                   : 55
PLOTXY               : 
PLUS                 : 66
PRINCIPAL            : 7
PROGRAM              : 1
RBRACKET             : 94 95
RCURLY               : 7 33 37 40 41 101
READ                 : 23
RETURN               : 109 110
RPAREN               : 7 22 23 25 26 37 40 77 101 109 110
SEMMICOLON           : 1 8 9 10 11 25 82 109
SIMPLEREGRESSION     : 
THEN                 : 40
TO                   : 33
TWOPOINTS            : 82 104
VARIANZA             : 
VARS                 : 81
VOID                 : 99
WHILE                : 37
WRITE                : 26
error                : 

Nonterminals, with rules where they appear

LoopEnd              : 33 37
addProgram           : 1
addVar               : 82 85 87 104 106
add_id               : 71
add_id2              : 17 18
args                 : 101 104
args1                : 107
arr                  : 18 25 86 87
assign               : 8 33
compexp              : 56 57 57
compexp1             : 59
else                 : 40
empty                : 16 42 80 83 88 100 102 105 108
endIF                : 40
exp                  : 17 18 22 32 37 40 77 95 109 110
for                  : 12
forOP                : 33
functionCall         : 9 76
functions            : 3 4 96 97 98 99
functions1           : 96 97 98 99
generateAssignQuad   : 17 18
generateQuadAND      : 56 57
generateQuadCOMPARE  : 60 61 62 63 64
generateQuadELSE     : 41
generateQuadFOR      : 33
generateQuadIF       : 40
generateQuadMUL      : 69 70
generateQuadOR       : 54 55
generateQuadPRINT    : 30 31
generateQuadREAD     : 23
generateQuadSUM      : 66 67
generateQuadWHILE    : 37
if                   : 14
media                : 
mulexp               : 65 66 66 67 67
nexp                 : 54 55 55
operatorRead         : 23
pexp                 : 68 69 69 70 70
principal            : 6
program              : 0
program1             : 1
program2             : 3 5
read                 : 10
return               : 15
saveCTE              : 30 31 72 73 74 75
saveFunction         : 101
saveOperator         : 17 18 55 57 60 61 62 63 64 66 67 69 70
saveTypeVar          : 91 92 93
statements           : 7 8 9 10 10 11 11 12 13 14 15 33 37 40 41 101
sumexp               : 58 59 60 60 61 61 62 62 63 63 64 64
type                 : 82 104
var                  : 79
var1                 : 23 71 82 85 87 104
var2                 : 81 82
vars                 : 3 4 7 101
while                : 13
whileOP              : 37
write                : 11
write1               : 26
write2               : 27 27 28

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMMICOLON addProgram program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMMICOLON addProgram program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMMICOLON addProgram program1

    SEMMICOLON      shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMMICOLON . addProgram program1
    (2) addProgram -> .

    VARS            reduce using rule 2 (addProgram -> .)
    PRINCIPAL       reduce using rule 2 (addProgram -> .)
    FUNCTION        reduce using rule 2 (addProgram -> .)
    $end            reduce using rule 2 (addProgram -> .)

    addProgram                     shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMMICOLON addProgram . program1
    (3) program1 -> . vars functions program2
    (4) program1 -> . vars functions
    (5) program1 -> . program2
    (79) vars -> . var
    (80) vars -> . empty
    (6) program2 -> . principal
    (81) var -> . VARS var2
    (111) empty -> .
    (7) principal -> . PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY

  ! shift/reduce conflict for PRINCIPAL resolved as shift
    VARS            shift and go to state 12
    FUNCTION        reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)
    PRINCIPAL       shift and go to state 13

  ! PRINCIPAL       [ reduce using rule 111 (empty -> .) ]

    program1                       shift and go to state 6
    vars                           shift and go to state 7
    program2                       shift and go to state 8
    var                            shift and go to state 9
    empty                          shift and go to state 10
    principal                      shift and go to state 11

state 6

    (1) program -> PROGRAM ID SEMMICOLON addProgram program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMMICOLON addProgram program1 .)


state 7

    (3) program1 -> vars . functions program2
    (4) program1 -> vars . functions
    (96) functions -> . FUNCTION INT functions1 functions
    (97) functions -> . FUNCTION CHAR functions1 functions
    (98) functions -> . FUNCTION FLOAT functions1 functions
    (99) functions -> . FUNCTION VOID functions1 functions
    (100) functions -> . empty
    (111) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)

    functions                      shift and go to state 14
    empty                          shift and go to state 16

state 8

    (5) program1 -> program2 .

    $end            reduce using rule 5 (program1 -> program2 .)


state 9

    (79) vars -> var .

    FUNCTION        reduce using rule 79 (vars -> var .)
    PRINCIPAL       reduce using rule 79 (vars -> var .)
    $end            reduce using rule 79 (vars -> var .)
    ID              reduce using rule 79 (vars -> var .)
    READ            reduce using rule 79 (vars -> var .)
    WRITE           reduce using rule 79 (vars -> var .)
    FOR             reduce using rule 79 (vars -> var .)
    WHILE           reduce using rule 79 (vars -> var .)
    IF              reduce using rule 79 (vars -> var .)
    RETURN          reduce using rule 79 (vars -> var .)
    RCURLY          reduce using rule 79 (vars -> var .)
    LCURLY          reduce using rule 79 (vars -> var .)


state 10

    (80) vars -> empty .

    FUNCTION        reduce using rule 80 (vars -> empty .)
    PRINCIPAL       reduce using rule 80 (vars -> empty .)
    $end            reduce using rule 80 (vars -> empty .)
    ID              reduce using rule 80 (vars -> empty .)
    READ            reduce using rule 80 (vars -> empty .)
    WRITE           reduce using rule 80 (vars -> empty .)
    FOR             reduce using rule 80 (vars -> empty .)
    WHILE           reduce using rule 80 (vars -> empty .)
    IF              reduce using rule 80 (vars -> empty .)
    RETURN          reduce using rule 80 (vars -> empty .)
    RCURLY          reduce using rule 80 (vars -> empty .)
    LCURLY          reduce using rule 80 (vars -> empty .)


state 11

    (6) program2 -> principal .

    $end            reduce using rule 6 (program2 -> principal .)


state 12

    (81) var -> VARS . var2
    (82) var2 -> . var2 type TWOPOINTS var1 SEMMICOLON addVar
    (83) var2 -> . empty
    (111) empty -> .

    INT             reduce using rule 111 (empty -> .)
    CHAR            reduce using rule 111 (empty -> .)
    FLOAT           reduce using rule 111 (empty -> .)
    FUNCTION        reduce using rule 111 (empty -> .)
    PRINCIPAL       reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)
    ID              reduce using rule 111 (empty -> .)
    READ            reduce using rule 111 (empty -> .)
    WRITE           reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)
    RCURLY          reduce using rule 111 (empty -> .)
    LCURLY          reduce using rule 111 (empty -> .)

    var2                           shift and go to state 17
    empty                          shift and go to state 18

state 13

    (7) principal -> PRINCIPAL . LPAREN RPAREN LCURLY vars statements RCURLY

    LPAREN          shift and go to state 19


state 14

    (3) program1 -> vars functions . program2
    (4) program1 -> vars functions .
    (6) program2 -> . principal
    (7) principal -> . PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY

    $end            reduce using rule 4 (program1 -> vars functions .)
    PRINCIPAL       shift and go to state 13

    program2                       shift and go to state 20
    principal                      shift and go to state 11

state 15

    (96) functions -> FUNCTION . INT functions1 functions
    (97) functions -> FUNCTION . CHAR functions1 functions
    (98) functions -> FUNCTION . FLOAT functions1 functions
    (99) functions -> FUNCTION . VOID functions1 functions

    INT             shift and go to state 21
    CHAR            shift and go to state 22
    FLOAT           shift and go to state 23
    VOID            shift and go to state 24


state 16

    (100) functions -> empty .

    PRINCIPAL       reduce using rule 100 (functions -> empty .)
    $end            reduce using rule 100 (functions -> empty .)


state 17

    (81) var -> VARS var2 .
    (82) var2 -> var2 . type TWOPOINTS var1 SEMMICOLON addVar
    (91) type -> . INT saveTypeVar
    (92) type -> . CHAR saveTypeVar
    (93) type -> . FLOAT saveTypeVar

    FUNCTION        reduce using rule 81 (var -> VARS var2 .)
    PRINCIPAL       reduce using rule 81 (var -> VARS var2 .)
    $end            reduce using rule 81 (var -> VARS var2 .)
    ID              reduce using rule 81 (var -> VARS var2 .)
    READ            reduce using rule 81 (var -> VARS var2 .)
    WRITE           reduce using rule 81 (var -> VARS var2 .)
    FOR             reduce using rule 81 (var -> VARS var2 .)
    WHILE           reduce using rule 81 (var -> VARS var2 .)
    IF              reduce using rule 81 (var -> VARS var2 .)
    RETURN          reduce using rule 81 (var -> VARS var2 .)
    RCURLY          reduce using rule 81 (var -> VARS var2 .)
    LCURLY          reduce using rule 81 (var -> VARS var2 .)
    INT             shift and go to state 26
    CHAR            shift and go to state 27
    FLOAT           shift and go to state 28

    type                           shift and go to state 25

state 18

    (83) var2 -> empty .

    INT             reduce using rule 83 (var2 -> empty .)
    CHAR            reduce using rule 83 (var2 -> empty .)
    FLOAT           reduce using rule 83 (var2 -> empty .)
    FUNCTION        reduce using rule 83 (var2 -> empty .)
    PRINCIPAL       reduce using rule 83 (var2 -> empty .)
    $end            reduce using rule 83 (var2 -> empty .)
    ID              reduce using rule 83 (var2 -> empty .)
    READ            reduce using rule 83 (var2 -> empty .)
    WRITE           reduce using rule 83 (var2 -> empty .)
    FOR             reduce using rule 83 (var2 -> empty .)
    WHILE           reduce using rule 83 (var2 -> empty .)
    IF              reduce using rule 83 (var2 -> empty .)
    RETURN          reduce using rule 83 (var2 -> empty .)
    RCURLY          reduce using rule 83 (var2 -> empty .)
    LCURLY          reduce using rule 83 (var2 -> empty .)


state 19

    (7) principal -> PRINCIPAL LPAREN . RPAREN LCURLY vars statements RCURLY

    RPAREN          shift and go to state 29


state 20

    (3) program1 -> vars functions program2 .

    $end            reduce using rule 3 (program1 -> vars functions program2 .)


state 21

    (96) functions -> FUNCTION INT . functions1 functions
    (101) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (102) functions1 -> . empty
    (111) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 111 (empty -> .)
    PRINCIPAL       reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)

    functions1                     shift and go to state 30
    empty                          shift and go to state 32

state 22

    (97) functions -> FUNCTION CHAR . functions1 functions
    (101) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (102) functions1 -> . empty
    (111) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 111 (empty -> .)
    PRINCIPAL       reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)

    functions1                     shift and go to state 33
    empty                          shift and go to state 32

state 23

    (98) functions -> FUNCTION FLOAT . functions1 functions
    (101) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (102) functions1 -> . empty
    (111) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 111 (empty -> .)
    PRINCIPAL       reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)

    functions1                     shift and go to state 34
    empty                          shift and go to state 32

state 24

    (99) functions -> FUNCTION VOID . functions1 functions
    (101) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (102) functions1 -> . empty
    (111) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 111 (empty -> .)
    PRINCIPAL       reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)

    functions1                     shift and go to state 35
    empty                          shift and go to state 32

state 25

    (82) var2 -> var2 type . TWOPOINTS var1 SEMMICOLON addVar

    TWOPOINTS       shift and go to state 36


state 26

    (91) type -> INT . saveTypeVar
    (90) saveTypeVar -> .

    TWOPOINTS       reduce using rule 90 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 37

state 27

    (92) type -> CHAR . saveTypeVar
    (90) saveTypeVar -> .

    TWOPOINTS       reduce using rule 90 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 38

state 28

    (93) type -> FLOAT . saveTypeVar
    (90) saveTypeVar -> .

    TWOPOINTS       reduce using rule 90 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 39

state 29

    (7) principal -> PRINCIPAL LPAREN RPAREN . LCURLY vars statements RCURLY

    LCURLY          shift and go to state 40


state 30

    (96) functions -> FUNCTION INT functions1 . functions
    (96) functions -> . FUNCTION INT functions1 functions
    (97) functions -> . FUNCTION CHAR functions1 functions
    (98) functions -> . FUNCTION FLOAT functions1 functions
    (99) functions -> . FUNCTION VOID functions1 functions
    (100) functions -> . empty
    (111) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)

    functions                      shift and go to state 41
    empty                          shift and go to state 16

state 31

    (101) functions1 -> ID . saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (103) saveFunction -> .

    LPAREN          reduce using rule 103 (saveFunction -> .)

    saveFunction                   shift and go to state 42

state 32

    (102) functions1 -> empty .

    FUNCTION        reduce using rule 102 (functions1 -> empty .)
    PRINCIPAL       reduce using rule 102 (functions1 -> empty .)
    $end            reduce using rule 102 (functions1 -> empty .)


state 33

    (97) functions -> FUNCTION CHAR functions1 . functions
    (96) functions -> . FUNCTION INT functions1 functions
    (97) functions -> . FUNCTION CHAR functions1 functions
    (98) functions -> . FUNCTION FLOAT functions1 functions
    (99) functions -> . FUNCTION VOID functions1 functions
    (100) functions -> . empty
    (111) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)

    functions                      shift and go to state 43
    empty                          shift and go to state 16

state 34

    (98) functions -> FUNCTION FLOAT functions1 . functions
    (96) functions -> . FUNCTION INT functions1 functions
    (97) functions -> . FUNCTION CHAR functions1 functions
    (98) functions -> . FUNCTION FLOAT functions1 functions
    (99) functions -> . FUNCTION VOID functions1 functions
    (100) functions -> . empty
    (111) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)

    functions                      shift and go to state 44
    empty                          shift and go to state 16

state 35

    (99) functions -> FUNCTION VOID functions1 . functions
    (96) functions -> . FUNCTION INT functions1 functions
    (97) functions -> . FUNCTION CHAR functions1 functions
    (98) functions -> . FUNCTION FLOAT functions1 functions
    (99) functions -> . FUNCTION VOID functions1 functions
    (100) functions -> . empty
    (111) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)

    functions                      shift and go to state 45
    empty                          shift and go to state 16

state 36

    (82) var2 -> var2 type TWOPOINTS . var1 SEMMICOLON addVar
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (111) empty -> .

    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 111 (empty -> .)

    var1                           shift and go to state 46
    empty                          shift and go to state 48

state 37

    (91) type -> INT saveTypeVar .

    TWOPOINTS       reduce using rule 91 (type -> INT saveTypeVar .)


state 38

    (92) type -> CHAR saveTypeVar .

    TWOPOINTS       reduce using rule 92 (type -> CHAR saveTypeVar .)


state 39

    (93) type -> FLOAT saveTypeVar .

    TWOPOINTS       reduce using rule 93 (type -> FLOAT saveTypeVar .)


state 40

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY . vars statements RCURLY
    (79) vars -> . var
    (80) vars -> . empty
    (81) var -> . VARS var2
    (111) empty -> .

    VARS            shift and go to state 12
    ID              reduce using rule 111 (empty -> .)
    READ            reduce using rule 111 (empty -> .)
    WRITE           reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)
    RCURLY          reduce using rule 111 (empty -> .)

    vars                           shift and go to state 49
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 41

    (96) functions -> FUNCTION INT functions1 functions .

    PRINCIPAL       reduce using rule 96 (functions -> FUNCTION INT functions1 functions .)
    $end            reduce using rule 96 (functions -> FUNCTION INT functions1 functions .)


state 42

    (101) functions1 -> ID saveFunction . LPAREN args RPAREN vars LCURLY statements RCURLY

    LPAREN          shift and go to state 50


state 43

    (97) functions -> FUNCTION CHAR functions1 functions .

    PRINCIPAL       reduce using rule 97 (functions -> FUNCTION CHAR functions1 functions .)
    $end            reduce using rule 97 (functions -> FUNCTION CHAR functions1 functions .)


state 44

    (98) functions -> FUNCTION FLOAT functions1 functions .

    PRINCIPAL       reduce using rule 98 (functions -> FUNCTION FLOAT functions1 functions .)
    $end            reduce using rule 98 (functions -> FUNCTION FLOAT functions1 functions .)


state 45

    (99) functions -> FUNCTION VOID functions1 functions .

    PRINCIPAL       reduce using rule 99 (functions -> FUNCTION VOID functions1 functions .)
    $end            reduce using rule 99 (functions -> FUNCTION VOID functions1 functions .)


state 46

    (82) var2 -> var2 type TWOPOINTS var1 . SEMMICOLON addVar

    SEMMICOLON      shift and go to state 51


state 47

    (84) var1 -> ID .
    (85) var1 -> ID . COMMA var1 addVar
    (86) var1 -> ID . arr
    (87) var1 -> ID . arr COMMA var1 addVar
    (94) arr -> . LBRACKET CTEI RBRACKET
    (95) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 84 (var1 -> ID .)
    MUL             reduce using rule 84 (var1 -> ID .)
    DIV             reduce using rule 84 (var1 -> ID .)
    PLUS            reduce using rule 84 (var1 -> ID .)
    MINUS           reduce using rule 84 (var1 -> ID .)
    GT              reduce using rule 84 (var1 -> ID .)
    LT              reduce using rule 84 (var1 -> ID .)
    GTE             reduce using rule 84 (var1 -> ID .)
    LTE             reduce using rule 84 (var1 -> ID .)
    NE              reduce using rule 84 (var1 -> ID .)
    AND             reduce using rule 84 (var1 -> ID .)
    OR              reduce using rule 84 (var1 -> ID .)
    RBRACKET        reduce using rule 84 (var1 -> ID .)
    RPAREN          reduce using rule 84 (var1 -> ID .)
    TO              reduce using rule 84 (var1 -> ID .)
    INT             reduce using rule 84 (var1 -> ID .)
    CHAR            reduce using rule 84 (var1 -> ID .)
    FLOAT           reduce using rule 84 (var1 -> ID .)
    CTEI            reduce using rule 84 (var1 -> ID .)
    CTEF            reduce using rule 84 (var1 -> ID .)
    CTEC            reduce using rule 84 (var1 -> ID .)
    CTESTRING       reduce using rule 84 (var1 -> ID .)
    LPAREN          reduce using rule 84 (var1 -> ID .)
    ID              reduce using rule 84 (var1 -> ID .)
    COMMA           shift and go to state 52
    LBRACKET        shift and go to state 54

  ! COMMA           [ reduce using rule 84 (var1 -> ID .) ]

    arr                            shift and go to state 53

state 48

    (88) var1 -> empty .

    SEMMICOLON      reduce using rule 88 (var1 -> empty .)
    MUL             reduce using rule 88 (var1 -> empty .)
    DIV             reduce using rule 88 (var1 -> empty .)
    PLUS            reduce using rule 88 (var1 -> empty .)
    MINUS           reduce using rule 88 (var1 -> empty .)
    GT              reduce using rule 88 (var1 -> empty .)
    LT              reduce using rule 88 (var1 -> empty .)
    GTE             reduce using rule 88 (var1 -> empty .)
    LTE             reduce using rule 88 (var1 -> empty .)
    NE              reduce using rule 88 (var1 -> empty .)
    AND             reduce using rule 88 (var1 -> empty .)
    OR              reduce using rule 88 (var1 -> empty .)
    RBRACKET        reduce using rule 88 (var1 -> empty .)
    RPAREN          reduce using rule 88 (var1 -> empty .)
    COMMA           reduce using rule 88 (var1 -> empty .)
    TO              reduce using rule 88 (var1 -> empty .)
    INT             reduce using rule 88 (var1 -> empty .)
    CHAR            reduce using rule 88 (var1 -> empty .)
    FLOAT           reduce using rule 88 (var1 -> empty .)
    CTEI            reduce using rule 88 (var1 -> empty .)
    CTEF            reduce using rule 88 (var1 -> empty .)
    CTEC            reduce using rule 88 (var1 -> empty .)
    CTESTRING       reduce using rule 88 (var1 -> empty .)
    LPAREN          reduce using rule 88 (var1 -> empty .)
    ID              reduce using rule 88 (var1 -> empty .)


state 49

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY vars . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)

    statements                     shift and go to state 55
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 50

    (101) functions1 -> ID saveFunction LPAREN . args RPAREN vars LCURLY statements RCURLY
    (104) args -> . args type TWOPOINTS var1 addVar
    (105) args -> . empty
    (111) empty -> .

    RPAREN          reduce using rule 111 (empty -> .)
    INT             reduce using rule 111 (empty -> .)
    CHAR            reduce using rule 111 (empty -> .)
    FLOAT           reduce using rule 111 (empty -> .)

    args                           shift and go to state 72
    empty                          shift and go to state 73

state 51

    (82) var2 -> var2 type TWOPOINTS var1 SEMMICOLON . addVar
    (89) addVar -> .

    INT             reduce using rule 89 (addVar -> .)
    CHAR            reduce using rule 89 (addVar -> .)
    FLOAT           reduce using rule 89 (addVar -> .)
    FUNCTION        reduce using rule 89 (addVar -> .)
    PRINCIPAL       reduce using rule 89 (addVar -> .)
    $end            reduce using rule 89 (addVar -> .)
    ID              reduce using rule 89 (addVar -> .)
    READ            reduce using rule 89 (addVar -> .)
    WRITE           reduce using rule 89 (addVar -> .)
    FOR             reduce using rule 89 (addVar -> .)
    WHILE           reduce using rule 89 (addVar -> .)
    IF              reduce using rule 89 (addVar -> .)
    RETURN          reduce using rule 89 (addVar -> .)
    RCURLY          reduce using rule 89 (addVar -> .)
    LCURLY          reduce using rule 89 (addVar -> .)

    addVar                         shift and go to state 74

state 52

    (85) var1 -> ID COMMA . var1 addVar
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (111) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 111 (empty -> .)
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    INT             reduce using rule 111 (empty -> .)
    CHAR            reduce using rule 111 (empty -> .)
    FLOAT           reduce using rule 111 (empty -> .)
    CTEI            reduce using rule 111 (empty -> .)
    CTEF            reduce using rule 111 (empty -> .)
    CTEC            reduce using rule 111 (empty -> .)
    CTESTRING       reduce using rule 111 (empty -> .)
    LPAREN          reduce using rule 111 (empty -> .)

  ! ID              [ reduce using rule 111 (empty -> .) ]

    var1                           shift and go to state 75
    empty                          shift and go to state 48

state 53

    (86) var1 -> ID arr .
    (87) var1 -> ID arr . COMMA var1 addVar

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 86 (var1 -> ID arr .)
    MUL             reduce using rule 86 (var1 -> ID arr .)
    DIV             reduce using rule 86 (var1 -> ID arr .)
    PLUS            reduce using rule 86 (var1 -> ID arr .)
    MINUS           reduce using rule 86 (var1 -> ID arr .)
    GT              reduce using rule 86 (var1 -> ID arr .)
    LT              reduce using rule 86 (var1 -> ID arr .)
    GTE             reduce using rule 86 (var1 -> ID arr .)
    LTE             reduce using rule 86 (var1 -> ID arr .)
    NE              reduce using rule 86 (var1 -> ID arr .)
    AND             reduce using rule 86 (var1 -> ID arr .)
    OR              reduce using rule 86 (var1 -> ID arr .)
    RBRACKET        reduce using rule 86 (var1 -> ID arr .)
    RPAREN          reduce using rule 86 (var1 -> ID arr .)
    TO              reduce using rule 86 (var1 -> ID arr .)
    INT             reduce using rule 86 (var1 -> ID arr .)
    CHAR            reduce using rule 86 (var1 -> ID arr .)
    FLOAT           reduce using rule 86 (var1 -> ID arr .)
    CTEI            reduce using rule 86 (var1 -> ID arr .)
    CTEF            reduce using rule 86 (var1 -> ID arr .)
    CTEC            reduce using rule 86 (var1 -> ID arr .)
    CTESTRING       reduce using rule 86 (var1 -> ID arr .)
    LPAREN          reduce using rule 86 (var1 -> ID arr .)
    ID              reduce using rule 86 (var1 -> ID arr .)
    COMMA           shift and go to state 76

  ! COMMA           [ reduce using rule 86 (var1 -> ID arr .) ]


state 54

    (94) arr -> LBRACKET . CTEI RBRACKET
    (95) arr -> LBRACKET . exp RBRACKET
    (54) exp -> . nexp generateQuadOR
    (55) exp -> . nexp generateQuadOR OR saveOperator nexp
    (56) nexp -> . compexp generateQuadAND
    (57) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    CTEI            shift and go to state 77
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)

    exp                            shift and go to state 78
    nexp                           shift and go to state 79
    compexp                        shift and go to state 80
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 55

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements . RCURLY

    RCURLY          shift and go to state 92


state 56

    (8) statements -> assign . SEMMICOLON statements

    SEMMICOLON      shift and go to state 93


state 57

    (9) statements -> functionCall . SEMMICOLON statements

    SEMMICOLON      shift and go to state 94


state 58

    (10) statements -> read . statements SEMMICOLON statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    SEMMICOLON      reduce using rule 111 (empty -> .)

    read                           shift and go to state 58
    statements                     shift and go to state 95
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 59

    (11) statements -> write . statements SEMMICOLON statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    SEMMICOLON      reduce using rule 111 (empty -> .)

    write                          shift and go to state 59
    statements                     shift and go to state 96
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 60

    (12) statements -> for . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)

    for                            shift and go to state 60
    statements                     shift and go to state 97
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 61

    (13) statements -> while . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)

    while                          shift and go to state 61
    statements                     shift and go to state 98
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 62

    (14) statements -> if . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)

    if                             shift and go to state 62
    statements                     shift and go to state 99
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 63

    (15) statements -> return . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)

    return                         shift and go to state 63
    statements                     shift and go to state 100
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    empty                          shift and go to state 64

state 64

    (16) statements -> empty .

    RCURLY          reduce using rule 16 (statements -> empty .)
    SEMMICOLON      reduce using rule 16 (statements -> empty .)


state 65

    (17) assign -> ID . add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> ID . add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> ID . LPAREN exp RPAREN
    (21) add_id2 -> .

    LPAREN          shift and go to state 102
    EQUALS          reduce using rule 21 (add_id2 -> .)
    LBRACKET        reduce using rule 21 (add_id2 -> .)

    add_id2                        shift and go to state 101

state 66

    (23) read -> READ . operatorRead LPAREN var1 generateQuadREAD RPAREN
    (24) operatorRead -> .

    LPAREN          reduce using rule 24 (operatorRead -> .)

    operatorRead                   shift and go to state 103

state 67

    (26) write -> WRITE . LPAREN write1 RPAREN

    LPAREN          shift and go to state 104


state 68

    (33) for -> FOR . forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (34) forOP -> .

    ID              reduce using rule 34 (forOP -> .)

    forOP                          shift and go to state 105

state 69

    (37) while -> WHILE . whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (38) whileOP -> .

    LPAREN          reduce using rule 38 (whileOP -> .)

    whileOP                        shift and go to state 106

state 70

    (40) if -> IF . LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF

    LPAREN          shift and go to state 107


state 71

    (109) return -> RETURN . LPAREN exp RPAREN SEMMICOLON
    (110) return -> RETURN . LPAREN exp RPAREN

    LPAREN          shift and go to state 108


state 72

    (101) functions1 -> ID saveFunction LPAREN args . RPAREN vars LCURLY statements RCURLY
    (104) args -> args . type TWOPOINTS var1 addVar
    (91) type -> . INT saveTypeVar
    (92) type -> . CHAR saveTypeVar
    (93) type -> . FLOAT saveTypeVar

    RPAREN          shift and go to state 109
    INT             shift and go to state 26
    CHAR            shift and go to state 27
    FLOAT           shift and go to state 28

    type                           shift and go to state 110

state 73

    (105) args -> empty .

    RPAREN          reduce using rule 105 (args -> empty .)
    INT             reduce using rule 105 (args -> empty .)
    CHAR            reduce using rule 105 (args -> empty .)
    FLOAT           reduce using rule 105 (args -> empty .)


state 74

    (82) var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .

    INT             reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    CHAR            reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FLOAT           reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FUNCTION        reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    PRINCIPAL       reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    $end            reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    ID              reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    READ            reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WRITE           reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FOR             reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WHILE           reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    IF              reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    RETURN          reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    RCURLY          reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    LCURLY          reduce using rule 82 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)


state 75

    (85) var1 -> ID COMMA var1 . addVar
    (89) addVar -> .

    SEMMICOLON      reduce using rule 89 (addVar -> .)
    MUL             reduce using rule 89 (addVar -> .)
    DIV             reduce using rule 89 (addVar -> .)
    PLUS            reduce using rule 89 (addVar -> .)
    MINUS           reduce using rule 89 (addVar -> .)
    GT              reduce using rule 89 (addVar -> .)
    LT              reduce using rule 89 (addVar -> .)
    GTE             reduce using rule 89 (addVar -> .)
    LTE             reduce using rule 89 (addVar -> .)
    NE              reduce using rule 89 (addVar -> .)
    AND             reduce using rule 89 (addVar -> .)
    OR              reduce using rule 89 (addVar -> .)
    RBRACKET        reduce using rule 89 (addVar -> .)
    RPAREN          reduce using rule 89 (addVar -> .)
    COMMA           reduce using rule 89 (addVar -> .)
    TO              reduce using rule 89 (addVar -> .)
    INT             reduce using rule 89 (addVar -> .)
    CHAR            reduce using rule 89 (addVar -> .)
    FLOAT           reduce using rule 89 (addVar -> .)
    CTEI            reduce using rule 89 (addVar -> .)
    CTEF            reduce using rule 89 (addVar -> .)
    CTEC            reduce using rule 89 (addVar -> .)
    CTESTRING       reduce using rule 89 (addVar -> .)
    LPAREN          reduce using rule 89 (addVar -> .)
    ID              reduce using rule 89 (addVar -> .)

    addVar                         shift and go to state 111

state 76

    (87) var1 -> ID arr COMMA . var1 addVar
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (111) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 111 (empty -> .)
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    INT             reduce using rule 111 (empty -> .)
    CHAR            reduce using rule 111 (empty -> .)
    FLOAT           reduce using rule 111 (empty -> .)
    CTEI            reduce using rule 111 (empty -> .)
    CTEF            reduce using rule 111 (empty -> .)
    CTEC            reduce using rule 111 (empty -> .)
    CTESTRING       reduce using rule 111 (empty -> .)
    LPAREN          reduce using rule 111 (empty -> .)

  ! ID              [ reduce using rule 111 (empty -> .) ]

    var1                           shift and go to state 112
    empty                          shift and go to state 48

state 77

    (94) arr -> LBRACKET CTEI . RBRACKET
    (72) pexp -> CTEI . saveCTE
    (53) saveCTE -> .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 113
    MUL             reduce using rule 53 (saveCTE -> .)
    DIV             reduce using rule 53 (saveCTE -> .)
    PLUS            reduce using rule 53 (saveCTE -> .)
    MINUS           reduce using rule 53 (saveCTE -> .)
    GT              reduce using rule 53 (saveCTE -> .)
    LT              reduce using rule 53 (saveCTE -> .)
    GTE             reduce using rule 53 (saveCTE -> .)
    LTE             reduce using rule 53 (saveCTE -> .)
    NE              reduce using rule 53 (saveCTE -> .)
    AND             reduce using rule 53 (saveCTE -> .)
    OR              reduce using rule 53 (saveCTE -> .)

  ! RBRACKET        [ reduce using rule 53 (saveCTE -> .) ]

    saveCTE                        shift and go to state 114

state 78

    (95) arr -> LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 115


state 79

    (54) exp -> nexp . generateQuadOR
    (55) exp -> nexp . generateQuadOR OR saveOperator nexp
    (43) generateQuadOR -> .

    OR              reduce using rule 43 (generateQuadOR -> .)
    RBRACKET        reduce using rule 43 (generateQuadOR -> .)
    RPAREN          reduce using rule 43 (generateQuadOR -> .)
    COMMA           reduce using rule 43 (generateQuadOR -> .)
    SEMMICOLON      reduce using rule 43 (generateQuadOR -> .)
    TO              reduce using rule 43 (generateQuadOR -> .)

    generateQuadOR                 shift and go to state 116

state 80

    (56) nexp -> compexp . generateQuadAND
    (57) nexp -> compexp . generateQuadAND AND saveOperator compexp
    (44) generateQuadAND -> .

    AND             reduce using rule 44 (generateQuadAND -> .)
    OR              reduce using rule 44 (generateQuadAND -> .)
    RBRACKET        reduce using rule 44 (generateQuadAND -> .)
    RPAREN          reduce using rule 44 (generateQuadAND -> .)
    COMMA           reduce using rule 44 (generateQuadAND -> .)
    SEMMICOLON      reduce using rule 44 (generateQuadAND -> .)
    TO              reduce using rule 44 (generateQuadAND -> .)

    generateQuadAND                shift and go to state 117

state 81

    (58) compexp -> sumexp .
    (60) compexp1 -> sumexp . GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> sumexp . LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> sumexp . GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> sumexp . LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> sumexp . NE saveOperator sumexp generateQuadCOMPARE

    AND             reduce using rule 58 (compexp -> sumexp .)
    OR              reduce using rule 58 (compexp -> sumexp .)
    RBRACKET        reduce using rule 58 (compexp -> sumexp .)
    RPAREN          reduce using rule 58 (compexp -> sumexp .)
    COMMA           reduce using rule 58 (compexp -> sumexp .)
    SEMMICOLON      reduce using rule 58 (compexp -> sumexp .)
    TO              reduce using rule 58 (compexp -> sumexp .)
    GT              shift and go to state 118
    LT              shift and go to state 119
    GTE             shift and go to state 120
    LTE             shift and go to state 121
    NE              shift and go to state 122


state 82

    (59) compexp -> compexp1 . sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)

    sumexp                         shift and go to state 123
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 83

    (65) sumexp -> mulexp .
    (66) sumexp -> mulexp . PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> mulexp . MINUS saveOperator mulexp generateQuadSUM

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    GT              reduce using rule 65 (sumexp -> mulexp .)
    LT              reduce using rule 65 (sumexp -> mulexp .)
    GTE             reduce using rule 65 (sumexp -> mulexp .)
    LTE             reduce using rule 65 (sumexp -> mulexp .)
    NE              reduce using rule 65 (sumexp -> mulexp .)
    AND             reduce using rule 65 (sumexp -> mulexp .)
    OR              reduce using rule 65 (sumexp -> mulexp .)
    RBRACKET        reduce using rule 65 (sumexp -> mulexp .)
    RPAREN          reduce using rule 65 (sumexp -> mulexp .)
    COMMA           reduce using rule 65 (sumexp -> mulexp .)
    SEMMICOLON      reduce using rule 65 (sumexp -> mulexp .)
    TO              reduce using rule 65 (sumexp -> mulexp .)
    CTEI            reduce using rule 65 (sumexp -> mulexp .)
    CTEF            reduce using rule 65 (sumexp -> mulexp .)
    CTEC            reduce using rule 65 (sumexp -> mulexp .)
    CTESTRING       reduce using rule 65 (sumexp -> mulexp .)
    LPAREN          reduce using rule 65 (sumexp -> mulexp .)
    ID              reduce using rule 65 (sumexp -> mulexp .)
    MUL             reduce using rule 65 (sumexp -> mulexp .)
    DIV             reduce using rule 65 (sumexp -> mulexp .)
    PLUS            shift and go to state 125
    MINUS           shift and go to state 126

  ! PLUS            [ reduce using rule 65 (sumexp -> mulexp .) ]
  ! MINUS           [ reduce using rule 65 (sumexp -> mulexp .) ]


state 84

    (68) mulexp -> pexp .
    (69) mulexp -> pexp . MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> pexp . DIV saveOperator pexp generateQuadMUL

  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    PLUS            reduce using rule 68 (mulexp -> pexp .)
    MINUS           reduce using rule 68 (mulexp -> pexp .)
    GT              reduce using rule 68 (mulexp -> pexp .)
    LT              reduce using rule 68 (mulexp -> pexp .)
    GTE             reduce using rule 68 (mulexp -> pexp .)
    LTE             reduce using rule 68 (mulexp -> pexp .)
    NE              reduce using rule 68 (mulexp -> pexp .)
    AND             reduce using rule 68 (mulexp -> pexp .)
    OR              reduce using rule 68 (mulexp -> pexp .)
    RBRACKET        reduce using rule 68 (mulexp -> pexp .)
    RPAREN          reduce using rule 68 (mulexp -> pexp .)
    COMMA           reduce using rule 68 (mulexp -> pexp .)
    SEMMICOLON      reduce using rule 68 (mulexp -> pexp .)
    TO              reduce using rule 68 (mulexp -> pexp .)
    CTEI            reduce using rule 68 (mulexp -> pexp .)
    CTEF            reduce using rule 68 (mulexp -> pexp .)
    CTEC            reduce using rule 68 (mulexp -> pexp .)
    CTESTRING       reduce using rule 68 (mulexp -> pexp .)
    LPAREN          reduce using rule 68 (mulexp -> pexp .)
    ID              reduce using rule 68 (mulexp -> pexp .)
    MUL             shift and go to state 127
    DIV             shift and go to state 128

  ! MUL             [ reduce using rule 68 (mulexp -> pexp .) ]
  ! DIV             [ reduce using rule 68 (mulexp -> pexp .) ]


state 85

    (71) pexp -> var1 . add_id
    (20) add_id -> .

    MUL             reduce using rule 20 (add_id -> .)
    DIV             reduce using rule 20 (add_id -> .)
    PLUS            reduce using rule 20 (add_id -> .)
    MINUS           reduce using rule 20 (add_id -> .)
    GT              reduce using rule 20 (add_id -> .)
    LT              reduce using rule 20 (add_id -> .)
    GTE             reduce using rule 20 (add_id -> .)
    LTE             reduce using rule 20 (add_id -> .)
    NE              reduce using rule 20 (add_id -> .)
    AND             reduce using rule 20 (add_id -> .)
    OR              reduce using rule 20 (add_id -> .)
    RBRACKET        reduce using rule 20 (add_id -> .)
    RPAREN          reduce using rule 20 (add_id -> .)
    COMMA           reduce using rule 20 (add_id -> .)
    SEMMICOLON      reduce using rule 20 (add_id -> .)
    TO              reduce using rule 20 (add_id -> .)
    CTEI            reduce using rule 20 (add_id -> .)
    CTEF            reduce using rule 20 (add_id -> .)
    CTEC            reduce using rule 20 (add_id -> .)
    CTESTRING       reduce using rule 20 (add_id -> .)
    LPAREN          reduce using rule 20 (add_id -> .)
    ID              reduce using rule 20 (add_id -> .)

    add_id                         shift and go to state 129

state 86

    (73) pexp -> CTEF . saveCTE
    (53) saveCTE -> .

    MUL             reduce using rule 53 (saveCTE -> .)
    DIV             reduce using rule 53 (saveCTE -> .)
    PLUS            reduce using rule 53 (saveCTE -> .)
    MINUS           reduce using rule 53 (saveCTE -> .)
    GT              reduce using rule 53 (saveCTE -> .)
    LT              reduce using rule 53 (saveCTE -> .)
    GTE             reduce using rule 53 (saveCTE -> .)
    LTE             reduce using rule 53 (saveCTE -> .)
    NE              reduce using rule 53 (saveCTE -> .)
    AND             reduce using rule 53 (saveCTE -> .)
    OR              reduce using rule 53 (saveCTE -> .)
    RBRACKET        reduce using rule 53 (saveCTE -> .)
    RPAREN          reduce using rule 53 (saveCTE -> .)
    COMMA           reduce using rule 53 (saveCTE -> .)
    SEMMICOLON      reduce using rule 53 (saveCTE -> .)
    TO              reduce using rule 53 (saveCTE -> .)
    CTEI            reduce using rule 53 (saveCTE -> .)
    CTEF            reduce using rule 53 (saveCTE -> .)
    CTEC            reduce using rule 53 (saveCTE -> .)
    CTESTRING       reduce using rule 53 (saveCTE -> .)
    LPAREN          reduce using rule 53 (saveCTE -> .)
    ID              reduce using rule 53 (saveCTE -> .)

    saveCTE                        shift and go to state 130

state 87

    (74) pexp -> CTEC . saveCTE
    (53) saveCTE -> .

    MUL             reduce using rule 53 (saveCTE -> .)
    DIV             reduce using rule 53 (saveCTE -> .)
    PLUS            reduce using rule 53 (saveCTE -> .)
    MINUS           reduce using rule 53 (saveCTE -> .)
    GT              reduce using rule 53 (saveCTE -> .)
    LT              reduce using rule 53 (saveCTE -> .)
    GTE             reduce using rule 53 (saveCTE -> .)
    LTE             reduce using rule 53 (saveCTE -> .)
    NE              reduce using rule 53 (saveCTE -> .)
    AND             reduce using rule 53 (saveCTE -> .)
    OR              reduce using rule 53 (saveCTE -> .)
    RBRACKET        reduce using rule 53 (saveCTE -> .)
    RPAREN          reduce using rule 53 (saveCTE -> .)
    COMMA           reduce using rule 53 (saveCTE -> .)
    SEMMICOLON      reduce using rule 53 (saveCTE -> .)
    TO              reduce using rule 53 (saveCTE -> .)
    CTEI            reduce using rule 53 (saveCTE -> .)
    CTEF            reduce using rule 53 (saveCTE -> .)
    CTEC            reduce using rule 53 (saveCTE -> .)
    CTESTRING       reduce using rule 53 (saveCTE -> .)
    LPAREN          reduce using rule 53 (saveCTE -> .)
    ID              reduce using rule 53 (saveCTE -> .)

    saveCTE                        shift and go to state 131

state 88

    (75) pexp -> CTESTRING . saveCTE
    (53) saveCTE -> .

    MUL             reduce using rule 53 (saveCTE -> .)
    DIV             reduce using rule 53 (saveCTE -> .)
    PLUS            reduce using rule 53 (saveCTE -> .)
    MINUS           reduce using rule 53 (saveCTE -> .)
    GT              reduce using rule 53 (saveCTE -> .)
    LT              reduce using rule 53 (saveCTE -> .)
    GTE             reduce using rule 53 (saveCTE -> .)
    LTE             reduce using rule 53 (saveCTE -> .)
    NE              reduce using rule 53 (saveCTE -> .)
    AND             reduce using rule 53 (saveCTE -> .)
    OR              reduce using rule 53 (saveCTE -> .)
    RBRACKET        reduce using rule 53 (saveCTE -> .)
    RPAREN          reduce using rule 53 (saveCTE -> .)
    COMMA           reduce using rule 53 (saveCTE -> .)
    SEMMICOLON      reduce using rule 53 (saveCTE -> .)
    TO              reduce using rule 53 (saveCTE -> .)
    CTEI            reduce using rule 53 (saveCTE -> .)
    CTEF            reduce using rule 53 (saveCTE -> .)
    CTEC            reduce using rule 53 (saveCTE -> .)
    CTESTRING       reduce using rule 53 (saveCTE -> .)
    LPAREN          reduce using rule 53 (saveCTE -> .)
    ID              reduce using rule 53 (saveCTE -> .)

    saveCTE                        shift and go to state 132

state 89

    (76) pexp -> functionCall .

    MUL             reduce using rule 76 (pexp -> functionCall .)
    DIV             reduce using rule 76 (pexp -> functionCall .)
    PLUS            reduce using rule 76 (pexp -> functionCall .)
    MINUS           reduce using rule 76 (pexp -> functionCall .)
    GT              reduce using rule 76 (pexp -> functionCall .)
    LT              reduce using rule 76 (pexp -> functionCall .)
    GTE             reduce using rule 76 (pexp -> functionCall .)
    LTE             reduce using rule 76 (pexp -> functionCall .)
    NE              reduce using rule 76 (pexp -> functionCall .)
    AND             reduce using rule 76 (pexp -> functionCall .)
    OR              reduce using rule 76 (pexp -> functionCall .)
    RBRACKET        reduce using rule 76 (pexp -> functionCall .)
    RPAREN          reduce using rule 76 (pexp -> functionCall .)
    COMMA           reduce using rule 76 (pexp -> functionCall .)
    SEMMICOLON      reduce using rule 76 (pexp -> functionCall .)
    TO              reduce using rule 76 (pexp -> functionCall .)
    CTEI            reduce using rule 76 (pexp -> functionCall .)
    CTEF            reduce using rule 76 (pexp -> functionCall .)
    CTEC            reduce using rule 76 (pexp -> functionCall .)
    CTESTRING       reduce using rule 76 (pexp -> functionCall .)
    LPAREN          reduce using rule 76 (pexp -> functionCall .)
    ID              reduce using rule 76 (pexp -> functionCall .)


state 90

    (77) pexp -> LPAREN . exp RPAREN
    (54) exp -> . nexp generateQuadOR
    (55) exp -> . nexp generateQuadOR OR saveOperator nexp
    (56) nexp -> . compexp generateQuadAND
    (57) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)

    exp                            shift and go to state 133
    nexp                           shift and go to state 79
    compexp                        shift and go to state 80
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 91

    (84) var1 -> ID .
    (85) var1 -> ID . COMMA var1 addVar
    (86) var1 -> ID . arr
    (87) var1 -> ID . arr COMMA var1 addVar
    (22) functionCall -> ID . LPAREN exp RPAREN
    (94) arr -> . LBRACKET CTEI RBRACKET
    (95) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    MUL             reduce using rule 84 (var1 -> ID .)
    DIV             reduce using rule 84 (var1 -> ID .)
    PLUS            reduce using rule 84 (var1 -> ID .)
    MINUS           reduce using rule 84 (var1 -> ID .)
    GT              reduce using rule 84 (var1 -> ID .)
    LT              reduce using rule 84 (var1 -> ID .)
    GTE             reduce using rule 84 (var1 -> ID .)
    LTE             reduce using rule 84 (var1 -> ID .)
    NE              reduce using rule 84 (var1 -> ID .)
    AND             reduce using rule 84 (var1 -> ID .)
    OR              reduce using rule 84 (var1 -> ID .)
    RBRACKET        reduce using rule 84 (var1 -> ID .)
    RPAREN          reduce using rule 84 (var1 -> ID .)
    SEMMICOLON      reduce using rule 84 (var1 -> ID .)
    TO              reduce using rule 84 (var1 -> ID .)
    CTEI            reduce using rule 84 (var1 -> ID .)
    CTEF            reduce using rule 84 (var1 -> ID .)
    CTEC            reduce using rule 84 (var1 -> ID .)
    CTESTRING       reduce using rule 84 (var1 -> ID .)
    ID              reduce using rule 84 (var1 -> ID .)
    COMMA           shift and go to state 52
    LPAREN          shift and go to state 102
    LBRACKET        shift and go to state 54

  ! COMMA           [ reduce using rule 84 (var1 -> ID .) ]
  ! LPAREN          [ reduce using rule 84 (var1 -> ID .) ]

    arr                            shift and go to state 53

state 92

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY .

    $end            reduce using rule 7 (principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY .)


state 93

    (8) statements -> assign SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)

    assign                         shift and go to state 56
    statements                     shift and go to state 134
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 94

    (9) statements -> functionCall SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)

    functionCall                   shift and go to state 57
    statements                     shift and go to state 135
    assign                         shift and go to state 56
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 95

    (10) statements -> read statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 136


state 96

    (11) statements -> write statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 137


state 97

    (12) statements -> for statements .

    RCURLY          reduce using rule 12 (statements -> for statements .)
    SEMMICOLON      reduce using rule 12 (statements -> for statements .)


state 98

    (13) statements -> while statements .

    RCURLY          reduce using rule 13 (statements -> while statements .)
    SEMMICOLON      reduce using rule 13 (statements -> while statements .)


state 99

    (14) statements -> if statements .

    RCURLY          reduce using rule 14 (statements -> if statements .)
    SEMMICOLON      reduce using rule 14 (statements -> if statements .)


state 100

    (15) statements -> return statements .

    RCURLY          reduce using rule 15 (statements -> return statements .)
    SEMMICOLON      reduce using rule 15 (statements -> return statements .)


state 101

    (17) assign -> ID add_id2 . EQUALS saveOperator exp generateAssignQuad
    (18) assign -> ID add_id2 . arr EQUALS saveOperator exp generateAssignQuad
    (94) arr -> . LBRACKET CTEI RBRACKET
    (95) arr -> . LBRACKET exp RBRACKET

    EQUALS          shift and go to state 138
    LBRACKET        shift and go to state 54

    arr                            shift and go to state 139

state 102

    (22) functionCall -> ID LPAREN . exp RPAREN
    (54) exp -> . nexp generateQuadOR
    (55) exp -> . nexp generateQuadOR OR saveOperator nexp
    (56) nexp -> . compexp generateQuadAND
    (57) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)

    exp                            shift and go to state 140
    nexp                           shift and go to state 79
    compexp                        shift and go to state 80
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 103

    (23) read -> READ operatorRead . LPAREN var1 generateQuadREAD RPAREN

    LPAREN          shift and go to state 141


state 104

    (26) write -> WRITE LPAREN . write1 RPAREN
    (27) write1 -> . write2 COMMA write2
    (28) write1 -> . write2
    (29) write2 -> . COMILLA CTESTRING COMILLA
    (30) write2 -> . CTEI saveCTE generateQuadPRINT
    (31) write2 -> . CTEF saveCTE generateQuadPRINT
    (32) write2 -> . exp
    (54) exp -> . nexp generateQuadOR
    (55) exp -> . nexp generateQuadOR OR saveOperator nexp
    (56) nexp -> . compexp generateQuadAND
    (57) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    COMILLA         shift and go to state 144
    CTEI            shift and go to state 145
    CTEF            shift and go to state 146
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)

    write1                         shift and go to state 142
    write2                         shift and go to state 143
    exp                            shift and go to state 147
    nexp                           shift and go to state 79
    compexp                        shift and go to state 80
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 105

    (33) for -> FOR forOP . assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad

    ID              shift and go to state 149

    assign                         shift and go to state 148

state 106

    (37) while -> WHILE whileOP . LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    LPAREN          shift and go to state 150


state 107

    (40) if -> IF LPAREN . exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (54) exp -> . nexp generateQuadOR
    (55) exp -> . nexp generateQuadOR OR saveOperator nexp
    (56) nexp -> . compexp generateQuadAND
    (57) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)

    exp                            shift and go to state 151
    nexp                           shift and go to state 79
    compexp                        shift and go to state 80
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 108

    (109) return -> RETURN LPAREN . exp RPAREN SEMMICOLON
    (110) return -> RETURN LPAREN . exp RPAREN
    (54) exp -> . nexp generateQuadOR
    (55) exp -> . nexp generateQuadOR OR saveOperator nexp
    (56) nexp -> . compexp generateQuadAND
    (57) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)

    exp                            shift and go to state 152
    nexp                           shift and go to state 79
    compexp                        shift and go to state 80
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 109

    (101) functions1 -> ID saveFunction LPAREN args RPAREN . vars LCURLY statements RCURLY
    (79) vars -> . var
    (80) vars -> . empty
    (81) var -> . VARS var2
    (111) empty -> .

    VARS            shift and go to state 12
    LCURLY          reduce using rule 111 (empty -> .)

    vars                           shift and go to state 153
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 110

    (104) args -> args type . TWOPOINTS var1 addVar

    TWOPOINTS       shift and go to state 154


state 111

    (85) var1 -> ID COMMA var1 addVar .

    SEMMICOLON      reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    MUL             reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    DIV             reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    PLUS            reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    MINUS           reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    GT              reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    LT              reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    GTE             reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    LTE             reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    NE              reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    AND             reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    OR              reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    RBRACKET        reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    RPAREN          reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    COMMA           reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    TO              reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    INT             reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    CHAR            reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    FLOAT           reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    CTEI            reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    CTEF            reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    CTEC            reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    CTESTRING       reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    LPAREN          reduce using rule 85 (var1 -> ID COMMA var1 addVar .)
    ID              reduce using rule 85 (var1 -> ID COMMA var1 addVar .)


state 112

    (87) var1 -> ID arr COMMA var1 . addVar
    (89) addVar -> .

    SEMMICOLON      reduce using rule 89 (addVar -> .)
    MUL             reduce using rule 89 (addVar -> .)
    DIV             reduce using rule 89 (addVar -> .)
    PLUS            reduce using rule 89 (addVar -> .)
    MINUS           reduce using rule 89 (addVar -> .)
    GT              reduce using rule 89 (addVar -> .)
    LT              reduce using rule 89 (addVar -> .)
    GTE             reduce using rule 89 (addVar -> .)
    LTE             reduce using rule 89 (addVar -> .)
    NE              reduce using rule 89 (addVar -> .)
    AND             reduce using rule 89 (addVar -> .)
    OR              reduce using rule 89 (addVar -> .)
    RBRACKET        reduce using rule 89 (addVar -> .)
    RPAREN          reduce using rule 89 (addVar -> .)
    COMMA           reduce using rule 89 (addVar -> .)
    TO              reduce using rule 89 (addVar -> .)
    INT             reduce using rule 89 (addVar -> .)
    CHAR            reduce using rule 89 (addVar -> .)
    FLOAT           reduce using rule 89 (addVar -> .)
    CTEI            reduce using rule 89 (addVar -> .)
    CTEF            reduce using rule 89 (addVar -> .)
    CTEC            reduce using rule 89 (addVar -> .)
    CTESTRING       reduce using rule 89 (addVar -> .)
    LPAREN          reduce using rule 89 (addVar -> .)
    ID              reduce using rule 89 (addVar -> .)

    addVar                         shift and go to state 155

state 113

    (94) arr -> LBRACKET CTEI RBRACKET .

    COMMA           reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    SEMMICOLON      reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    MUL             reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    DIV             reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    PLUS            reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    MINUS           reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    GT              reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    LT              reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    GTE             reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    LTE             reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    NE              reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    AND             reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    OR              reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    RBRACKET        reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    RPAREN          reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    TO              reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    INT             reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    CHAR            reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    FLOAT           reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    CTEI            reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    CTEF            reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    CTEC            reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    CTESTRING       reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    LPAREN          reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    ID              reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)
    EQUALS          reduce using rule 94 (arr -> LBRACKET CTEI RBRACKET .)


state 114

    (72) pexp -> CTEI saveCTE .

    MUL             reduce using rule 72 (pexp -> CTEI saveCTE .)
    DIV             reduce using rule 72 (pexp -> CTEI saveCTE .)
    PLUS            reduce using rule 72 (pexp -> CTEI saveCTE .)
    MINUS           reduce using rule 72 (pexp -> CTEI saveCTE .)
    GT              reduce using rule 72 (pexp -> CTEI saveCTE .)
    LT              reduce using rule 72 (pexp -> CTEI saveCTE .)
    GTE             reduce using rule 72 (pexp -> CTEI saveCTE .)
    LTE             reduce using rule 72 (pexp -> CTEI saveCTE .)
    NE              reduce using rule 72 (pexp -> CTEI saveCTE .)
    AND             reduce using rule 72 (pexp -> CTEI saveCTE .)
    OR              reduce using rule 72 (pexp -> CTEI saveCTE .)
    RBRACKET        reduce using rule 72 (pexp -> CTEI saveCTE .)
    RPAREN          reduce using rule 72 (pexp -> CTEI saveCTE .)
    COMMA           reduce using rule 72 (pexp -> CTEI saveCTE .)
    SEMMICOLON      reduce using rule 72 (pexp -> CTEI saveCTE .)
    TO              reduce using rule 72 (pexp -> CTEI saveCTE .)
    CTEI            reduce using rule 72 (pexp -> CTEI saveCTE .)
    CTEF            reduce using rule 72 (pexp -> CTEI saveCTE .)
    CTEC            reduce using rule 72 (pexp -> CTEI saveCTE .)
    CTESTRING       reduce using rule 72 (pexp -> CTEI saveCTE .)
    LPAREN          reduce using rule 72 (pexp -> CTEI saveCTE .)
    ID              reduce using rule 72 (pexp -> CTEI saveCTE .)


state 115

    (95) arr -> LBRACKET exp RBRACKET .

    COMMA           reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    SEMMICOLON      reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    MUL             reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    DIV             reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    GT              reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    LT              reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    GTE             reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    LTE             reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    NE              reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    AND             reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    OR              reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    TO              reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    INT             reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    CHAR            reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    FLOAT           reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    CTEI            reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    CTEF            reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    CTEC            reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    CTESTRING       reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    ID              reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 95 (arr -> LBRACKET exp RBRACKET .)


state 116

    (54) exp -> nexp generateQuadOR .
    (55) exp -> nexp generateQuadOR . OR saveOperator nexp

    RBRACKET        reduce using rule 54 (exp -> nexp generateQuadOR .)
    RPAREN          reduce using rule 54 (exp -> nexp generateQuadOR .)
    COMMA           reduce using rule 54 (exp -> nexp generateQuadOR .)
    SEMMICOLON      reduce using rule 54 (exp -> nexp generateQuadOR .)
    TO              reduce using rule 54 (exp -> nexp generateQuadOR .)
    OR              shift and go to state 156


state 117

    (56) nexp -> compexp generateQuadAND .
    (57) nexp -> compexp generateQuadAND . AND saveOperator compexp

    OR              reduce using rule 56 (nexp -> compexp generateQuadAND .)
    RBRACKET        reduce using rule 56 (nexp -> compexp generateQuadAND .)
    RPAREN          reduce using rule 56 (nexp -> compexp generateQuadAND .)
    COMMA           reduce using rule 56 (nexp -> compexp generateQuadAND .)
    SEMMICOLON      reduce using rule 56 (nexp -> compexp generateQuadAND .)
    TO              reduce using rule 56 (nexp -> compexp generateQuadAND .)
    AND             shift and go to state 157


state 118

    (60) compexp1 -> sumexp GT . saveOperator sumexp generateQuadCOMPARE
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    RBRACKET        reduce using rule 78 (saveOperator -> .)
    RPAREN          reduce using rule 78 (saveOperator -> .)
    COMMA           reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 158

state 119

    (61) compexp1 -> sumexp LT . saveOperator sumexp generateQuadCOMPARE
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    RBRACKET        reduce using rule 78 (saveOperator -> .)
    RPAREN          reduce using rule 78 (saveOperator -> .)
    COMMA           reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 159

state 120

    (62) compexp1 -> sumexp GTE . saveOperator sumexp generateQuadCOMPARE
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    RBRACKET        reduce using rule 78 (saveOperator -> .)
    RPAREN          reduce using rule 78 (saveOperator -> .)
    COMMA           reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 160

state 121

    (63) compexp1 -> sumexp LTE . saveOperator sumexp generateQuadCOMPARE
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    RBRACKET        reduce using rule 78 (saveOperator -> .)
    RPAREN          reduce using rule 78 (saveOperator -> .)
    COMMA           reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 161

state 122

    (64) compexp1 -> sumexp NE . saveOperator sumexp generateQuadCOMPARE
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    RBRACKET        reduce using rule 78 (saveOperator -> .)
    RPAREN          reduce using rule 78 (saveOperator -> .)
    COMMA           reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 162

state 123

    (59) compexp -> compexp1 sumexp .

    AND             reduce using rule 59 (compexp -> compexp1 sumexp .)
    OR              reduce using rule 59 (compexp -> compexp1 sumexp .)
    RBRACKET        reduce using rule 59 (compexp -> compexp1 sumexp .)
    RPAREN          reduce using rule 59 (compexp -> compexp1 sumexp .)
    COMMA           reduce using rule 59 (compexp -> compexp1 sumexp .)
    SEMMICOLON      reduce using rule 59 (compexp -> compexp1 sumexp .)
    TO              reduce using rule 59 (compexp -> compexp1 sumexp .)


state 124

    (72) pexp -> CTEI . saveCTE
    (53) saveCTE -> .

    MUL             reduce using rule 53 (saveCTE -> .)
    DIV             reduce using rule 53 (saveCTE -> .)
    PLUS            reduce using rule 53 (saveCTE -> .)
    MINUS           reduce using rule 53 (saveCTE -> .)
    AND             reduce using rule 53 (saveCTE -> .)
    OR              reduce using rule 53 (saveCTE -> .)
    RBRACKET        reduce using rule 53 (saveCTE -> .)
    RPAREN          reduce using rule 53 (saveCTE -> .)
    COMMA           reduce using rule 53 (saveCTE -> .)
    SEMMICOLON      reduce using rule 53 (saveCTE -> .)
    TO              reduce using rule 53 (saveCTE -> .)
    GT              reduce using rule 53 (saveCTE -> .)
    LT              reduce using rule 53 (saveCTE -> .)
    GTE             reduce using rule 53 (saveCTE -> .)
    LTE             reduce using rule 53 (saveCTE -> .)
    NE              reduce using rule 53 (saveCTE -> .)
    CTEI            reduce using rule 53 (saveCTE -> .)
    CTEF            reduce using rule 53 (saveCTE -> .)
    CTEC            reduce using rule 53 (saveCTE -> .)
    CTESTRING       reduce using rule 53 (saveCTE -> .)
    LPAREN          reduce using rule 53 (saveCTE -> .)
    ID              reduce using rule 53 (saveCTE -> .)

    saveCTE                        shift and go to state 114

state 125

    (66) sumexp -> mulexp PLUS . saveOperator mulexp generateQuadSUM
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)
    GT              reduce using rule 78 (saveOperator -> .)
    LT              reduce using rule 78 (saveOperator -> .)
    GTE             reduce using rule 78 (saveOperator -> .)
    LTE             reduce using rule 78 (saveOperator -> .)
    NE              reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    RBRACKET        reduce using rule 78 (saveOperator -> .)
    RPAREN          reduce using rule 78 (saveOperator -> .)
    COMMA           reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 163

state 126

    (67) sumexp -> mulexp MINUS . saveOperator mulexp generateQuadSUM
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)
    GT              reduce using rule 78 (saveOperator -> .)
    LT              reduce using rule 78 (saveOperator -> .)
    GTE             reduce using rule 78 (saveOperator -> .)
    LTE             reduce using rule 78 (saveOperator -> .)
    NE              reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    RBRACKET        reduce using rule 78 (saveOperator -> .)
    RPAREN          reduce using rule 78 (saveOperator -> .)
    COMMA           reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 164

state 127

    (69) mulexp -> pexp MUL . saveOperator pexp generateQuadMUL
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)
    GT              reduce using rule 78 (saveOperator -> .)
    LT              reduce using rule 78 (saveOperator -> .)
    GTE             reduce using rule 78 (saveOperator -> .)
    LTE             reduce using rule 78 (saveOperator -> .)
    NE              reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    RBRACKET        reduce using rule 78 (saveOperator -> .)
    RPAREN          reduce using rule 78 (saveOperator -> .)
    COMMA           reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 165

state 128

    (70) mulexp -> pexp DIV . saveOperator pexp generateQuadMUL
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)
    GT              reduce using rule 78 (saveOperator -> .)
    LT              reduce using rule 78 (saveOperator -> .)
    GTE             reduce using rule 78 (saveOperator -> .)
    LTE             reduce using rule 78 (saveOperator -> .)
    NE              reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    RBRACKET        reduce using rule 78 (saveOperator -> .)
    RPAREN          reduce using rule 78 (saveOperator -> .)
    COMMA           reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 166

state 129

    (71) pexp -> var1 add_id .

    MUL             reduce using rule 71 (pexp -> var1 add_id .)
    DIV             reduce using rule 71 (pexp -> var1 add_id .)
    PLUS            reduce using rule 71 (pexp -> var1 add_id .)
    MINUS           reduce using rule 71 (pexp -> var1 add_id .)
    GT              reduce using rule 71 (pexp -> var1 add_id .)
    LT              reduce using rule 71 (pexp -> var1 add_id .)
    GTE             reduce using rule 71 (pexp -> var1 add_id .)
    LTE             reduce using rule 71 (pexp -> var1 add_id .)
    NE              reduce using rule 71 (pexp -> var1 add_id .)
    AND             reduce using rule 71 (pexp -> var1 add_id .)
    OR              reduce using rule 71 (pexp -> var1 add_id .)
    RBRACKET        reduce using rule 71 (pexp -> var1 add_id .)
    RPAREN          reduce using rule 71 (pexp -> var1 add_id .)
    COMMA           reduce using rule 71 (pexp -> var1 add_id .)
    SEMMICOLON      reduce using rule 71 (pexp -> var1 add_id .)
    TO              reduce using rule 71 (pexp -> var1 add_id .)
    CTEI            reduce using rule 71 (pexp -> var1 add_id .)
    CTEF            reduce using rule 71 (pexp -> var1 add_id .)
    CTEC            reduce using rule 71 (pexp -> var1 add_id .)
    CTESTRING       reduce using rule 71 (pexp -> var1 add_id .)
    LPAREN          reduce using rule 71 (pexp -> var1 add_id .)
    ID              reduce using rule 71 (pexp -> var1 add_id .)


state 130

    (73) pexp -> CTEF saveCTE .

    MUL             reduce using rule 73 (pexp -> CTEF saveCTE .)
    DIV             reduce using rule 73 (pexp -> CTEF saveCTE .)
    PLUS            reduce using rule 73 (pexp -> CTEF saveCTE .)
    MINUS           reduce using rule 73 (pexp -> CTEF saveCTE .)
    GT              reduce using rule 73 (pexp -> CTEF saveCTE .)
    LT              reduce using rule 73 (pexp -> CTEF saveCTE .)
    GTE             reduce using rule 73 (pexp -> CTEF saveCTE .)
    LTE             reduce using rule 73 (pexp -> CTEF saveCTE .)
    NE              reduce using rule 73 (pexp -> CTEF saveCTE .)
    AND             reduce using rule 73 (pexp -> CTEF saveCTE .)
    OR              reduce using rule 73 (pexp -> CTEF saveCTE .)
    RBRACKET        reduce using rule 73 (pexp -> CTEF saveCTE .)
    RPAREN          reduce using rule 73 (pexp -> CTEF saveCTE .)
    COMMA           reduce using rule 73 (pexp -> CTEF saveCTE .)
    SEMMICOLON      reduce using rule 73 (pexp -> CTEF saveCTE .)
    TO              reduce using rule 73 (pexp -> CTEF saveCTE .)
    CTEI            reduce using rule 73 (pexp -> CTEF saveCTE .)
    CTEF            reduce using rule 73 (pexp -> CTEF saveCTE .)
    CTEC            reduce using rule 73 (pexp -> CTEF saveCTE .)
    CTESTRING       reduce using rule 73 (pexp -> CTEF saveCTE .)
    LPAREN          reduce using rule 73 (pexp -> CTEF saveCTE .)
    ID              reduce using rule 73 (pexp -> CTEF saveCTE .)


state 131

    (74) pexp -> CTEC saveCTE .

    MUL             reduce using rule 74 (pexp -> CTEC saveCTE .)
    DIV             reduce using rule 74 (pexp -> CTEC saveCTE .)
    PLUS            reduce using rule 74 (pexp -> CTEC saveCTE .)
    MINUS           reduce using rule 74 (pexp -> CTEC saveCTE .)
    GT              reduce using rule 74 (pexp -> CTEC saveCTE .)
    LT              reduce using rule 74 (pexp -> CTEC saveCTE .)
    GTE             reduce using rule 74 (pexp -> CTEC saveCTE .)
    LTE             reduce using rule 74 (pexp -> CTEC saveCTE .)
    NE              reduce using rule 74 (pexp -> CTEC saveCTE .)
    AND             reduce using rule 74 (pexp -> CTEC saveCTE .)
    OR              reduce using rule 74 (pexp -> CTEC saveCTE .)
    RBRACKET        reduce using rule 74 (pexp -> CTEC saveCTE .)
    RPAREN          reduce using rule 74 (pexp -> CTEC saveCTE .)
    COMMA           reduce using rule 74 (pexp -> CTEC saveCTE .)
    SEMMICOLON      reduce using rule 74 (pexp -> CTEC saveCTE .)
    TO              reduce using rule 74 (pexp -> CTEC saveCTE .)
    CTEI            reduce using rule 74 (pexp -> CTEC saveCTE .)
    CTEF            reduce using rule 74 (pexp -> CTEC saveCTE .)
    CTEC            reduce using rule 74 (pexp -> CTEC saveCTE .)
    CTESTRING       reduce using rule 74 (pexp -> CTEC saveCTE .)
    LPAREN          reduce using rule 74 (pexp -> CTEC saveCTE .)
    ID              reduce using rule 74 (pexp -> CTEC saveCTE .)


state 132

    (75) pexp -> CTESTRING saveCTE .

    MUL             reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    DIV             reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    PLUS            reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    MINUS           reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    GT              reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    LT              reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    GTE             reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    LTE             reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    NE              reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    AND             reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    OR              reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    RBRACKET        reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    RPAREN          reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    COMMA           reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    SEMMICOLON      reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    TO              reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    CTEI            reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    CTEF            reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    CTEC            reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    CTESTRING       reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    LPAREN          reduce using rule 75 (pexp -> CTESTRING saveCTE .)
    ID              reduce using rule 75 (pexp -> CTESTRING saveCTE .)


state 133

    (77) pexp -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 167


state 134

    (8) statements -> assign SEMMICOLON statements .

    RCURLY          reduce using rule 8 (statements -> assign SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 8 (statements -> assign SEMMICOLON statements .)


state 135

    (9) statements -> functionCall SEMMICOLON statements .

    RCURLY          reduce using rule 9 (statements -> functionCall SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 9 (statements -> functionCall SEMMICOLON statements .)


state 136

    (10) statements -> read statements SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)

    read                           shift and go to state 58
    statements                     shift and go to state 168
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 137

    (11) statements -> write statements SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)

    write                          shift and go to state 59
    statements                     shift and go to state 169
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 138

    (17) assign -> ID add_id2 EQUALS . saveOperator exp generateAssignQuad
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    GT              reduce using rule 78 (saveOperator -> .)
    LT              reduce using rule 78 (saveOperator -> .)
    GTE             reduce using rule 78 (saveOperator -> .)
    LTE             reduce using rule 78 (saveOperator -> .)
    NE              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 170

state 139

    (18) assign -> ID add_id2 arr . EQUALS saveOperator exp generateAssignQuad

    EQUALS          shift and go to state 171


state 140

    (22) functionCall -> ID LPAREN exp . RPAREN

    RPAREN          shift and go to state 172


state 141

    (23) read -> READ operatorRead LPAREN . var1 generateQuadREAD RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (111) empty -> .

    ID              shift and go to state 47
    RPAREN          reduce using rule 111 (empty -> .)

    var1                           shift and go to state 173
    empty                          shift and go to state 48

state 142

    (26) write -> WRITE LPAREN write1 . RPAREN

    RPAREN          shift and go to state 174


state 143

    (27) write1 -> write2 . COMMA write2
    (28) write1 -> write2 .

    COMMA           shift and go to state 175
    RPAREN          reduce using rule 28 (write1 -> write2 .)


state 144

    (29) write2 -> COMILLA . CTESTRING COMILLA

    CTESTRING       shift and go to state 176


state 145

    (30) write2 -> CTEI . saveCTE generateQuadPRINT
    (72) pexp -> CTEI . saveCTE
    (53) saveCTE -> .

    COMMA           reduce using rule 53 (saveCTE -> .)
    RPAREN          reduce using rule 53 (saveCTE -> .)
    MUL             reduce using rule 53 (saveCTE -> .)
    DIV             reduce using rule 53 (saveCTE -> .)
    PLUS            reduce using rule 53 (saveCTE -> .)
    MINUS           reduce using rule 53 (saveCTE -> .)
    GT              reduce using rule 53 (saveCTE -> .)
    LT              reduce using rule 53 (saveCTE -> .)
    GTE             reduce using rule 53 (saveCTE -> .)
    LTE             reduce using rule 53 (saveCTE -> .)
    NE              reduce using rule 53 (saveCTE -> .)
    AND             reduce using rule 53 (saveCTE -> .)
    OR              reduce using rule 53 (saveCTE -> .)

    saveCTE                        shift and go to state 177

state 146

    (31) write2 -> CTEF . saveCTE generateQuadPRINT
    (73) pexp -> CTEF . saveCTE
    (53) saveCTE -> .

    COMMA           reduce using rule 53 (saveCTE -> .)
    RPAREN          reduce using rule 53 (saveCTE -> .)
    MUL             reduce using rule 53 (saveCTE -> .)
    DIV             reduce using rule 53 (saveCTE -> .)
    PLUS            reduce using rule 53 (saveCTE -> .)
    MINUS           reduce using rule 53 (saveCTE -> .)
    GT              reduce using rule 53 (saveCTE -> .)
    LT              reduce using rule 53 (saveCTE -> .)
    GTE             reduce using rule 53 (saveCTE -> .)
    LTE             reduce using rule 53 (saveCTE -> .)
    NE              reduce using rule 53 (saveCTE -> .)
    AND             reduce using rule 53 (saveCTE -> .)
    OR              reduce using rule 53 (saveCTE -> .)

    saveCTE                        shift and go to state 178

state 147

    (32) write2 -> exp .

    COMMA           reduce using rule 32 (write2 -> exp .)
    RPAREN          reduce using rule 32 (write2 -> exp .)


state 148

    (33) for -> FOR forOP assign . TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    TO              shift and go to state 179


state 149

    (17) assign -> ID . add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> ID . add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (21) add_id2 -> .

    EQUALS          reduce using rule 21 (add_id2 -> .)
    LBRACKET        reduce using rule 21 (add_id2 -> .)

    add_id2                        shift and go to state 101

state 150

    (37) while -> WHILE whileOP LPAREN . exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (54) exp -> . nexp generateQuadOR
    (55) exp -> . nexp generateQuadOR OR saveOperator nexp
    (56) nexp -> . compexp generateQuadAND
    (57) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)

    exp                            shift and go to state 180
    nexp                           shift and go to state 79
    compexp                        shift and go to state 80
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 151

    (40) if -> IF LPAREN exp . RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF

    RPAREN          shift and go to state 181


state 152

    (109) return -> RETURN LPAREN exp . RPAREN SEMMICOLON
    (110) return -> RETURN LPAREN exp . RPAREN

    RPAREN          shift and go to state 182


state 153

    (101) functions1 -> ID saveFunction LPAREN args RPAREN vars . LCURLY statements RCURLY

    LCURLY          shift and go to state 183


state 154

    (104) args -> args type TWOPOINTS . var1 addVar
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (111) empty -> .

    ID              shift and go to state 47
    RPAREN          reduce using rule 111 (empty -> .)
    INT             reduce using rule 111 (empty -> .)
    CHAR            reduce using rule 111 (empty -> .)
    FLOAT           reduce using rule 111 (empty -> .)

    var1                           shift and go to state 184
    empty                          shift and go to state 48

state 155

    (87) var1 -> ID arr COMMA var1 addVar .

    SEMMICOLON      reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    MUL             reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    DIV             reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    PLUS            reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    MINUS           reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    GT              reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    LT              reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    GTE             reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    LTE             reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    NE              reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    AND             reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    OR              reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    RBRACKET        reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    RPAREN          reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    COMMA           reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    TO              reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    INT             reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    CHAR            reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    FLOAT           reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    CTEI            reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    CTEF            reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    CTEC            reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    CTESTRING       reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    LPAREN          reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)
    ID              reduce using rule 87 (var1 -> ID arr COMMA var1 addVar .)


state 156

    (55) exp -> nexp generateQuadOR OR . saveOperator nexp
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    GT              reduce using rule 78 (saveOperator -> .)
    LT              reduce using rule 78 (saveOperator -> .)
    GTE             reduce using rule 78 (saveOperator -> .)
    LTE             reduce using rule 78 (saveOperator -> .)
    NE              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)
    RBRACKET        reduce using rule 78 (saveOperator -> .)
    RPAREN          reduce using rule 78 (saveOperator -> .)
    COMMA           reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 185

state 157

    (57) nexp -> compexp generateQuadAND AND . saveOperator compexp
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    GT              reduce using rule 78 (saveOperator -> .)
    LT              reduce using rule 78 (saveOperator -> .)
    GTE             reduce using rule 78 (saveOperator -> .)
    LTE             reduce using rule 78 (saveOperator -> .)
    NE              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    RBRACKET        reduce using rule 78 (saveOperator -> .)
    RPAREN          reduce using rule 78 (saveOperator -> .)
    COMMA           reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 186

state 158

    (60) compexp1 -> sumexp GT saveOperator . sumexp generateQuadCOMPARE
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)

  ! CTEI            [ reduce using rule 111 (empty -> .) ]
  ! CTEF            [ reduce using rule 111 (empty -> .) ]
  ! CTEC            [ reduce using rule 111 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! ID              [ reduce using rule 111 (empty -> .) ]

    sumexp                         shift and go to state 187
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 159

    (61) compexp1 -> sumexp LT saveOperator . sumexp generateQuadCOMPARE
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)

  ! CTEI            [ reduce using rule 111 (empty -> .) ]
  ! CTEF            [ reduce using rule 111 (empty -> .) ]
  ! CTEC            [ reduce using rule 111 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! ID              [ reduce using rule 111 (empty -> .) ]

    sumexp                         shift and go to state 188
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 160

    (62) compexp1 -> sumexp GTE saveOperator . sumexp generateQuadCOMPARE
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)

  ! CTEI            [ reduce using rule 111 (empty -> .) ]
  ! CTEF            [ reduce using rule 111 (empty -> .) ]
  ! CTEC            [ reduce using rule 111 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! ID              [ reduce using rule 111 (empty -> .) ]

    sumexp                         shift and go to state 189
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 161

    (63) compexp1 -> sumexp LTE saveOperator . sumexp generateQuadCOMPARE
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)

  ! CTEI            [ reduce using rule 111 (empty -> .) ]
  ! CTEF            [ reduce using rule 111 (empty -> .) ]
  ! CTEC            [ reduce using rule 111 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! ID              [ reduce using rule 111 (empty -> .) ]

    sumexp                         shift and go to state 190
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 162

    (64) compexp1 -> sumexp NE saveOperator . sumexp generateQuadCOMPARE
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)

  ! CTEI            [ reduce using rule 111 (empty -> .) ]
  ! CTEF            [ reduce using rule 111 (empty -> .) ]
  ! CTEC            [ reduce using rule 111 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! ID              [ reduce using rule 111 (empty -> .) ]

    sumexp                         shift and go to state 191
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 163

    (66) sumexp -> mulexp PLUS saveOperator . mulexp generateQuadSUM
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)

  ! CTEI            [ reduce using rule 111 (empty -> .) ]
  ! CTEF            [ reduce using rule 111 (empty -> .) ]
  ! CTEC            [ reduce using rule 111 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! ID              [ reduce using rule 111 (empty -> .) ]

    mulexp                         shift and go to state 192
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 164

    (67) sumexp -> mulexp MINUS saveOperator . mulexp generateQuadSUM
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)

  ! CTEI            [ reduce using rule 111 (empty -> .) ]
  ! CTEF            [ reduce using rule 111 (empty -> .) ]
  ! CTEC            [ reduce using rule 111 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! ID              [ reduce using rule 111 (empty -> .) ]

    mulexp                         shift and go to state 193
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 165

    (69) mulexp -> pexp MUL saveOperator . pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)

  ! CTEI            [ reduce using rule 111 (empty -> .) ]
  ! CTEF            [ reduce using rule 111 (empty -> .) ]
  ! CTEC            [ reduce using rule 111 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! ID              [ reduce using rule 111 (empty -> .) ]

    pexp                           shift and go to state 194
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 166

    (70) mulexp -> pexp DIV saveOperator . pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)

  ! CTEI            [ reduce using rule 111 (empty -> .) ]
  ! CTEF            [ reduce using rule 111 (empty -> .) ]
  ! CTEC            [ reduce using rule 111 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! ID              [ reduce using rule 111 (empty -> .) ]

    pexp                           shift and go to state 195
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 167

    (77) pexp -> LPAREN exp RPAREN .

    MUL             reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    DIV             reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    AND             reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    OR              reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    SEMMICOLON      reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    TO              reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    CTEI            reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    CTEF            reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    CTEC            reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    CTESTRING       reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 77 (pexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 77 (pexp -> LPAREN exp RPAREN .)


state 168

    (10) statements -> read statements SEMMICOLON statements .

    RCURLY          reduce using rule 10 (statements -> read statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 10 (statements -> read statements SEMMICOLON statements .)


state 169

    (11) statements -> write statements SEMMICOLON statements .

    RCURLY          reduce using rule 11 (statements -> write statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 11 (statements -> write statements SEMMICOLON statements .)


state 170

    (17) assign -> ID add_id2 EQUALS saveOperator . exp generateAssignQuad
    (54) exp -> . nexp generateQuadOR
    (55) exp -> . nexp generateQuadOR OR saveOperator nexp
    (56) nexp -> . compexp generateQuadAND
    (57) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)

    exp                            shift and go to state 196
    nexp                           shift and go to state 79
    compexp                        shift and go to state 80
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 171

    (18) assign -> ID add_id2 arr EQUALS . saveOperator exp generateAssignQuad
    (78) saveOperator -> .

    CTEI            reduce using rule 78 (saveOperator -> .)
    CTEF            reduce using rule 78 (saveOperator -> .)
    CTEC            reduce using rule 78 (saveOperator -> .)
    CTESTRING       reduce using rule 78 (saveOperator -> .)
    LPAREN          reduce using rule 78 (saveOperator -> .)
    ID              reduce using rule 78 (saveOperator -> .)
    OR              reduce using rule 78 (saveOperator -> .)
    AND             reduce using rule 78 (saveOperator -> .)
    GT              reduce using rule 78 (saveOperator -> .)
    LT              reduce using rule 78 (saveOperator -> .)
    GTE             reduce using rule 78 (saveOperator -> .)
    LTE             reduce using rule 78 (saveOperator -> .)
    NE              reduce using rule 78 (saveOperator -> .)
    PLUS            reduce using rule 78 (saveOperator -> .)
    MINUS           reduce using rule 78 (saveOperator -> .)
    MUL             reduce using rule 78 (saveOperator -> .)
    DIV             reduce using rule 78 (saveOperator -> .)
    SEMMICOLON      reduce using rule 78 (saveOperator -> .)
    TO              reduce using rule 78 (saveOperator -> .)

    saveOperator                   shift and go to state 197

state 172

    (22) functionCall -> ID LPAREN exp RPAREN .

    SEMMICOLON      reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    MUL             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    DIV             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    PLUS            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    MINUS           reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    GT              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    LT              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    GTE             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    LTE             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    NE              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    AND             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    OR              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    RPAREN          reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    COMMA           reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    TO              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTEI            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTEF            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTEC            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTESTRING       reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    LPAREN          reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    ID              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)


state 173

    (23) read -> READ operatorRead LPAREN var1 . generateQuadREAD RPAREN
    (50) generateQuadREAD -> .

    RPAREN          reduce using rule 50 (generateQuadREAD -> .)

    generateQuadREAD               shift and go to state 198

state 174

    (26) write -> WRITE LPAREN write1 RPAREN .

    ID              reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    READ            reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    WRITE           reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    FOR             reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    WHILE           reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    IF              reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    RETURN          reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    SEMMICOLON      reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)


state 175

    (27) write1 -> write2 COMMA . write2
    (29) write2 -> . COMILLA CTESTRING COMILLA
    (30) write2 -> . CTEI saveCTE generateQuadPRINT
    (31) write2 -> . CTEF saveCTE generateQuadPRINT
    (32) write2 -> . exp
    (54) exp -> . nexp generateQuadOR
    (55) exp -> . nexp generateQuadOR OR saveOperator nexp
    (56) nexp -> . compexp generateQuadAND
    (57) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    COMILLA         shift and go to state 144
    CTEI            shift and go to state 145
    CTEF            shift and go to state 146
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)

    write2                         shift and go to state 199
    exp                            shift and go to state 147
    nexp                           shift and go to state 79
    compexp                        shift and go to state 80
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 176

    (29) write2 -> COMILLA CTESTRING . COMILLA

    COMILLA         shift and go to state 200


state 177

    (30) write2 -> CTEI saveCTE . generateQuadPRINT
    (72) pexp -> CTEI saveCTE .
    (49) generateQuadPRINT -> .

  ! reduce/reduce conflict for COMMA resolved using rule 49 (generateQuadPRINT -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 49 (generateQuadPRINT -> .)
    MUL             reduce using rule 72 (pexp -> CTEI saveCTE .)
    DIV             reduce using rule 72 (pexp -> CTEI saveCTE .)
    PLUS            reduce using rule 72 (pexp -> CTEI saveCTE .)
    MINUS           reduce using rule 72 (pexp -> CTEI saveCTE .)
    GT              reduce using rule 72 (pexp -> CTEI saveCTE .)
    LT              reduce using rule 72 (pexp -> CTEI saveCTE .)
    GTE             reduce using rule 72 (pexp -> CTEI saveCTE .)
    LTE             reduce using rule 72 (pexp -> CTEI saveCTE .)
    NE              reduce using rule 72 (pexp -> CTEI saveCTE .)
    AND             reduce using rule 72 (pexp -> CTEI saveCTE .)
    OR              reduce using rule 72 (pexp -> CTEI saveCTE .)
    COMMA           reduce using rule 49 (generateQuadPRINT -> .)
    RPAREN          reduce using rule 49 (generateQuadPRINT -> .)

  ! COMMA           [ reduce using rule 72 (pexp -> CTEI saveCTE .) ]
  ! RPAREN          [ reduce using rule 72 (pexp -> CTEI saveCTE .) ]

    generateQuadPRINT              shift and go to state 201

state 178

    (31) write2 -> CTEF saveCTE . generateQuadPRINT
    (73) pexp -> CTEF saveCTE .
    (49) generateQuadPRINT -> .

  ! reduce/reduce conflict for COMMA resolved using rule 49 (generateQuadPRINT -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 49 (generateQuadPRINT -> .)
    MUL             reduce using rule 73 (pexp -> CTEF saveCTE .)
    DIV             reduce using rule 73 (pexp -> CTEF saveCTE .)
    PLUS            reduce using rule 73 (pexp -> CTEF saveCTE .)
    MINUS           reduce using rule 73 (pexp -> CTEF saveCTE .)
    GT              reduce using rule 73 (pexp -> CTEF saveCTE .)
    LT              reduce using rule 73 (pexp -> CTEF saveCTE .)
    GTE             reduce using rule 73 (pexp -> CTEF saveCTE .)
    LTE             reduce using rule 73 (pexp -> CTEF saveCTE .)
    NE              reduce using rule 73 (pexp -> CTEF saveCTE .)
    AND             reduce using rule 73 (pexp -> CTEF saveCTE .)
    OR              reduce using rule 73 (pexp -> CTEF saveCTE .)
    COMMA           reduce using rule 49 (generateQuadPRINT -> .)
    RPAREN          reduce using rule 49 (generateQuadPRINT -> .)

  ! COMMA           [ reduce using rule 73 (pexp -> CTEF saveCTE .) ]
  ! RPAREN          [ reduce using rule 73 (pexp -> CTEF saveCTE .) ]

    generateQuadPRINT              shift and go to state 202

state 179

    (33) for -> FOR forOP assign TO . CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    CTEI            shift and go to state 203


state 180

    (37) while -> WHILE whileOP LPAREN exp . RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    RPAREN          shift and go to state 204


state 181

    (40) if -> IF LPAREN exp RPAREN . generateQuadIF THEN LCURLY statements RCURLY else endIF
    (46) generateQuadIF -> .

    THEN            reduce using rule 46 (generateQuadIF -> .)

    generateQuadIF                 shift and go to state 205

state 182

    (109) return -> RETURN LPAREN exp RPAREN . SEMMICOLON
    (110) return -> RETURN LPAREN exp RPAREN .

  ! shift/reduce conflict for SEMMICOLON resolved as shift
    SEMMICOLON      shift and go to state 206
    ID              reduce using rule 110 (return -> RETURN LPAREN exp RPAREN .)
    READ            reduce using rule 110 (return -> RETURN LPAREN exp RPAREN .)
    WRITE           reduce using rule 110 (return -> RETURN LPAREN exp RPAREN .)
    FOR             reduce using rule 110 (return -> RETURN LPAREN exp RPAREN .)
    WHILE           reduce using rule 110 (return -> RETURN LPAREN exp RPAREN .)
    IF              reduce using rule 110 (return -> RETURN LPAREN exp RPAREN .)
    RETURN          reduce using rule 110 (return -> RETURN LPAREN exp RPAREN .)
    RCURLY          reduce using rule 110 (return -> RETURN LPAREN exp RPAREN .)

  ! SEMMICOLON      [ reduce using rule 110 (return -> RETURN LPAREN exp RPAREN .) ]


state 183

    (101) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)

    statements                     shift and go to state 207
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 184

    (104) args -> args type TWOPOINTS var1 . addVar
    (89) addVar -> .

    RPAREN          reduce using rule 89 (addVar -> .)
    INT             reduce using rule 89 (addVar -> .)
    CHAR            reduce using rule 89 (addVar -> .)
    FLOAT           reduce using rule 89 (addVar -> .)

    addVar                         shift and go to state 208

state 185

    (55) exp -> nexp generateQuadOR OR saveOperator . nexp
    (56) nexp -> . compexp generateQuadAND
    (57) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)

    nexp                           shift and go to state 209
    compexp                        shift and go to state 80
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 186

    (57) nexp -> compexp generateQuadAND AND saveOperator . compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    RBRACKET        reduce using rule 111 (empty -> .)
    RPAREN          reduce using rule 111 (empty -> .)
    COMMA           reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)

    compexp                        shift and go to state 210
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 187

    (60) compexp1 -> sumexp GT saveOperator sumexp . generateQuadCOMPARE
    (45) generateQuadCOMPARE -> .

    CTEI            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 45 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 45 (generateQuadCOMPARE -> .)
    ID              reduce using rule 45 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 45 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 45 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 45 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 45 (generateQuadCOMPARE -> .)
    AND             reduce using rule 45 (generateQuadCOMPARE -> .)
    OR              reduce using rule 45 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 45 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 45 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 45 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 45 (generateQuadCOMPARE -> .)
    TO              reduce using rule 45 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 211

state 188

    (61) compexp1 -> sumexp LT saveOperator sumexp . generateQuadCOMPARE
    (45) generateQuadCOMPARE -> .

    CTEI            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 45 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 45 (generateQuadCOMPARE -> .)
    ID              reduce using rule 45 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 45 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 45 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 45 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 45 (generateQuadCOMPARE -> .)
    AND             reduce using rule 45 (generateQuadCOMPARE -> .)
    OR              reduce using rule 45 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 45 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 45 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 45 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 45 (generateQuadCOMPARE -> .)
    TO              reduce using rule 45 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 212

state 189

    (62) compexp1 -> sumexp GTE saveOperator sumexp . generateQuadCOMPARE
    (45) generateQuadCOMPARE -> .

    CTEI            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 45 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 45 (generateQuadCOMPARE -> .)
    ID              reduce using rule 45 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 45 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 45 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 45 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 45 (generateQuadCOMPARE -> .)
    AND             reduce using rule 45 (generateQuadCOMPARE -> .)
    OR              reduce using rule 45 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 45 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 45 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 45 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 45 (generateQuadCOMPARE -> .)
    TO              reduce using rule 45 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 213

state 190

    (63) compexp1 -> sumexp LTE saveOperator sumexp . generateQuadCOMPARE
    (45) generateQuadCOMPARE -> .

    CTEI            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 45 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 45 (generateQuadCOMPARE -> .)
    ID              reduce using rule 45 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 45 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 45 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 45 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 45 (generateQuadCOMPARE -> .)
    AND             reduce using rule 45 (generateQuadCOMPARE -> .)
    OR              reduce using rule 45 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 45 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 45 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 45 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 45 (generateQuadCOMPARE -> .)
    TO              reduce using rule 45 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 214

state 191

    (64) compexp1 -> sumexp NE saveOperator sumexp . generateQuadCOMPARE
    (45) generateQuadCOMPARE -> .

    CTEI            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 45 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 45 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 45 (generateQuadCOMPARE -> .)
    ID              reduce using rule 45 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 45 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 45 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 45 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 45 (generateQuadCOMPARE -> .)
    AND             reduce using rule 45 (generateQuadCOMPARE -> .)
    OR              reduce using rule 45 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 45 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 45 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 45 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 45 (generateQuadCOMPARE -> .)
    TO              reduce using rule 45 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 215

state 192

    (66) sumexp -> mulexp PLUS saveOperator mulexp . generateQuadSUM
    (47) generateQuadSUM -> .

    GT              reduce using rule 47 (generateQuadSUM -> .)
    LT              reduce using rule 47 (generateQuadSUM -> .)
    GTE             reduce using rule 47 (generateQuadSUM -> .)
    LTE             reduce using rule 47 (generateQuadSUM -> .)
    NE              reduce using rule 47 (generateQuadSUM -> .)
    AND             reduce using rule 47 (generateQuadSUM -> .)
    OR              reduce using rule 47 (generateQuadSUM -> .)
    RBRACKET        reduce using rule 47 (generateQuadSUM -> .)
    RPAREN          reduce using rule 47 (generateQuadSUM -> .)
    COMMA           reduce using rule 47 (generateQuadSUM -> .)
    SEMMICOLON      reduce using rule 47 (generateQuadSUM -> .)
    TO              reduce using rule 47 (generateQuadSUM -> .)
    CTEI            reduce using rule 47 (generateQuadSUM -> .)
    CTEF            reduce using rule 47 (generateQuadSUM -> .)
    CTEC            reduce using rule 47 (generateQuadSUM -> .)
    CTESTRING       reduce using rule 47 (generateQuadSUM -> .)
    LPAREN          reduce using rule 47 (generateQuadSUM -> .)
    ID              reduce using rule 47 (generateQuadSUM -> .)
    PLUS            reduce using rule 47 (generateQuadSUM -> .)
    MINUS           reduce using rule 47 (generateQuadSUM -> .)
    MUL             reduce using rule 47 (generateQuadSUM -> .)
    DIV             reduce using rule 47 (generateQuadSUM -> .)

    generateQuadSUM                shift and go to state 216

state 193

    (67) sumexp -> mulexp MINUS saveOperator mulexp . generateQuadSUM
    (47) generateQuadSUM -> .

    GT              reduce using rule 47 (generateQuadSUM -> .)
    LT              reduce using rule 47 (generateQuadSUM -> .)
    GTE             reduce using rule 47 (generateQuadSUM -> .)
    LTE             reduce using rule 47 (generateQuadSUM -> .)
    NE              reduce using rule 47 (generateQuadSUM -> .)
    AND             reduce using rule 47 (generateQuadSUM -> .)
    OR              reduce using rule 47 (generateQuadSUM -> .)
    RBRACKET        reduce using rule 47 (generateQuadSUM -> .)
    RPAREN          reduce using rule 47 (generateQuadSUM -> .)
    COMMA           reduce using rule 47 (generateQuadSUM -> .)
    SEMMICOLON      reduce using rule 47 (generateQuadSUM -> .)
    TO              reduce using rule 47 (generateQuadSUM -> .)
    CTEI            reduce using rule 47 (generateQuadSUM -> .)
    CTEF            reduce using rule 47 (generateQuadSUM -> .)
    CTEC            reduce using rule 47 (generateQuadSUM -> .)
    CTESTRING       reduce using rule 47 (generateQuadSUM -> .)
    LPAREN          reduce using rule 47 (generateQuadSUM -> .)
    ID              reduce using rule 47 (generateQuadSUM -> .)
    PLUS            reduce using rule 47 (generateQuadSUM -> .)
    MINUS           reduce using rule 47 (generateQuadSUM -> .)
    MUL             reduce using rule 47 (generateQuadSUM -> .)
    DIV             reduce using rule 47 (generateQuadSUM -> .)

    generateQuadSUM                shift and go to state 217

state 194

    (69) mulexp -> pexp MUL saveOperator pexp . generateQuadMUL
    (48) generateQuadMUL -> .

    PLUS            reduce using rule 48 (generateQuadMUL -> .)
    MINUS           reduce using rule 48 (generateQuadMUL -> .)
    GT              reduce using rule 48 (generateQuadMUL -> .)
    LT              reduce using rule 48 (generateQuadMUL -> .)
    GTE             reduce using rule 48 (generateQuadMUL -> .)
    LTE             reduce using rule 48 (generateQuadMUL -> .)
    NE              reduce using rule 48 (generateQuadMUL -> .)
    AND             reduce using rule 48 (generateQuadMUL -> .)
    OR              reduce using rule 48 (generateQuadMUL -> .)
    RBRACKET        reduce using rule 48 (generateQuadMUL -> .)
    RPAREN          reduce using rule 48 (generateQuadMUL -> .)
    COMMA           reduce using rule 48 (generateQuadMUL -> .)
    SEMMICOLON      reduce using rule 48 (generateQuadMUL -> .)
    TO              reduce using rule 48 (generateQuadMUL -> .)
    CTEI            reduce using rule 48 (generateQuadMUL -> .)
    CTEF            reduce using rule 48 (generateQuadMUL -> .)
    CTEC            reduce using rule 48 (generateQuadMUL -> .)
    CTESTRING       reduce using rule 48 (generateQuadMUL -> .)
    LPAREN          reduce using rule 48 (generateQuadMUL -> .)
    ID              reduce using rule 48 (generateQuadMUL -> .)
    MUL             reduce using rule 48 (generateQuadMUL -> .)
    DIV             reduce using rule 48 (generateQuadMUL -> .)

    generateQuadMUL                shift and go to state 218

state 195

    (70) mulexp -> pexp DIV saveOperator pexp . generateQuadMUL
    (48) generateQuadMUL -> .

    PLUS            reduce using rule 48 (generateQuadMUL -> .)
    MINUS           reduce using rule 48 (generateQuadMUL -> .)
    GT              reduce using rule 48 (generateQuadMUL -> .)
    LT              reduce using rule 48 (generateQuadMUL -> .)
    GTE             reduce using rule 48 (generateQuadMUL -> .)
    LTE             reduce using rule 48 (generateQuadMUL -> .)
    NE              reduce using rule 48 (generateQuadMUL -> .)
    AND             reduce using rule 48 (generateQuadMUL -> .)
    OR              reduce using rule 48 (generateQuadMUL -> .)
    RBRACKET        reduce using rule 48 (generateQuadMUL -> .)
    RPAREN          reduce using rule 48 (generateQuadMUL -> .)
    COMMA           reduce using rule 48 (generateQuadMUL -> .)
    SEMMICOLON      reduce using rule 48 (generateQuadMUL -> .)
    TO              reduce using rule 48 (generateQuadMUL -> .)
    CTEI            reduce using rule 48 (generateQuadMUL -> .)
    CTEF            reduce using rule 48 (generateQuadMUL -> .)
    CTEC            reduce using rule 48 (generateQuadMUL -> .)
    CTESTRING       reduce using rule 48 (generateQuadMUL -> .)
    LPAREN          reduce using rule 48 (generateQuadMUL -> .)
    ID              reduce using rule 48 (generateQuadMUL -> .)
    MUL             reduce using rule 48 (generateQuadMUL -> .)
    DIV             reduce using rule 48 (generateQuadMUL -> .)

    generateQuadMUL                shift and go to state 219

state 196

    (17) assign -> ID add_id2 EQUALS saveOperator exp . generateAssignQuad
    (19) generateAssignQuad -> .

    SEMMICOLON      reduce using rule 19 (generateAssignQuad -> .)
    TO              reduce using rule 19 (generateAssignQuad -> .)

    generateAssignQuad             shift and go to state 220

state 197

    (18) assign -> ID add_id2 arr EQUALS saveOperator . exp generateAssignQuad
    (54) exp -> . nexp generateQuadOR
    (55) exp -> . nexp generateQuadOR OR saveOperator nexp
    (56) nexp -> . compexp generateQuadAND
    (57) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (58) compexp -> . sumexp
    (59) compexp -> . compexp1 sumexp
    (65) sumexp -> . mulexp
    (66) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (67) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (60) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (61) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (68) mulexp -> . pexp
    (69) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (70) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (71) pexp -> . var1 add_id
    (72) pexp -> . CTEI saveCTE
    (73) pexp -> . CTEF saveCTE
    (74) pexp -> . CTEC saveCTE
    (75) pexp -> . CTESTRING saveCTE
    (76) pexp -> . functionCall
    (77) pexp -> . LPAREN exp RPAREN
    (84) var1 -> . ID
    (85) var1 -> . ID COMMA var1 addVar
    (86) var1 -> . ID arr
    (87) var1 -> . ID arr COMMA var1 addVar
    (88) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (111) empty -> .

    CTEI            shift and go to state 124
    CTEF            shift and go to state 86
    CTEC            shift and go to state 87
    CTESTRING       shift and go to state 88
    LPAREN          shift and go to state 90
    ID              shift and go to state 91
    MUL             reduce using rule 111 (empty -> .)
    DIV             reduce using rule 111 (empty -> .)
    PLUS            reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    GT              reduce using rule 111 (empty -> .)
    LT              reduce using rule 111 (empty -> .)
    GTE             reduce using rule 111 (empty -> .)
    LTE             reduce using rule 111 (empty -> .)
    NE              reduce using rule 111 (empty -> .)
    AND             reduce using rule 111 (empty -> .)
    OR              reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)
    TO              reduce using rule 111 (empty -> .)

    exp                            shift and go to state 221
    nexp                           shift and go to state 79
    compexp                        shift and go to state 80
    sumexp                         shift and go to state 81
    compexp1                       shift and go to state 82
    mulexp                         shift and go to state 83
    pexp                           shift and go to state 84
    var1                           shift and go to state 85
    functionCall                   shift and go to state 89
    empty                          shift and go to state 48

state 198

    (23) read -> READ operatorRead LPAREN var1 generateQuadREAD . RPAREN

    RPAREN          shift and go to state 222


state 199

    (27) write1 -> write2 COMMA write2 .

    RPAREN          reduce using rule 27 (write1 -> write2 COMMA write2 .)


state 200

    (29) write2 -> COMILLA CTESTRING COMILLA .

    COMMA           reduce using rule 29 (write2 -> COMILLA CTESTRING COMILLA .)
    RPAREN          reduce using rule 29 (write2 -> COMILLA CTESTRING COMILLA .)


state 201

    (30) write2 -> CTEI saveCTE generateQuadPRINT .

    COMMA           reduce using rule 30 (write2 -> CTEI saveCTE generateQuadPRINT .)
    RPAREN          reduce using rule 30 (write2 -> CTEI saveCTE generateQuadPRINT .)


state 202

    (31) write2 -> CTEF saveCTE generateQuadPRINT .

    COMMA           reduce using rule 31 (write2 -> CTEF saveCTE generateQuadPRINT .)
    RPAREN          reduce using rule 31 (write2 -> CTEF saveCTE generateQuadPRINT .)


state 203

    (33) for -> FOR forOP assign TO CTEI . DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    DO              shift and go to state 223


state 204

    (37) while -> WHILE whileOP LPAREN exp RPAREN . DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    DO              shift and go to state 224


state 205

    (40) if -> IF LPAREN exp RPAREN generateQuadIF . THEN LCURLY statements RCURLY else endIF

    THEN            shift and go to state 225


state 206

    (109) return -> RETURN LPAREN exp RPAREN SEMMICOLON .

    ID              reduce using rule 109 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    READ            reduce using rule 109 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WRITE           reduce using rule 109 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    FOR             reduce using rule 109 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WHILE           reduce using rule 109 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    IF              reduce using rule 109 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RETURN          reduce using rule 109 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RCURLY          reduce using rule 109 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    SEMMICOLON      reduce using rule 109 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)


state 207

    (101) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements . RCURLY

    RCURLY          shift and go to state 226


state 208

    (104) args -> args type TWOPOINTS var1 addVar .

    RPAREN          reduce using rule 104 (args -> args type TWOPOINTS var1 addVar .)
    INT             reduce using rule 104 (args -> args type TWOPOINTS var1 addVar .)
    CHAR            reduce using rule 104 (args -> args type TWOPOINTS var1 addVar .)
    FLOAT           reduce using rule 104 (args -> args type TWOPOINTS var1 addVar .)


state 209

    (55) exp -> nexp generateQuadOR OR saveOperator nexp .

    RBRACKET        reduce using rule 55 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    RPAREN          reduce using rule 55 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    COMMA           reduce using rule 55 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    SEMMICOLON      reduce using rule 55 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    TO              reduce using rule 55 (exp -> nexp generateQuadOR OR saveOperator nexp .)


state 210

    (57) nexp -> compexp generateQuadAND AND saveOperator compexp .

    OR              reduce using rule 57 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    RBRACKET        reduce using rule 57 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    RPAREN          reduce using rule 57 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    COMMA           reduce using rule 57 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    SEMMICOLON      reduce using rule 57 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    TO              reduce using rule 57 (nexp -> compexp generateQuadAND AND saveOperator compexp .)


state 211

    (60) compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 60 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)


state 212

    (61) compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 61 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)


state 213

    (62) compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 62 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)


state 214

    (63) compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 63 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)


state 215

    (64) compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 64 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)


state 216

    (66) sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .

    GT              reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LT              reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    GTE             reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LTE             reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    NE              reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    AND             reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    OR              reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    RBRACKET        reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    RPAREN          reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    COMMA           reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    SEMMICOLON      reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    TO              reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEI            reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEF            reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEC            reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTESTRING       reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LPAREN          reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    ID              reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    PLUS            reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    MINUS           reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    MUL             reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    DIV             reduce using rule 66 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)


state 217

    (67) sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .

    GT              reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LT              reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    GTE             reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LTE             reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    NE              reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    AND             reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    OR              reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    RBRACKET        reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    RPAREN          reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    COMMA           reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    SEMMICOLON      reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    TO              reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEI            reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEF            reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEC            reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTESTRING       reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LPAREN          reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    ID              reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    PLUS            reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    MINUS           reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    MUL             reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    DIV             reduce using rule 67 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)


state 218

    (69) mulexp -> pexp MUL saveOperator pexp generateQuadMUL .

    PLUS            reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    MINUS           reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    GT              reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LT              reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    GTE             reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LTE             reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    NE              reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    AND             reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    OR              reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    RBRACKET        reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    RPAREN          reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    COMMA           reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    SEMMICOLON      reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    TO              reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEI            reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEF            reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEC            reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTESTRING       reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LPAREN          reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    ID              reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    MUL             reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    DIV             reduce using rule 69 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)


state 219

    (70) mulexp -> pexp DIV saveOperator pexp generateQuadMUL .

    PLUS            reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    MINUS           reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    GT              reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LT              reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    GTE             reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LTE             reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    NE              reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    AND             reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    OR              reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    RBRACKET        reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    RPAREN          reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    COMMA           reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    SEMMICOLON      reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    TO              reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEI            reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEF            reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEC            reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTESTRING       reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LPAREN          reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    ID              reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    MUL             reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    DIV             reduce using rule 70 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)


state 220

    (17) assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .

    SEMMICOLON      reduce using rule 17 (assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .)
    TO              reduce using rule 17 (assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .)


state 221

    (18) assign -> ID add_id2 arr EQUALS saveOperator exp . generateAssignQuad
    (19) generateAssignQuad -> .

    SEMMICOLON      reduce using rule 19 (generateAssignQuad -> .)
    TO              reduce using rule 19 (generateAssignQuad -> .)

    generateAssignQuad             shift and go to state 227

state 222

    (23) read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .

    ID              reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    READ            reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    WRITE           reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    FOR             reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    WHILE           reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    IF              reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    RETURN          reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    SEMMICOLON      reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)


state 223

    (33) for -> FOR forOP assign TO CTEI DO . generateQuadFOR LCURLY statements RCURLY LoopEnd
    (35) generateQuadFOR -> .

    LCURLY          reduce using rule 35 (generateQuadFOR -> .)

    generateQuadFOR                shift and go to state 228

state 224

    (37) while -> WHILE whileOP LPAREN exp RPAREN DO . generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (39) generateQuadWHILE -> .

    LCURLY          reduce using rule 39 (generateQuadWHILE -> .)

    generateQuadWHILE              shift and go to state 229

state 225

    (40) if -> IF LPAREN exp RPAREN generateQuadIF THEN . LCURLY statements RCURLY else endIF

    LCURLY          shift and go to state 230


state 226

    (101) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .

    FUNCTION        reduce using rule 101 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .)
    PRINCIPAL       reduce using rule 101 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .)
    $end            reduce using rule 101 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .)


state 227

    (18) assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .

    SEMMICOLON      reduce using rule 18 (assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .)
    TO              reduce using rule 18 (assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .)


state 228

    (33) for -> FOR forOP assign TO CTEI DO generateQuadFOR . LCURLY statements RCURLY LoopEnd

    LCURLY          shift and go to state 231


state 229

    (37) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE . LCURLY statements RCURLY LoopEnd

    LCURLY          shift and go to state 232


state 230

    (40) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY . statements RCURLY else endIF
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)

    statements                     shift and go to state 233
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 231

    (33) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY . statements RCURLY LoopEnd
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)

    assign                         shift and go to state 56
    statements                     shift and go to state 234
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 232

    (37) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY . statements RCURLY LoopEnd
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)

    statements                     shift and go to state 235
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 233

    (40) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements . RCURLY else endIF

    RCURLY          shift and go to state 236


state 234

    (33) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements . RCURLY LoopEnd

    RCURLY          shift and go to state 237


state 235

    (37) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements . RCURLY LoopEnd

    RCURLY          shift and go to state 238


state 236

    (40) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY . else endIF
    (41) else -> . ELSE generateQuadELSE LCURLY statements RCURLY
    (42) else -> . empty
    (111) empty -> .

    ELSE            shift and go to state 240
    ID              reduce using rule 111 (empty -> .)
    READ            reduce using rule 111 (empty -> .)
    WRITE           reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)
    RCURLY          reduce using rule 111 (empty -> .)
    SEMMICOLON      reduce using rule 111 (empty -> .)

    else                           shift and go to state 239
    empty                          shift and go to state 241

state 237

    (33) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY . LoopEnd
    (36) LoopEnd -> .

    ID              reduce using rule 36 (LoopEnd -> .)
    READ            reduce using rule 36 (LoopEnd -> .)
    WRITE           reduce using rule 36 (LoopEnd -> .)
    FOR             reduce using rule 36 (LoopEnd -> .)
    WHILE           reduce using rule 36 (LoopEnd -> .)
    IF              reduce using rule 36 (LoopEnd -> .)
    RETURN          reduce using rule 36 (LoopEnd -> .)
    RCURLY          reduce using rule 36 (LoopEnd -> .)
    SEMMICOLON      reduce using rule 36 (LoopEnd -> .)

    LoopEnd                        shift and go to state 242

state 238

    (37) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY . LoopEnd
    (36) LoopEnd -> .

    ID              reduce using rule 36 (LoopEnd -> .)
    READ            reduce using rule 36 (LoopEnd -> .)
    WRITE           reduce using rule 36 (LoopEnd -> .)
    FOR             reduce using rule 36 (LoopEnd -> .)
    WHILE           reduce using rule 36 (LoopEnd -> .)
    IF              reduce using rule 36 (LoopEnd -> .)
    RETURN          reduce using rule 36 (LoopEnd -> .)
    RCURLY          reduce using rule 36 (LoopEnd -> .)
    SEMMICOLON      reduce using rule 36 (LoopEnd -> .)

    LoopEnd                        shift and go to state 243

state 239

    (40) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else . endIF
    (51) endIF -> .

    ID              reduce using rule 51 (endIF -> .)
    READ            reduce using rule 51 (endIF -> .)
    WRITE           reduce using rule 51 (endIF -> .)
    FOR             reduce using rule 51 (endIF -> .)
    WHILE           reduce using rule 51 (endIF -> .)
    IF              reduce using rule 51 (endIF -> .)
    RETURN          reduce using rule 51 (endIF -> .)
    RCURLY          reduce using rule 51 (endIF -> .)
    SEMMICOLON      reduce using rule 51 (endIF -> .)

    endIF                          shift and go to state 244

state 240

    (41) else -> ELSE . generateQuadELSE LCURLY statements RCURLY
    (52) generateQuadELSE -> .

    LCURLY          reduce using rule 52 (generateQuadELSE -> .)

    generateQuadELSE               shift and go to state 245

state 241

    (42) else -> empty .

    ID              reduce using rule 42 (else -> empty .)
    READ            reduce using rule 42 (else -> empty .)
    WRITE           reduce using rule 42 (else -> empty .)
    FOR             reduce using rule 42 (else -> empty .)
    WHILE           reduce using rule 42 (else -> empty .)
    IF              reduce using rule 42 (else -> empty .)
    RETURN          reduce using rule 42 (else -> empty .)
    RCURLY          reduce using rule 42 (else -> empty .)
    SEMMICOLON      reduce using rule 42 (else -> empty .)


state 242

    (33) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .

    ID              reduce using rule 33 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    READ            reduce using rule 33 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    WRITE           reduce using rule 33 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    FOR             reduce using rule 33 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    WHILE           reduce using rule 33 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    IF              reduce using rule 33 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    RETURN          reduce using rule 33 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    RCURLY          reduce using rule 33 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    SEMMICOLON      reduce using rule 33 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)


state 243

    (37) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .

    ID              reduce using rule 37 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    READ            reduce using rule 37 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    WRITE           reduce using rule 37 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    FOR             reduce using rule 37 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    WHILE           reduce using rule 37 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    IF              reduce using rule 37 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    RETURN          reduce using rule 37 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    RCURLY          reduce using rule 37 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    SEMMICOLON      reduce using rule 37 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)


state 244

    (40) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .

    ID              reduce using rule 40 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    READ            reduce using rule 40 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    WRITE           reduce using rule 40 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    FOR             reduce using rule 40 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    WHILE           reduce using rule 40 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    IF              reduce using rule 40 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    RETURN          reduce using rule 40 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    RCURLY          reduce using rule 40 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    SEMMICOLON      reduce using rule 40 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)


state 245

    (41) else -> ELSE generateQuadELSE . LCURLY statements RCURLY

    LCURLY          shift and go to state 246


state 246

    (41) else -> ELSE generateQuadELSE LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (37) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (109) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (110) return -> . RETURN LPAREN exp RPAREN
    (111) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 111 (empty -> .)

    statements                     shift and go to state 247
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 247

    (41) else -> ELSE generateQuadELSE LCURLY statements . RCURLY

    RCURLY          shift and go to state 248


state 248

    (41) else -> ELSE generateQuadELSE LCURLY statements RCURLY .

    ID              reduce using rule 41 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    READ            reduce using rule 41 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    WRITE           reduce using rule 41 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    FOR             reduce using rule 41 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    WHILE           reduce using rule 41 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    IF              reduce using rule 41 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    RETURN          reduce using rule 41 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    RCURLY          reduce using rule 41 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 41 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PRINCIPAL in state 5 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 47 resolved as shift
WARNING: shift/reduce conflict for ID in state 52 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 53 resolved as shift
WARNING: shift/reduce conflict for ID in state 76 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 77 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MUL in state 84 resolved as shift
WARNING: shift/reduce conflict for DIV in state 84 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 91 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 91 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 158 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 158 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 158 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 158 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 158 resolved as shift
WARNING: shift/reduce conflict for ID in state 158 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 159 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 159 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 159 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 159 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 159 resolved as shift
WARNING: shift/reduce conflict for ID in state 159 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 160 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 160 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 160 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 160 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 160 resolved as shift
WARNING: shift/reduce conflict for ID in state 160 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 161 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 161 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 161 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 161 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 161 resolved as shift
WARNING: shift/reduce conflict for ID in state 161 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 162 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 162 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 162 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 162 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 162 resolved as shift
WARNING: shift/reduce conflict for ID in state 162 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 163 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 163 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 163 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 163 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 163 resolved as shift
WARNING: shift/reduce conflict for ID in state 163 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 164 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 164 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 164 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 164 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 164 resolved as shift
WARNING: shift/reduce conflict for ID in state 164 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 165 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 165 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 165 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 165 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 165 resolved as shift
WARNING: shift/reduce conflict for ID in state 165 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 166 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 166 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 166 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 166 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 166 resolved as shift
WARNING: shift/reduce conflict for ID in state 166 resolved as shift
WARNING: shift/reduce conflict for SEMMICOLON in state 182 resolved as shift
WARNING: reduce/reduce conflict in state 177 resolved using rule (generateQuadPRINT -> <empty>)
WARNING: rejected rule (pexp -> CTEI saveCTE) in state 177
WARNING: reduce/reduce conflict in state 178 resolved using rule (generateQuadPRINT -> <empty>)
WARNING: rejected rule (pexp -> CTEF saveCTE) in state 178
