Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CTEC
    END
    FROM
    MODA
    PLOTXY
    SIMPLEREGRESSION
    VARIANZA

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMMICOLON program1
Rule 2     program1 -> vars functions principal
Rule 3     program1 -> vars functions
Rule 4     program1 -> program2
Rule 5     program2 -> principal
Rule 6     principal -> PRINCIPAL LPAREN RPAREN LCURLY statements RCURLY
Rule 7     statements -> assign SEMMICOLON statements
Rule 8     statements -> functionCall SEMMICOLON statements
Rule 9     statements -> read statements SEMMICOLON statements
Rule 10    statements -> write statements SEMMICOLON statements
Rule 11    statements -> for statements
Rule 12    statements -> while statements
Rule 13    statements -> if statements
Rule 14    statements -> return statements
Rule 15    statements -> empty
Rule 16    assign -> ID EQUALS exp
Rule 17    assign -> ID LBRACKET exp RBRACKET EQUALS exp
Rule 18    functionCall -> ID LPAREN exp RPAREN
Rule 19    read -> READ LPAREN read1 RPAREN
Rule 20    read1 -> ID read2
Rule 21    read2 -> COMMA read1
Rule 22    read2 -> empty
Rule 23    media -> MEDIA LPAREN arr RPAREN SEMMICOLON
Rule 24    write -> WRITE LPAREN write1 RPAREN
Rule 25    write1 -> write2 COMMA write2
Rule 26    write1 -> write2
Rule 27    write2 -> CTESTRING
Rule 28    write2 -> CTEI
Rule 29    write2 -> CTEF
Rule 30    write2 -> exp
Rule 31    for -> FOR assign TO CTEI DO LCURLY statements RCURLY
Rule 32    while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
Rule 33    if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
Rule 34    else -> ELSE LCURLY statements RCURLY
Rule 35    else -> empty
Rule 36    exp -> nexp
Rule 37    exp -> nexp OR nexp
Rule 38    nexp -> compexp
Rule 39    nexp -> compexp AND compexp
Rule 40    compexp -> sumexp
Rule 41    compexp -> compexp1 sumexp
Rule 42    compexp1 -> sumexp GT sumexp
Rule 43    compexp1 -> sumexp LT sumexp
Rule 44    compexp1 -> sumexp GTE sumexp
Rule 45    compexp1 -> sumexp LTE sumexp
Rule 46    compexp1 -> sumexp NE sumexp
Rule 47    sumexp -> mulexp
Rule 48    sumexp -> mulexp PLUS mulexp
Rule 49    sumexp -> mulexp MINUS mulexp
Rule 50    mulexp -> pexp
Rule 51    mulexp -> pexp MUL pexp
Rule 52    mulexp -> pexp DIV pexp
Rule 53    pexp -> var1
Rule 54    pexp -> CTEI
Rule 55    pexp -> CTEF
Rule 56    pexp -> functionCall
Rule 57    pexp -> LPAREN exp RPAREN
Rule 58    vars -> var
Rule 59    vars -> empty
Rule 60    var -> VARS var2
Rule 61    var2 -> var2 type TWOPOINTS var1 SEMMICOLON
Rule 62    var2 -> empty
Rule 63    var1 -> ID
Rule 64    var1 -> ID COMMA var1
Rule 65    var1 -> ID arr
Rule 66    var1 -> ID arr COMMA var1
Rule 67    var1 -> empty
Rule 68    type -> INT
Rule 69    type -> CHAR
Rule 70    type -> FLOAT
Rule 71    arr -> LBRACKET CTEI RBRACKET
Rule 72    arr -> LBRACKET exp RBRACKET
Rule 73    functions -> FUNCTION VOID functionVoid functions
Rule 74    functions -> FUNCTION type functionType functions
Rule 75    functions -> empty
Rule 76    functionVoid -> ID LPAREN args RPAREN vars LCURLY statements RCURLY
Rule 77    functionType -> ID LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY
Rule 78    args -> type TWOPOINTS ID MultipleArgs
Rule 79    args -> empty
Rule 80    MultipleArgs -> COMMA args
Rule 81    MultipleArgs -> empty
Rule 82    return -> RETURN LPAREN exp RPAREN SEMMICOLON
Rule 83    return -> RETURN LPAREN exp RPAREN
Rule 84    empty -> <empty>

Terminals, with rules where they appear

AND                  : 39
CHAR                 : 69
COMMA                : 21 25 64 66 80
CTEC                 : 
CTEF                 : 29 55
CTEI                 : 28 31 54 71
CTESTRING            : 27
DIV                  : 52
DO                   : 31 32
ELSE                 : 34
END                  : 
EQUALS               : 16 17
FLOAT                : 70
FOR                  : 31
FROM                 : 
FUNCTION             : 73 74
GT                   : 42
GTE                  : 44
ID                   : 1 16 17 18 20 63 64 65 66 76 77 78
IF                   : 33
INT                  : 68
LBRACKET             : 17 71 72
LCURLY               : 6 31 32 33 34 76 77
LPAREN               : 6 18 19 23 24 32 33 57 76 77 82 83
LT                   : 43
LTE                  : 45
MEDIA                : 23
MINUS                : 49
MODA                 : 
MUL                  : 51
NE                   : 46
OR                   : 37
PLOTXY               : 
PLUS                 : 48
PRINCIPAL            : 6
PROGRAM              : 1
RBRACKET             : 17 71 72
RCURLY               : 6 31 32 33 34 76 77
READ                 : 19
RETURN               : 82 83
RPAREN               : 6 18 19 23 24 32 33 57 76 77 82 83
SEMMICOLON           : 1 7 8 9 10 23 61 77 82
SIMPLEREGRESSION     : 
THEN                 : 33
TO                   : 31
TWOPOINTS            : 61 78
VARIANZA             : 
VARS                 : 60
VOID                 : 73
WHILE                : 32
WRITE                : 24
error                : 

Nonterminals, with rules where they appear

MultipleArgs         : 78
args                 : 76 77 80
arr                  : 23 65 66
assign               : 7 31
compexp              : 38 39 39
compexp1             : 41
else                 : 33
empty                : 15 22 35 59 62 67 75 79 81
exp                  : 16 17 17 18 30 32 33 57 72 82 83
for                  : 11
functionCall         : 8 56
functionType         : 74
functionVoid         : 73
functions            : 2 3 73 74
if                   : 13
media                : 
mulexp               : 47 48 48 49 49
nexp                 : 36 37 37
pexp                 : 50 51 51 52 52
principal            : 2 5
program              : 0
program1             : 1
program2             : 4
read                 : 9
read1                : 19 21
read2                : 20
return               : 14 77
statements           : 6 7 8 9 9 10 10 11 12 13 14 31 32 33 34 76 77
sumexp               : 40 41 42 42 43 43 44 44 45 45 46 46
type                 : 61 74 78
var                  : 58
var1                 : 53 61 64 66
var2                 : 60 61
vars                 : 2 3 76 77
while                : 12
write                : 10
write1               : 24
write2               : 25 25 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMMICOLON program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMMICOLON program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMMICOLON program1

    SEMMICOLON      shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMMICOLON . program1
    (2) program1 -> . vars functions principal
    (3) program1 -> . vars functions
    (4) program1 -> . program2
    (58) vars -> . var
    (59) vars -> . empty
    (5) program2 -> . principal
    (60) var -> . VARS var2
    (84) empty -> .
    (6) principal -> . PRINCIPAL LPAREN RPAREN LCURLY statements RCURLY

  ! shift/reduce conflict for PRINCIPAL resolved as shift
    VARS            shift and go to state 11
    FUNCTION        reduce using rule 84 (empty -> .)
    $end            reduce using rule 84 (empty -> .)
    PRINCIPAL       shift and go to state 12

  ! PRINCIPAL       [ reduce using rule 84 (empty -> .) ]

    program1                       shift and go to state 5
    vars                           shift and go to state 6
    principal                      shift and go to state 7
    program2                       shift and go to state 8
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 5

    (1) program -> PROGRAM ID SEMMICOLON program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMMICOLON program1 .)


state 6

    (2) program1 -> vars . functions principal
    (3) program1 -> vars . functions
    (73) functions -> . FUNCTION VOID functionVoid functions
    (74) functions -> . FUNCTION type functionType functions
    (75) functions -> . empty
    (84) empty -> .

    FUNCTION        shift and go to state 14
    PRINCIPAL       reduce using rule 84 (empty -> .)
    $end            reduce using rule 84 (empty -> .)

    functions                      shift and go to state 13
    empty                          shift and go to state 15

state 7

    (5) program2 -> principal .

    $end            reduce using rule 5 (program2 -> principal .)


state 8

    (4) program1 -> program2 .

    $end            reduce using rule 4 (program1 -> program2 .)


state 9

    (58) vars -> var .

    FUNCTION        reduce using rule 58 (vars -> var .)
    PRINCIPAL       reduce using rule 58 (vars -> var .)
    $end            reduce using rule 58 (vars -> var .)
    LCURLY          reduce using rule 58 (vars -> var .)


state 10

    (59) vars -> empty .

    FUNCTION        reduce using rule 59 (vars -> empty .)
    PRINCIPAL       reduce using rule 59 (vars -> empty .)
    $end            reduce using rule 59 (vars -> empty .)
    LCURLY          reduce using rule 59 (vars -> empty .)


state 11

    (60) var -> VARS . var2
    (61) var2 -> . var2 type TWOPOINTS var1 SEMMICOLON
    (62) var2 -> . empty
    (84) empty -> .

    INT             reduce using rule 84 (empty -> .)
    CHAR            reduce using rule 84 (empty -> .)
    FLOAT           reduce using rule 84 (empty -> .)
    FUNCTION        reduce using rule 84 (empty -> .)
    PRINCIPAL       reduce using rule 84 (empty -> .)
    $end            reduce using rule 84 (empty -> .)
    LCURLY          reduce using rule 84 (empty -> .)

    var2                           shift and go to state 16
    empty                          shift and go to state 17

state 12

    (6) principal -> PRINCIPAL . LPAREN RPAREN LCURLY statements RCURLY

    LPAREN          shift and go to state 18


state 13

    (2) program1 -> vars functions . principal
    (3) program1 -> vars functions .
    (6) principal -> . PRINCIPAL LPAREN RPAREN LCURLY statements RCURLY

    $end            reduce using rule 3 (program1 -> vars functions .)
    PRINCIPAL       shift and go to state 12

    principal                      shift and go to state 19

state 14

    (73) functions -> FUNCTION . VOID functionVoid functions
    (74) functions -> FUNCTION . type functionType functions
    (68) type -> . INT
    (69) type -> . CHAR
    (70) type -> . FLOAT

    VOID            shift and go to state 20
    INT             shift and go to state 22
    CHAR            shift and go to state 23
    FLOAT           shift and go to state 24

    type                           shift and go to state 21

state 15

    (75) functions -> empty .

    PRINCIPAL       reduce using rule 75 (functions -> empty .)
    $end            reduce using rule 75 (functions -> empty .)


state 16

    (60) var -> VARS var2 .
    (61) var2 -> var2 . type TWOPOINTS var1 SEMMICOLON
    (68) type -> . INT
    (69) type -> . CHAR
    (70) type -> . FLOAT

    FUNCTION        reduce using rule 60 (var -> VARS var2 .)
    PRINCIPAL       reduce using rule 60 (var -> VARS var2 .)
    $end            reduce using rule 60 (var -> VARS var2 .)
    LCURLY          reduce using rule 60 (var -> VARS var2 .)
    INT             shift and go to state 22
    CHAR            shift and go to state 23
    FLOAT           shift and go to state 24

    type                           shift and go to state 25

state 17

    (62) var2 -> empty .

    INT             reduce using rule 62 (var2 -> empty .)
    CHAR            reduce using rule 62 (var2 -> empty .)
    FLOAT           reduce using rule 62 (var2 -> empty .)
    FUNCTION        reduce using rule 62 (var2 -> empty .)
    PRINCIPAL       reduce using rule 62 (var2 -> empty .)
    $end            reduce using rule 62 (var2 -> empty .)
    LCURLY          reduce using rule 62 (var2 -> empty .)


state 18

    (6) principal -> PRINCIPAL LPAREN . RPAREN LCURLY statements RCURLY

    RPAREN          shift and go to state 26


state 19

    (2) program1 -> vars functions principal .

    $end            reduce using rule 2 (program1 -> vars functions principal .)


state 20

    (73) functions -> FUNCTION VOID . functionVoid functions
    (76) functionVoid -> . ID LPAREN args RPAREN vars LCURLY statements RCURLY

    ID              shift and go to state 28

    functionVoid                   shift and go to state 27

state 21

    (74) functions -> FUNCTION type . functionType functions
    (77) functionType -> . ID LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY

    ID              shift and go to state 30

    functionType                   shift and go to state 29

state 22

    (68) type -> INT .

    ID              reduce using rule 68 (type -> INT .)
    TWOPOINTS       reduce using rule 68 (type -> INT .)


state 23

    (69) type -> CHAR .

    ID              reduce using rule 69 (type -> CHAR .)
    TWOPOINTS       reduce using rule 69 (type -> CHAR .)


state 24

    (70) type -> FLOAT .

    ID              reduce using rule 70 (type -> FLOAT .)
    TWOPOINTS       reduce using rule 70 (type -> FLOAT .)


state 25

    (61) var2 -> var2 type . TWOPOINTS var1 SEMMICOLON

    TWOPOINTS       shift and go to state 31


state 26

    (6) principal -> PRINCIPAL LPAREN RPAREN . LCURLY statements RCURLY

    LCURLY          shift and go to state 32


state 27

    (73) functions -> FUNCTION VOID functionVoid . functions
    (73) functions -> . FUNCTION VOID functionVoid functions
    (74) functions -> . FUNCTION type functionType functions
    (75) functions -> . empty
    (84) empty -> .

    FUNCTION        shift and go to state 14
    PRINCIPAL       reduce using rule 84 (empty -> .)
    $end            reduce using rule 84 (empty -> .)

    functions                      shift and go to state 33
    empty                          shift and go to state 15

state 28

    (76) functionVoid -> ID . LPAREN args RPAREN vars LCURLY statements RCURLY

    LPAREN          shift and go to state 34


state 29

    (74) functions -> FUNCTION type functionType . functions
    (73) functions -> . FUNCTION VOID functionVoid functions
    (74) functions -> . FUNCTION type functionType functions
    (75) functions -> . empty
    (84) empty -> .

    FUNCTION        shift and go to state 14
    PRINCIPAL       reduce using rule 84 (empty -> .)
    $end            reduce using rule 84 (empty -> .)

    functions                      shift and go to state 35
    empty                          shift and go to state 15

state 30

    (77) functionType -> ID . LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY

    LPAREN          shift and go to state 36


state 31

    (61) var2 -> var2 type TWOPOINTS . var1 SEMMICOLON
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (84) empty -> .

    ID              shift and go to state 38
    SEMMICOLON      reduce using rule 84 (empty -> .)

    var1                           shift and go to state 37
    empty                          shift and go to state 39

state 32

    (6) principal -> PRINCIPAL LPAREN RPAREN LCURLY . statements RCURLY
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)

    statements                     shift and go to state 40
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 33

    (73) functions -> FUNCTION VOID functionVoid functions .

    PRINCIPAL       reduce using rule 73 (functions -> FUNCTION VOID functionVoid functions .)
    $end            reduce using rule 73 (functions -> FUNCTION VOID functionVoid functions .)


state 34

    (76) functionVoid -> ID LPAREN . args RPAREN vars LCURLY statements RCURLY
    (78) args -> . type TWOPOINTS ID MultipleArgs
    (79) args -> . empty
    (68) type -> . INT
    (69) type -> . CHAR
    (70) type -> . FLOAT
    (84) empty -> .

    INT             shift and go to state 22
    CHAR            shift and go to state 23
    FLOAT           shift and go to state 24
    RPAREN          reduce using rule 84 (empty -> .)

    args                           shift and go to state 57
    type                           shift and go to state 58
    empty                          shift and go to state 59

state 35

    (74) functions -> FUNCTION type functionType functions .

    PRINCIPAL       reduce using rule 74 (functions -> FUNCTION type functionType functions .)
    $end            reduce using rule 74 (functions -> FUNCTION type functionType functions .)


state 36

    (77) functionType -> ID LPAREN . args RPAREN vars LCURLY statements return SEMMICOLON RCURLY
    (78) args -> . type TWOPOINTS ID MultipleArgs
    (79) args -> . empty
    (68) type -> . INT
    (69) type -> . CHAR
    (70) type -> . FLOAT
    (84) empty -> .

    INT             shift and go to state 22
    CHAR            shift and go to state 23
    FLOAT           shift and go to state 24
    RPAREN          reduce using rule 84 (empty -> .)

    args                           shift and go to state 60
    type                           shift and go to state 58
    empty                          shift and go to state 59

state 37

    (61) var2 -> var2 type TWOPOINTS var1 . SEMMICOLON

    SEMMICOLON      shift and go to state 61


state 38

    (63) var1 -> ID .
    (64) var1 -> ID . COMMA var1
    (65) var1 -> ID . arr
    (66) var1 -> ID . arr COMMA var1
    (71) arr -> . LBRACKET CTEI RBRACKET
    (72) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 63 (var1 -> ID .)
    MUL             reduce using rule 63 (var1 -> ID .)
    DIV             reduce using rule 63 (var1 -> ID .)
    PLUS            reduce using rule 63 (var1 -> ID .)
    MINUS           reduce using rule 63 (var1 -> ID .)
    GT              reduce using rule 63 (var1 -> ID .)
    LT              reduce using rule 63 (var1 -> ID .)
    GTE             reduce using rule 63 (var1 -> ID .)
    LTE             reduce using rule 63 (var1 -> ID .)
    NE              reduce using rule 63 (var1 -> ID .)
    AND             reduce using rule 63 (var1 -> ID .)
    OR              reduce using rule 63 (var1 -> ID .)
    RBRACKET        reduce using rule 63 (var1 -> ID .)
    TO              reduce using rule 63 (var1 -> ID .)
    RPAREN          reduce using rule 63 (var1 -> ID .)
    CTEI            reduce using rule 63 (var1 -> ID .)
    CTEF            reduce using rule 63 (var1 -> ID .)
    LPAREN          reduce using rule 63 (var1 -> ID .)
    ID              reduce using rule 63 (var1 -> ID .)
    COMMA           shift and go to state 62
    LBRACKET        shift and go to state 64

  ! COMMA           [ reduce using rule 63 (var1 -> ID .) ]

    arr                            shift and go to state 63

state 39

    (67) var1 -> empty .

    SEMMICOLON      reduce using rule 67 (var1 -> empty .)
    MUL             reduce using rule 67 (var1 -> empty .)
    DIV             reduce using rule 67 (var1 -> empty .)
    PLUS            reduce using rule 67 (var1 -> empty .)
    MINUS           reduce using rule 67 (var1 -> empty .)
    GT              reduce using rule 67 (var1 -> empty .)
    LT              reduce using rule 67 (var1 -> empty .)
    GTE             reduce using rule 67 (var1 -> empty .)
    LTE             reduce using rule 67 (var1 -> empty .)
    NE              reduce using rule 67 (var1 -> empty .)
    AND             reduce using rule 67 (var1 -> empty .)
    OR              reduce using rule 67 (var1 -> empty .)
    RBRACKET        reduce using rule 67 (var1 -> empty .)
    TO              reduce using rule 67 (var1 -> empty .)
    RPAREN          reduce using rule 67 (var1 -> empty .)
    COMMA           reduce using rule 67 (var1 -> empty .)
    CTEI            reduce using rule 67 (var1 -> empty .)
    CTEF            reduce using rule 67 (var1 -> empty .)
    LPAREN          reduce using rule 67 (var1 -> empty .)
    ID              reduce using rule 67 (var1 -> empty .)


state 40

    (6) principal -> PRINCIPAL LPAREN RPAREN LCURLY statements . RCURLY

    RCURLY          shift and go to state 65


state 41

    (7) statements -> assign . SEMMICOLON statements

    SEMMICOLON      shift and go to state 66


state 42

    (8) statements -> functionCall . SEMMICOLON statements

    SEMMICOLON      shift and go to state 67


state 43

    (9) statements -> read . statements SEMMICOLON statements
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    SEMMICOLON      reduce using rule 84 (empty -> .)

    read                           shift and go to state 43
    statements                     shift and go to state 68
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 44

    (10) statements -> write . statements SEMMICOLON statements
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    SEMMICOLON      reduce using rule 84 (empty -> .)

    write                          shift and go to state 44
    statements                     shift and go to state 69
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 45

    (11) statements -> for . statements
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)

  ! RETURN          [ reduce using rule 84 (empty -> .) ]

    for                            shift and go to state 45
    statements                     shift and go to state 70
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 46

    (12) statements -> while . statements
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)

  ! RETURN          [ reduce using rule 84 (empty -> .) ]

    while                          shift and go to state 46
    statements                     shift and go to state 71
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 47

    (13) statements -> if . statements
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)

  ! RETURN          [ reduce using rule 84 (empty -> .) ]

    if                             shift and go to state 47
    statements                     shift and go to state 72
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 48

    (14) statements -> return . statements
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)

  ! RETURN          [ reduce using rule 84 (empty -> .) ]

    return                         shift and go to state 48
    statements                     shift and go to state 73
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    empty                          shift and go to state 49

state 49

    (15) statements -> empty .

    RCURLY          reduce using rule 15 (statements -> empty .)
    SEMMICOLON      reduce using rule 15 (statements -> empty .)
    RETURN          reduce using rule 15 (statements -> empty .)


state 50

    (16) assign -> ID . EQUALS exp
    (17) assign -> ID . LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> ID . LPAREN exp RPAREN

    EQUALS          shift and go to state 74
    LBRACKET        shift and go to state 75
    LPAREN          shift and go to state 76


state 51

    (19) read -> READ . LPAREN read1 RPAREN

    LPAREN          shift and go to state 77


state 52

    (24) write -> WRITE . LPAREN write1 RPAREN

    LPAREN          shift and go to state 78


state 53

    (31) for -> FOR . assign TO CTEI DO LCURLY statements RCURLY
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp

    ID              shift and go to state 80

    assign                         shift and go to state 79

state 54

    (32) while -> WHILE . LPAREN exp RPAREN DO LCURLY statements RCURLY

    LPAREN          shift and go to state 81


state 55

    (33) if -> IF . LPAREN exp RPAREN THEN LCURLY statements RCURLY else

    LPAREN          shift and go to state 82


state 56

    (82) return -> RETURN . LPAREN exp RPAREN SEMMICOLON
    (83) return -> RETURN . LPAREN exp RPAREN

    LPAREN          shift and go to state 83


state 57

    (76) functionVoid -> ID LPAREN args . RPAREN vars LCURLY statements RCURLY

    RPAREN          shift and go to state 84


state 58

    (78) args -> type . TWOPOINTS ID MultipleArgs

    TWOPOINTS       shift and go to state 85


state 59

    (79) args -> empty .

    RPAREN          reduce using rule 79 (args -> empty .)


state 60

    (77) functionType -> ID LPAREN args . RPAREN vars LCURLY statements return SEMMICOLON RCURLY

    RPAREN          shift and go to state 86


state 61

    (61) var2 -> var2 type TWOPOINTS var1 SEMMICOLON .

    INT             reduce using rule 61 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    CHAR            reduce using rule 61 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    FLOAT           reduce using rule 61 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    FUNCTION        reduce using rule 61 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    PRINCIPAL       reduce using rule 61 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    $end            reduce using rule 61 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    LCURLY          reduce using rule 61 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)


state 62

    (64) var1 -> ID COMMA . var1
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (84) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 38
    SEMMICOLON      reduce using rule 84 (empty -> .)
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)
    CTEI            reduce using rule 84 (empty -> .)
    CTEF            reduce using rule 84 (empty -> .)
    LPAREN          reduce using rule 84 (empty -> .)

  ! ID              [ reduce using rule 84 (empty -> .) ]

    var1                           shift and go to state 87
    empty                          shift and go to state 39

state 63

    (65) var1 -> ID arr .
    (66) var1 -> ID arr . COMMA var1

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 65 (var1 -> ID arr .)
    MUL             reduce using rule 65 (var1 -> ID arr .)
    DIV             reduce using rule 65 (var1 -> ID arr .)
    PLUS            reduce using rule 65 (var1 -> ID arr .)
    MINUS           reduce using rule 65 (var1 -> ID arr .)
    GT              reduce using rule 65 (var1 -> ID arr .)
    LT              reduce using rule 65 (var1 -> ID arr .)
    GTE             reduce using rule 65 (var1 -> ID arr .)
    LTE             reduce using rule 65 (var1 -> ID arr .)
    NE              reduce using rule 65 (var1 -> ID arr .)
    AND             reduce using rule 65 (var1 -> ID arr .)
    OR              reduce using rule 65 (var1 -> ID arr .)
    RBRACKET        reduce using rule 65 (var1 -> ID arr .)
    TO              reduce using rule 65 (var1 -> ID arr .)
    RPAREN          reduce using rule 65 (var1 -> ID arr .)
    CTEI            reduce using rule 65 (var1 -> ID arr .)
    CTEF            reduce using rule 65 (var1 -> ID arr .)
    LPAREN          reduce using rule 65 (var1 -> ID arr .)
    ID              reduce using rule 65 (var1 -> ID arr .)
    COMMA           shift and go to state 88

  ! COMMA           [ reduce using rule 65 (var1 -> ID arr .) ]


state 64

    (71) arr -> LBRACKET . CTEI RBRACKET
    (72) arr -> LBRACKET . exp RBRACKET
    (36) exp -> . nexp
    (37) exp -> . nexp OR nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 89
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)

    exp                            shift and go to state 90
    nexp                           shift and go to state 91
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 65

    (6) principal -> PRINCIPAL LPAREN RPAREN LCURLY statements RCURLY .

    $end            reduce using rule 6 (principal -> PRINCIPAL LPAREN RPAREN LCURLY statements RCURLY .)


state 66

    (7) statements -> assign SEMMICOLON . statements
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)

  ! RETURN          [ reduce using rule 84 (empty -> .) ]

    assign                         shift and go to state 41
    statements                     shift and go to state 102
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 67

    (8) statements -> functionCall SEMMICOLON . statements
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)

  ! RETURN          [ reduce using rule 84 (empty -> .) ]

    functionCall                   shift and go to state 42
    statements                     shift and go to state 103
    assign                         shift and go to state 41
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 68

    (9) statements -> read statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 104


state 69

    (10) statements -> write statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 105


state 70

    (11) statements -> for statements .

    RCURLY          reduce using rule 11 (statements -> for statements .)
    SEMMICOLON      reduce using rule 11 (statements -> for statements .)
    RETURN          reduce using rule 11 (statements -> for statements .)


state 71

    (12) statements -> while statements .

    RCURLY          reduce using rule 12 (statements -> while statements .)
    SEMMICOLON      reduce using rule 12 (statements -> while statements .)
    RETURN          reduce using rule 12 (statements -> while statements .)


state 72

    (13) statements -> if statements .

    RCURLY          reduce using rule 13 (statements -> if statements .)
    SEMMICOLON      reduce using rule 13 (statements -> if statements .)
    RETURN          reduce using rule 13 (statements -> if statements .)


state 73

    (14) statements -> return statements .

    RCURLY          reduce using rule 14 (statements -> return statements .)
    SEMMICOLON      reduce using rule 14 (statements -> return statements .)
    RETURN          reduce using rule 14 (statements -> return statements .)


state 74

    (16) assign -> ID EQUALS . exp
    (36) exp -> . nexp
    (37) exp -> . nexp OR nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)

    exp                            shift and go to state 106
    nexp                           shift and go to state 91
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 75

    (17) assign -> ID LBRACKET . exp RBRACKET EQUALS exp
    (36) exp -> . nexp
    (37) exp -> . nexp OR nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)

    exp                            shift and go to state 108
    nexp                           shift and go to state 91
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 76

    (18) functionCall -> ID LPAREN . exp RPAREN
    (36) exp -> . nexp
    (37) exp -> . nexp OR nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)

    exp                            shift and go to state 109
    nexp                           shift and go to state 91
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 77

    (19) read -> READ LPAREN . read1 RPAREN
    (20) read1 -> . ID read2

    ID              shift and go to state 111

    read1                          shift and go to state 110

state 78

    (24) write -> WRITE LPAREN . write1 RPAREN
    (25) write1 -> . write2 COMMA write2
    (26) write1 -> . write2
    (27) write2 -> . CTESTRING
    (28) write2 -> . CTEI
    (29) write2 -> . CTEF
    (30) write2 -> . exp
    (36) exp -> . nexp
    (37) exp -> . nexp OR nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTESTRING       shift and go to state 114
    CTEI            shift and go to state 115
    CTEF            shift and go to state 116
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)

    write1                         shift and go to state 112
    write2                         shift and go to state 113
    exp                            shift and go to state 117
    nexp                           shift and go to state 91
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 79

    (31) for -> FOR assign . TO CTEI DO LCURLY statements RCURLY

    TO              shift and go to state 118


state 80

    (16) assign -> ID . EQUALS exp
    (17) assign -> ID . LBRACKET exp RBRACKET EQUALS exp

    EQUALS          shift and go to state 74
    LBRACKET        shift and go to state 75


state 81

    (32) while -> WHILE LPAREN . exp RPAREN DO LCURLY statements RCURLY
    (36) exp -> . nexp
    (37) exp -> . nexp OR nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)

    exp                            shift and go to state 119
    nexp                           shift and go to state 91
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 82

    (33) if -> IF LPAREN . exp RPAREN THEN LCURLY statements RCURLY else
    (36) exp -> . nexp
    (37) exp -> . nexp OR nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)

    exp                            shift and go to state 120
    nexp                           shift and go to state 91
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 83

    (82) return -> RETURN LPAREN . exp RPAREN SEMMICOLON
    (83) return -> RETURN LPAREN . exp RPAREN
    (36) exp -> . nexp
    (37) exp -> . nexp OR nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)

    exp                            shift and go to state 121
    nexp                           shift and go to state 91
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 84

    (76) functionVoid -> ID LPAREN args RPAREN . vars LCURLY statements RCURLY
    (58) vars -> . var
    (59) vars -> . empty
    (60) var -> . VARS var2
    (84) empty -> .

    VARS            shift and go to state 11
    LCURLY          reduce using rule 84 (empty -> .)

    vars                           shift and go to state 122
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 85

    (78) args -> type TWOPOINTS . ID MultipleArgs

    ID              shift and go to state 123


state 86

    (77) functionType -> ID LPAREN args RPAREN . vars LCURLY statements return SEMMICOLON RCURLY
    (58) vars -> . var
    (59) vars -> . empty
    (60) var -> . VARS var2
    (84) empty -> .

    VARS            shift and go to state 11
    LCURLY          reduce using rule 84 (empty -> .)

    vars                           shift and go to state 124
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 87

    (64) var1 -> ID COMMA var1 .

    SEMMICOLON      reduce using rule 64 (var1 -> ID COMMA var1 .)
    MUL             reduce using rule 64 (var1 -> ID COMMA var1 .)
    DIV             reduce using rule 64 (var1 -> ID COMMA var1 .)
    PLUS            reduce using rule 64 (var1 -> ID COMMA var1 .)
    MINUS           reduce using rule 64 (var1 -> ID COMMA var1 .)
    GT              reduce using rule 64 (var1 -> ID COMMA var1 .)
    LT              reduce using rule 64 (var1 -> ID COMMA var1 .)
    GTE             reduce using rule 64 (var1 -> ID COMMA var1 .)
    LTE             reduce using rule 64 (var1 -> ID COMMA var1 .)
    NE              reduce using rule 64 (var1 -> ID COMMA var1 .)
    AND             reduce using rule 64 (var1 -> ID COMMA var1 .)
    OR              reduce using rule 64 (var1 -> ID COMMA var1 .)
    RBRACKET        reduce using rule 64 (var1 -> ID COMMA var1 .)
    TO              reduce using rule 64 (var1 -> ID COMMA var1 .)
    RPAREN          reduce using rule 64 (var1 -> ID COMMA var1 .)
    COMMA           reduce using rule 64 (var1 -> ID COMMA var1 .)
    CTEI            reduce using rule 64 (var1 -> ID COMMA var1 .)
    CTEF            reduce using rule 64 (var1 -> ID COMMA var1 .)
    LPAREN          reduce using rule 64 (var1 -> ID COMMA var1 .)
    ID              reduce using rule 64 (var1 -> ID COMMA var1 .)


state 88

    (66) var1 -> ID arr COMMA . var1
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (84) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 38
    SEMMICOLON      reduce using rule 84 (empty -> .)
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)
    CTEI            reduce using rule 84 (empty -> .)
    CTEF            reduce using rule 84 (empty -> .)
    LPAREN          reduce using rule 84 (empty -> .)

  ! ID              [ reduce using rule 84 (empty -> .) ]

    var1                           shift and go to state 125
    empty                          shift and go to state 39

state 89

    (71) arr -> LBRACKET CTEI . RBRACKET
    (54) pexp -> CTEI .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 126
    MUL             reduce using rule 54 (pexp -> CTEI .)
    DIV             reduce using rule 54 (pexp -> CTEI .)
    PLUS            reduce using rule 54 (pexp -> CTEI .)
    MINUS           reduce using rule 54 (pexp -> CTEI .)
    GT              reduce using rule 54 (pexp -> CTEI .)
    LT              reduce using rule 54 (pexp -> CTEI .)
    GTE             reduce using rule 54 (pexp -> CTEI .)
    LTE             reduce using rule 54 (pexp -> CTEI .)
    NE              reduce using rule 54 (pexp -> CTEI .)
    AND             reduce using rule 54 (pexp -> CTEI .)
    OR              reduce using rule 54 (pexp -> CTEI .)

  ! RBRACKET        [ reduce using rule 54 (pexp -> CTEI .) ]


state 90

    (72) arr -> LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 127


state 91

    (36) exp -> nexp .
    (37) exp -> nexp . OR nexp

    RBRACKET        reduce using rule 36 (exp -> nexp .)
    SEMMICOLON      reduce using rule 36 (exp -> nexp .)
    TO              reduce using rule 36 (exp -> nexp .)
    RPAREN          reduce using rule 36 (exp -> nexp .)
    COMMA           reduce using rule 36 (exp -> nexp .)
    OR              shift and go to state 128


state 92

    (38) nexp -> compexp .
    (39) nexp -> compexp . AND compexp

    OR              reduce using rule 38 (nexp -> compexp .)
    RBRACKET        reduce using rule 38 (nexp -> compexp .)
    SEMMICOLON      reduce using rule 38 (nexp -> compexp .)
    TO              reduce using rule 38 (nexp -> compexp .)
    RPAREN          reduce using rule 38 (nexp -> compexp .)
    COMMA           reduce using rule 38 (nexp -> compexp .)
    AND             shift and go to state 129


state 93

    (40) compexp -> sumexp .
    (42) compexp1 -> sumexp . GT sumexp
    (43) compexp1 -> sumexp . LT sumexp
    (44) compexp1 -> sumexp . GTE sumexp
    (45) compexp1 -> sumexp . LTE sumexp
    (46) compexp1 -> sumexp . NE sumexp

    AND             reduce using rule 40 (compexp -> sumexp .)
    OR              reduce using rule 40 (compexp -> sumexp .)
    RBRACKET        reduce using rule 40 (compexp -> sumexp .)
    SEMMICOLON      reduce using rule 40 (compexp -> sumexp .)
    TO              reduce using rule 40 (compexp -> sumexp .)
    RPAREN          reduce using rule 40 (compexp -> sumexp .)
    COMMA           reduce using rule 40 (compexp -> sumexp .)
    GT              shift and go to state 130
    LT              shift and go to state 131
    GTE             shift and go to state 132
    LTE             shift and go to state 133
    NE              shift and go to state 134


state 94

    (41) compexp -> compexp1 . sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)

    sumexp                         shift and go to state 135
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 95

    (47) sumexp -> mulexp .
    (48) sumexp -> mulexp . PLUS mulexp
    (49) sumexp -> mulexp . MINUS mulexp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    GT              reduce using rule 47 (sumexp -> mulexp .)
    LT              reduce using rule 47 (sumexp -> mulexp .)
    GTE             reduce using rule 47 (sumexp -> mulexp .)
    LTE             reduce using rule 47 (sumexp -> mulexp .)
    NE              reduce using rule 47 (sumexp -> mulexp .)
    AND             reduce using rule 47 (sumexp -> mulexp .)
    OR              reduce using rule 47 (sumexp -> mulexp .)
    RBRACKET        reduce using rule 47 (sumexp -> mulexp .)
    SEMMICOLON      reduce using rule 47 (sumexp -> mulexp .)
    TO              reduce using rule 47 (sumexp -> mulexp .)
    RPAREN          reduce using rule 47 (sumexp -> mulexp .)
    COMMA           reduce using rule 47 (sumexp -> mulexp .)
    CTEI            reduce using rule 47 (sumexp -> mulexp .)
    CTEF            reduce using rule 47 (sumexp -> mulexp .)
    LPAREN          reduce using rule 47 (sumexp -> mulexp .)
    ID              reduce using rule 47 (sumexp -> mulexp .)
    MUL             reduce using rule 47 (sumexp -> mulexp .)
    DIV             reduce using rule 47 (sumexp -> mulexp .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137

  ! PLUS            [ reduce using rule 47 (sumexp -> mulexp .) ]
  ! MINUS           [ reduce using rule 47 (sumexp -> mulexp .) ]


state 96

    (50) mulexp -> pexp .
    (51) mulexp -> pexp . MUL pexp
    (52) mulexp -> pexp . DIV pexp

  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    PLUS            reduce using rule 50 (mulexp -> pexp .)
    MINUS           reduce using rule 50 (mulexp -> pexp .)
    GT              reduce using rule 50 (mulexp -> pexp .)
    LT              reduce using rule 50 (mulexp -> pexp .)
    GTE             reduce using rule 50 (mulexp -> pexp .)
    LTE             reduce using rule 50 (mulexp -> pexp .)
    NE              reduce using rule 50 (mulexp -> pexp .)
    AND             reduce using rule 50 (mulexp -> pexp .)
    OR              reduce using rule 50 (mulexp -> pexp .)
    RBRACKET        reduce using rule 50 (mulexp -> pexp .)
    SEMMICOLON      reduce using rule 50 (mulexp -> pexp .)
    TO              reduce using rule 50 (mulexp -> pexp .)
    RPAREN          reduce using rule 50 (mulexp -> pexp .)
    COMMA           reduce using rule 50 (mulexp -> pexp .)
    CTEI            reduce using rule 50 (mulexp -> pexp .)
    CTEF            reduce using rule 50 (mulexp -> pexp .)
    LPAREN          reduce using rule 50 (mulexp -> pexp .)
    ID              reduce using rule 50 (mulexp -> pexp .)
    MUL             shift and go to state 138
    DIV             shift and go to state 139

  ! MUL             [ reduce using rule 50 (mulexp -> pexp .) ]
  ! DIV             [ reduce using rule 50 (mulexp -> pexp .) ]


state 97

    (53) pexp -> var1 .

    MUL             reduce using rule 53 (pexp -> var1 .)
    DIV             reduce using rule 53 (pexp -> var1 .)
    PLUS            reduce using rule 53 (pexp -> var1 .)
    MINUS           reduce using rule 53 (pexp -> var1 .)
    GT              reduce using rule 53 (pexp -> var1 .)
    LT              reduce using rule 53 (pexp -> var1 .)
    GTE             reduce using rule 53 (pexp -> var1 .)
    LTE             reduce using rule 53 (pexp -> var1 .)
    NE              reduce using rule 53 (pexp -> var1 .)
    AND             reduce using rule 53 (pexp -> var1 .)
    OR              reduce using rule 53 (pexp -> var1 .)
    RBRACKET        reduce using rule 53 (pexp -> var1 .)
    SEMMICOLON      reduce using rule 53 (pexp -> var1 .)
    TO              reduce using rule 53 (pexp -> var1 .)
    RPAREN          reduce using rule 53 (pexp -> var1 .)
    COMMA           reduce using rule 53 (pexp -> var1 .)
    CTEI            reduce using rule 53 (pexp -> var1 .)
    CTEF            reduce using rule 53 (pexp -> var1 .)
    LPAREN          reduce using rule 53 (pexp -> var1 .)
    ID              reduce using rule 53 (pexp -> var1 .)


state 98

    (55) pexp -> CTEF .

    MUL             reduce using rule 55 (pexp -> CTEF .)
    DIV             reduce using rule 55 (pexp -> CTEF .)
    PLUS            reduce using rule 55 (pexp -> CTEF .)
    MINUS           reduce using rule 55 (pexp -> CTEF .)
    GT              reduce using rule 55 (pexp -> CTEF .)
    LT              reduce using rule 55 (pexp -> CTEF .)
    GTE             reduce using rule 55 (pexp -> CTEF .)
    LTE             reduce using rule 55 (pexp -> CTEF .)
    NE              reduce using rule 55 (pexp -> CTEF .)
    AND             reduce using rule 55 (pexp -> CTEF .)
    OR              reduce using rule 55 (pexp -> CTEF .)
    RBRACKET        reduce using rule 55 (pexp -> CTEF .)
    SEMMICOLON      reduce using rule 55 (pexp -> CTEF .)
    TO              reduce using rule 55 (pexp -> CTEF .)
    RPAREN          reduce using rule 55 (pexp -> CTEF .)
    COMMA           reduce using rule 55 (pexp -> CTEF .)
    CTEI            reduce using rule 55 (pexp -> CTEF .)
    CTEF            reduce using rule 55 (pexp -> CTEF .)
    LPAREN          reduce using rule 55 (pexp -> CTEF .)
    ID              reduce using rule 55 (pexp -> CTEF .)


state 99

    (56) pexp -> functionCall .

    MUL             reduce using rule 56 (pexp -> functionCall .)
    DIV             reduce using rule 56 (pexp -> functionCall .)
    PLUS            reduce using rule 56 (pexp -> functionCall .)
    MINUS           reduce using rule 56 (pexp -> functionCall .)
    GT              reduce using rule 56 (pexp -> functionCall .)
    LT              reduce using rule 56 (pexp -> functionCall .)
    GTE             reduce using rule 56 (pexp -> functionCall .)
    LTE             reduce using rule 56 (pexp -> functionCall .)
    NE              reduce using rule 56 (pexp -> functionCall .)
    AND             reduce using rule 56 (pexp -> functionCall .)
    OR              reduce using rule 56 (pexp -> functionCall .)
    RBRACKET        reduce using rule 56 (pexp -> functionCall .)
    SEMMICOLON      reduce using rule 56 (pexp -> functionCall .)
    TO              reduce using rule 56 (pexp -> functionCall .)
    RPAREN          reduce using rule 56 (pexp -> functionCall .)
    COMMA           reduce using rule 56 (pexp -> functionCall .)
    CTEI            reduce using rule 56 (pexp -> functionCall .)
    CTEF            reduce using rule 56 (pexp -> functionCall .)
    LPAREN          reduce using rule 56 (pexp -> functionCall .)
    ID              reduce using rule 56 (pexp -> functionCall .)


state 100

    (57) pexp -> LPAREN . exp RPAREN
    (36) exp -> . nexp
    (37) exp -> . nexp OR nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)

    exp                            shift and go to state 140
    nexp                           shift and go to state 91
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 101

    (63) var1 -> ID .
    (64) var1 -> ID . COMMA var1
    (65) var1 -> ID . arr
    (66) var1 -> ID . arr COMMA var1
    (18) functionCall -> ID . LPAREN exp RPAREN
    (71) arr -> . LBRACKET CTEI RBRACKET
    (72) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    MUL             reduce using rule 63 (var1 -> ID .)
    DIV             reduce using rule 63 (var1 -> ID .)
    PLUS            reduce using rule 63 (var1 -> ID .)
    MINUS           reduce using rule 63 (var1 -> ID .)
    GT              reduce using rule 63 (var1 -> ID .)
    LT              reduce using rule 63 (var1 -> ID .)
    GTE             reduce using rule 63 (var1 -> ID .)
    LTE             reduce using rule 63 (var1 -> ID .)
    NE              reduce using rule 63 (var1 -> ID .)
    AND             reduce using rule 63 (var1 -> ID .)
    OR              reduce using rule 63 (var1 -> ID .)
    RBRACKET        reduce using rule 63 (var1 -> ID .)
    SEMMICOLON      reduce using rule 63 (var1 -> ID .)
    TO              reduce using rule 63 (var1 -> ID .)
    RPAREN          reduce using rule 63 (var1 -> ID .)
    CTEI            reduce using rule 63 (var1 -> ID .)
    CTEF            reduce using rule 63 (var1 -> ID .)
    ID              reduce using rule 63 (var1 -> ID .)
    COMMA           shift and go to state 62
    LPAREN          shift and go to state 76
    LBRACKET        shift and go to state 64

  ! COMMA           [ reduce using rule 63 (var1 -> ID .) ]
  ! LPAREN          [ reduce using rule 63 (var1 -> ID .) ]

    arr                            shift and go to state 63

state 102

    (7) statements -> assign SEMMICOLON statements .

    RCURLY          reduce using rule 7 (statements -> assign SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 7 (statements -> assign SEMMICOLON statements .)
    RETURN          reduce using rule 7 (statements -> assign SEMMICOLON statements .)


state 103

    (8) statements -> functionCall SEMMICOLON statements .

    RCURLY          reduce using rule 8 (statements -> functionCall SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 8 (statements -> functionCall SEMMICOLON statements .)
    RETURN          reduce using rule 8 (statements -> functionCall SEMMICOLON statements .)


state 104

    (9) statements -> read statements SEMMICOLON . statements
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)

  ! RETURN          [ reduce using rule 84 (empty -> .) ]

    read                           shift and go to state 43
    statements                     shift and go to state 141
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 105

    (10) statements -> write statements SEMMICOLON . statements
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)

  ! RETURN          [ reduce using rule 84 (empty -> .) ]

    write                          shift and go to state 44
    statements                     shift and go to state 142
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 106

    (16) assign -> ID EQUALS exp .

    SEMMICOLON      reduce using rule 16 (assign -> ID EQUALS exp .)
    TO              reduce using rule 16 (assign -> ID EQUALS exp .)


state 107

    (54) pexp -> CTEI .

    MUL             reduce using rule 54 (pexp -> CTEI .)
    DIV             reduce using rule 54 (pexp -> CTEI .)
    PLUS            reduce using rule 54 (pexp -> CTEI .)
    MINUS           reduce using rule 54 (pexp -> CTEI .)
    GT              reduce using rule 54 (pexp -> CTEI .)
    LT              reduce using rule 54 (pexp -> CTEI .)
    GTE             reduce using rule 54 (pexp -> CTEI .)
    LTE             reduce using rule 54 (pexp -> CTEI .)
    NE              reduce using rule 54 (pexp -> CTEI .)
    AND             reduce using rule 54 (pexp -> CTEI .)
    OR              reduce using rule 54 (pexp -> CTEI .)
    SEMMICOLON      reduce using rule 54 (pexp -> CTEI .)
    TO              reduce using rule 54 (pexp -> CTEI .)
    RBRACKET        reduce using rule 54 (pexp -> CTEI .)
    RPAREN          reduce using rule 54 (pexp -> CTEI .)
    COMMA           reduce using rule 54 (pexp -> CTEI .)
    CTEI            reduce using rule 54 (pexp -> CTEI .)
    CTEF            reduce using rule 54 (pexp -> CTEI .)
    LPAREN          reduce using rule 54 (pexp -> CTEI .)
    ID              reduce using rule 54 (pexp -> CTEI .)


state 108

    (17) assign -> ID LBRACKET exp . RBRACKET EQUALS exp

    RBRACKET        shift and go to state 143


state 109

    (18) functionCall -> ID LPAREN exp . RPAREN

    RPAREN          shift and go to state 144


state 110

    (19) read -> READ LPAREN read1 . RPAREN

    RPAREN          shift and go to state 145


state 111

    (20) read1 -> ID . read2
    (21) read2 -> . COMMA read1
    (22) read2 -> . empty
    (84) empty -> .

    COMMA           shift and go to state 147
    RPAREN          reduce using rule 84 (empty -> .)

    read2                          shift and go to state 146
    empty                          shift and go to state 148

state 112

    (24) write -> WRITE LPAREN write1 . RPAREN

    RPAREN          shift and go to state 149


state 113

    (25) write1 -> write2 . COMMA write2
    (26) write1 -> write2 .

    COMMA           shift and go to state 150
    RPAREN          reduce using rule 26 (write1 -> write2 .)


state 114

    (27) write2 -> CTESTRING .

    COMMA           reduce using rule 27 (write2 -> CTESTRING .)
    RPAREN          reduce using rule 27 (write2 -> CTESTRING .)


state 115

    (28) write2 -> CTEI .
    (54) pexp -> CTEI .

  ! reduce/reduce conflict for COMMA resolved using rule 28 (write2 -> CTEI .)
  ! reduce/reduce conflict for RPAREN resolved using rule 28 (write2 -> CTEI .)
    COMMA           reduce using rule 28 (write2 -> CTEI .)
    RPAREN          reduce using rule 28 (write2 -> CTEI .)
    MUL             reduce using rule 54 (pexp -> CTEI .)
    DIV             reduce using rule 54 (pexp -> CTEI .)
    PLUS            reduce using rule 54 (pexp -> CTEI .)
    MINUS           reduce using rule 54 (pexp -> CTEI .)
    GT              reduce using rule 54 (pexp -> CTEI .)
    LT              reduce using rule 54 (pexp -> CTEI .)
    GTE             reduce using rule 54 (pexp -> CTEI .)
    LTE             reduce using rule 54 (pexp -> CTEI .)
    NE              reduce using rule 54 (pexp -> CTEI .)
    AND             reduce using rule 54 (pexp -> CTEI .)
    OR              reduce using rule 54 (pexp -> CTEI .)

  ! COMMA           [ reduce using rule 54 (pexp -> CTEI .) ]
  ! RPAREN          [ reduce using rule 54 (pexp -> CTEI .) ]


state 116

    (29) write2 -> CTEF .
    (55) pexp -> CTEF .

  ! reduce/reduce conflict for COMMA resolved using rule 29 (write2 -> CTEF .)
  ! reduce/reduce conflict for RPAREN resolved using rule 29 (write2 -> CTEF .)
    COMMA           reduce using rule 29 (write2 -> CTEF .)
    RPAREN          reduce using rule 29 (write2 -> CTEF .)
    MUL             reduce using rule 55 (pexp -> CTEF .)
    DIV             reduce using rule 55 (pexp -> CTEF .)
    PLUS            reduce using rule 55 (pexp -> CTEF .)
    MINUS           reduce using rule 55 (pexp -> CTEF .)
    GT              reduce using rule 55 (pexp -> CTEF .)
    LT              reduce using rule 55 (pexp -> CTEF .)
    GTE             reduce using rule 55 (pexp -> CTEF .)
    LTE             reduce using rule 55 (pexp -> CTEF .)
    NE              reduce using rule 55 (pexp -> CTEF .)
    AND             reduce using rule 55 (pexp -> CTEF .)
    OR              reduce using rule 55 (pexp -> CTEF .)

  ! COMMA           [ reduce using rule 55 (pexp -> CTEF .) ]
  ! RPAREN          [ reduce using rule 55 (pexp -> CTEF .) ]


state 117

    (30) write2 -> exp .

    COMMA           reduce using rule 30 (write2 -> exp .)
    RPAREN          reduce using rule 30 (write2 -> exp .)


state 118

    (31) for -> FOR assign TO . CTEI DO LCURLY statements RCURLY

    CTEI            shift and go to state 151


state 119

    (32) while -> WHILE LPAREN exp . RPAREN DO LCURLY statements RCURLY

    RPAREN          shift and go to state 152


state 120

    (33) if -> IF LPAREN exp . RPAREN THEN LCURLY statements RCURLY else

    RPAREN          shift and go to state 153


state 121

    (82) return -> RETURN LPAREN exp . RPAREN SEMMICOLON
    (83) return -> RETURN LPAREN exp . RPAREN

    RPAREN          shift and go to state 154


state 122

    (76) functionVoid -> ID LPAREN args RPAREN vars . LCURLY statements RCURLY

    LCURLY          shift and go to state 155


state 123

    (78) args -> type TWOPOINTS ID . MultipleArgs
    (80) MultipleArgs -> . COMMA args
    (81) MultipleArgs -> . empty
    (84) empty -> .

    COMMA           shift and go to state 157
    RPAREN          reduce using rule 84 (empty -> .)

    MultipleArgs                   shift and go to state 156
    empty                          shift and go to state 158

state 124

    (77) functionType -> ID LPAREN args RPAREN vars . LCURLY statements return SEMMICOLON RCURLY

    LCURLY          shift and go to state 159


state 125

    (66) var1 -> ID arr COMMA var1 .

    SEMMICOLON      reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    MUL             reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    DIV             reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    PLUS            reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    MINUS           reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    GT              reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    LT              reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    GTE             reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    LTE             reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    NE              reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    AND             reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    OR              reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    RBRACKET        reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    TO              reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    RPAREN          reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    COMMA           reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    CTEI            reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    CTEF            reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    LPAREN          reduce using rule 66 (var1 -> ID arr COMMA var1 .)
    ID              reduce using rule 66 (var1 -> ID arr COMMA var1 .)


state 126

    (71) arr -> LBRACKET CTEI RBRACKET .

    COMMA           reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    SEMMICOLON      reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    MUL             reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    DIV             reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    PLUS            reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    MINUS           reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    GT              reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    LT              reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    GTE             reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    LTE             reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    NE              reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    AND             reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    OR              reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    RBRACKET        reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    TO              reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    RPAREN          reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    CTEI            reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    CTEF            reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    LPAREN          reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)
    ID              reduce using rule 71 (arr -> LBRACKET CTEI RBRACKET .)


state 127

    (72) arr -> LBRACKET exp RBRACKET .

    COMMA           reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    SEMMICOLON      reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    MUL             reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    DIV             reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    GT              reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    LT              reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    GTE             reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    LTE             reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    NE              reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    AND             reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    OR              reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    TO              reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    CTEI            reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    CTEF            reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)
    ID              reduce using rule 72 (arr -> LBRACKET exp RBRACKET .)


state 128

    (37) exp -> nexp OR . nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)

    nexp                           shift and go to state 160
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 129

    (39) nexp -> compexp AND . compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)

    compexp                        shift and go to state 161
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 130

    (42) compexp1 -> sumexp GT . sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)

  ! CTEI            [ reduce using rule 84 (empty -> .) ]
  ! CTEF            [ reduce using rule 84 (empty -> .) ]
  ! LPAREN          [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]

    sumexp                         shift and go to state 162
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 131

    (43) compexp1 -> sumexp LT . sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)

  ! CTEI            [ reduce using rule 84 (empty -> .) ]
  ! CTEF            [ reduce using rule 84 (empty -> .) ]
  ! LPAREN          [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]

    sumexp                         shift and go to state 163
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 132

    (44) compexp1 -> sumexp GTE . sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)

  ! CTEI            [ reduce using rule 84 (empty -> .) ]
  ! CTEF            [ reduce using rule 84 (empty -> .) ]
  ! LPAREN          [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]

    sumexp                         shift and go to state 164
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 133

    (45) compexp1 -> sumexp LTE . sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)

  ! CTEI            [ reduce using rule 84 (empty -> .) ]
  ! CTEF            [ reduce using rule 84 (empty -> .) ]
  ! LPAREN          [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]

    sumexp                         shift and go to state 165
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 134

    (46) compexp1 -> sumexp NE . sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)

  ! CTEI            [ reduce using rule 84 (empty -> .) ]
  ! CTEF            [ reduce using rule 84 (empty -> .) ]
  ! LPAREN          [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]

    sumexp                         shift and go to state 166
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 135

    (41) compexp -> compexp1 sumexp .

    AND             reduce using rule 41 (compexp -> compexp1 sumexp .)
    OR              reduce using rule 41 (compexp -> compexp1 sumexp .)
    RBRACKET        reduce using rule 41 (compexp -> compexp1 sumexp .)
    SEMMICOLON      reduce using rule 41 (compexp -> compexp1 sumexp .)
    TO              reduce using rule 41 (compexp -> compexp1 sumexp .)
    RPAREN          reduce using rule 41 (compexp -> compexp1 sumexp .)
    COMMA           reduce using rule 41 (compexp -> compexp1 sumexp .)


state 136

    (48) sumexp -> mulexp PLUS . mulexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)

  ! CTEI            [ reduce using rule 84 (empty -> .) ]
  ! CTEF            [ reduce using rule 84 (empty -> .) ]
  ! LPAREN          [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]

    mulexp                         shift and go to state 167
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 137

    (49) sumexp -> mulexp MINUS . mulexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)

  ! CTEI            [ reduce using rule 84 (empty -> .) ]
  ! CTEF            [ reduce using rule 84 (empty -> .) ]
  ! LPAREN          [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]

    mulexp                         shift and go to state 168
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 138

    (51) mulexp -> pexp MUL . pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)

  ! CTEI            [ reduce using rule 84 (empty -> .) ]
  ! CTEF            [ reduce using rule 84 (empty -> .) ]
  ! LPAREN          [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]

    pexp                           shift and go to state 169
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 139

    (52) mulexp -> pexp DIV . pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RBRACKET        reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)
    COMMA           reduce using rule 84 (empty -> .)
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)

  ! CTEI            [ reduce using rule 84 (empty -> .) ]
  ! CTEF            [ reduce using rule 84 (empty -> .) ]
  ! LPAREN          [ reduce using rule 84 (empty -> .) ]
  ! ID              [ reduce using rule 84 (empty -> .) ]

    pexp                           shift and go to state 170
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 140

    (57) pexp -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 171


state 141

    (9) statements -> read statements SEMMICOLON statements .

    RCURLY          reduce using rule 9 (statements -> read statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 9 (statements -> read statements SEMMICOLON statements .)
    RETURN          reduce using rule 9 (statements -> read statements SEMMICOLON statements .)


state 142

    (10) statements -> write statements SEMMICOLON statements .

    RCURLY          reduce using rule 10 (statements -> write statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 10 (statements -> write statements SEMMICOLON statements .)
    RETURN          reduce using rule 10 (statements -> write statements SEMMICOLON statements .)


state 143

    (17) assign -> ID LBRACKET exp RBRACKET . EQUALS exp

    EQUALS          shift and go to state 172


state 144

    (18) functionCall -> ID LPAREN exp RPAREN .

    SEMMICOLON      reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    MUL             reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    DIV             reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    PLUS            reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    MINUS           reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    GT              reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    LT              reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    GTE             reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    LTE             reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    NE              reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    AND             reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    OR              reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    TO              reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    RPAREN          reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    COMMA           reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    CTEI            reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    CTEF            reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    LPAREN          reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)
    ID              reduce using rule 18 (functionCall -> ID LPAREN exp RPAREN .)


state 145

    (19) read -> READ LPAREN read1 RPAREN .

    ID              reduce using rule 19 (read -> READ LPAREN read1 RPAREN .)
    READ            reduce using rule 19 (read -> READ LPAREN read1 RPAREN .)
    WRITE           reduce using rule 19 (read -> READ LPAREN read1 RPAREN .)
    FOR             reduce using rule 19 (read -> READ LPAREN read1 RPAREN .)
    WHILE           reduce using rule 19 (read -> READ LPAREN read1 RPAREN .)
    IF              reduce using rule 19 (read -> READ LPAREN read1 RPAREN .)
    RETURN          reduce using rule 19 (read -> READ LPAREN read1 RPAREN .)
    SEMMICOLON      reduce using rule 19 (read -> READ LPAREN read1 RPAREN .)


state 146

    (20) read1 -> ID read2 .

    RPAREN          reduce using rule 20 (read1 -> ID read2 .)


state 147

    (21) read2 -> COMMA . read1
    (20) read1 -> . ID read2

    ID              shift and go to state 111

    read1                          shift and go to state 173

state 148

    (22) read2 -> empty .

    RPAREN          reduce using rule 22 (read2 -> empty .)


state 149

    (24) write -> WRITE LPAREN write1 RPAREN .

    ID              reduce using rule 24 (write -> WRITE LPAREN write1 RPAREN .)
    READ            reduce using rule 24 (write -> WRITE LPAREN write1 RPAREN .)
    WRITE           reduce using rule 24 (write -> WRITE LPAREN write1 RPAREN .)
    FOR             reduce using rule 24 (write -> WRITE LPAREN write1 RPAREN .)
    WHILE           reduce using rule 24 (write -> WRITE LPAREN write1 RPAREN .)
    IF              reduce using rule 24 (write -> WRITE LPAREN write1 RPAREN .)
    RETURN          reduce using rule 24 (write -> WRITE LPAREN write1 RPAREN .)
    SEMMICOLON      reduce using rule 24 (write -> WRITE LPAREN write1 RPAREN .)


state 150

    (25) write1 -> write2 COMMA . write2
    (27) write2 -> . CTESTRING
    (28) write2 -> . CTEI
    (29) write2 -> . CTEF
    (30) write2 -> . exp
    (36) exp -> . nexp
    (37) exp -> . nexp OR nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTESTRING       shift and go to state 114
    CTEI            shift and go to state 115
    CTEF            shift and go to state 116
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    RPAREN          reduce using rule 84 (empty -> .)

    write2                         shift and go to state 174
    exp                            shift and go to state 117
    nexp                           shift and go to state 91
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 151

    (31) for -> FOR assign TO CTEI . DO LCURLY statements RCURLY

    DO              shift and go to state 175


state 152

    (32) while -> WHILE LPAREN exp RPAREN . DO LCURLY statements RCURLY

    DO              shift and go to state 176


state 153

    (33) if -> IF LPAREN exp RPAREN . THEN LCURLY statements RCURLY else

    THEN            shift and go to state 177


state 154

    (82) return -> RETURN LPAREN exp RPAREN . SEMMICOLON
    (83) return -> RETURN LPAREN exp RPAREN .

  ! shift/reduce conflict for SEMMICOLON resolved as shift
    SEMMICOLON      shift and go to state 178
    ID              reduce using rule 83 (return -> RETURN LPAREN exp RPAREN .)
    READ            reduce using rule 83 (return -> RETURN LPAREN exp RPAREN .)
    WRITE           reduce using rule 83 (return -> RETURN LPAREN exp RPAREN .)
    FOR             reduce using rule 83 (return -> RETURN LPAREN exp RPAREN .)
    WHILE           reduce using rule 83 (return -> RETURN LPAREN exp RPAREN .)
    IF              reduce using rule 83 (return -> RETURN LPAREN exp RPAREN .)
    RETURN          reduce using rule 83 (return -> RETURN LPAREN exp RPAREN .)
    RCURLY          reduce using rule 83 (return -> RETURN LPAREN exp RPAREN .)

  ! SEMMICOLON      [ reduce using rule 83 (return -> RETURN LPAREN exp RPAREN .) ]


state 155

    (76) functionVoid -> ID LPAREN args RPAREN vars LCURLY . statements RCURLY
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)

    statements                     shift and go to state 179
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 156

    (78) args -> type TWOPOINTS ID MultipleArgs .

    RPAREN          reduce using rule 78 (args -> type TWOPOINTS ID MultipleArgs .)


state 157

    (80) MultipleArgs -> COMMA . args
    (78) args -> . type TWOPOINTS ID MultipleArgs
    (79) args -> . empty
    (68) type -> . INT
    (69) type -> . CHAR
    (70) type -> . FLOAT
    (84) empty -> .

    INT             shift and go to state 22
    CHAR            shift and go to state 23
    FLOAT           shift and go to state 24
    RPAREN          reduce using rule 84 (empty -> .)

    args                           shift and go to state 180
    type                           shift and go to state 58
    empty                          shift and go to state 59

state 158

    (81) MultipleArgs -> empty .

    RPAREN          reduce using rule 81 (MultipleArgs -> empty .)


state 159

    (77) functionType -> ID LPAREN args RPAREN vars LCURLY . statements return SEMMICOLON RCURLY
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56

  ! RETURN          [ reduce using rule 84 (empty -> .) ]

    statements                     shift and go to state 181
    return                         shift and go to state 48
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    empty                          shift and go to state 49

state 160

    (37) exp -> nexp OR nexp .

    RBRACKET        reduce using rule 37 (exp -> nexp OR nexp .)
    SEMMICOLON      reduce using rule 37 (exp -> nexp OR nexp .)
    TO              reduce using rule 37 (exp -> nexp OR nexp .)
    RPAREN          reduce using rule 37 (exp -> nexp OR nexp .)
    COMMA           reduce using rule 37 (exp -> nexp OR nexp .)


state 161

    (39) nexp -> compexp AND compexp .

    OR              reduce using rule 39 (nexp -> compexp AND compexp .)
    RBRACKET        reduce using rule 39 (nexp -> compexp AND compexp .)
    SEMMICOLON      reduce using rule 39 (nexp -> compexp AND compexp .)
    TO              reduce using rule 39 (nexp -> compexp AND compexp .)
    RPAREN          reduce using rule 39 (nexp -> compexp AND compexp .)
    COMMA           reduce using rule 39 (nexp -> compexp AND compexp .)


state 162

    (42) compexp1 -> sumexp GT sumexp .

    CTEI            reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    CTEF            reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    LPAREN          reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    ID              reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    PLUS            reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    MINUS           reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    MUL             reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    DIV             reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    AND             reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    OR              reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    RBRACKET        reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    SEMMICOLON      reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    TO              reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    RPAREN          reduce using rule 42 (compexp1 -> sumexp GT sumexp .)
    COMMA           reduce using rule 42 (compexp1 -> sumexp GT sumexp .)


state 163

    (43) compexp1 -> sumexp LT sumexp .

    CTEI            reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    CTEF            reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    LPAREN          reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    ID              reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    PLUS            reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    MINUS           reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    MUL             reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    DIV             reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    AND             reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    OR              reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    RBRACKET        reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    SEMMICOLON      reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    TO              reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    RPAREN          reduce using rule 43 (compexp1 -> sumexp LT sumexp .)
    COMMA           reduce using rule 43 (compexp1 -> sumexp LT sumexp .)


state 164

    (44) compexp1 -> sumexp GTE sumexp .

    CTEI            reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    CTEF            reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    LPAREN          reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    ID              reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    PLUS            reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    MINUS           reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    MUL             reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    DIV             reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    AND             reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    OR              reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    RBRACKET        reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    SEMMICOLON      reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    TO              reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    RPAREN          reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)
    COMMA           reduce using rule 44 (compexp1 -> sumexp GTE sumexp .)


state 165

    (45) compexp1 -> sumexp LTE sumexp .

    CTEI            reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    CTEF            reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    LPAREN          reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    ID              reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    PLUS            reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    MINUS           reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    MUL             reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    DIV             reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    AND             reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    OR              reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    RBRACKET        reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    SEMMICOLON      reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    TO              reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    RPAREN          reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)
    COMMA           reduce using rule 45 (compexp1 -> sumexp LTE sumexp .)


state 166

    (46) compexp1 -> sumexp NE sumexp .

    CTEI            reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    CTEF            reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    LPAREN          reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    ID              reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    PLUS            reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    MINUS           reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    MUL             reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    DIV             reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    AND             reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    OR              reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    RBRACKET        reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    SEMMICOLON      reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    TO              reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    RPAREN          reduce using rule 46 (compexp1 -> sumexp NE sumexp .)
    COMMA           reduce using rule 46 (compexp1 -> sumexp NE sumexp .)


state 167

    (48) sumexp -> mulexp PLUS mulexp .

    GT              reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    LT              reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    GTE             reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    LTE             reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    NE              reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    AND             reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    OR              reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    RBRACKET        reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    SEMMICOLON      reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    TO              reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    RPAREN          reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    COMMA           reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    CTEI            reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    CTEF            reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    LPAREN          reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    ID              reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    PLUS            reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    MINUS           reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    MUL             reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)
    DIV             reduce using rule 48 (sumexp -> mulexp PLUS mulexp .)


state 168

    (49) sumexp -> mulexp MINUS mulexp .

    GT              reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    LT              reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    GTE             reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    LTE             reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    NE              reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    AND             reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    OR              reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    RBRACKET        reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    SEMMICOLON      reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    TO              reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    RPAREN          reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    COMMA           reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    CTEI            reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    CTEF            reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    LPAREN          reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    ID              reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    PLUS            reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    MINUS           reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    MUL             reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)
    DIV             reduce using rule 49 (sumexp -> mulexp MINUS mulexp .)


state 169

    (51) mulexp -> pexp MUL pexp .

    PLUS            reduce using rule 51 (mulexp -> pexp MUL pexp .)
    MINUS           reduce using rule 51 (mulexp -> pexp MUL pexp .)
    GT              reduce using rule 51 (mulexp -> pexp MUL pexp .)
    LT              reduce using rule 51 (mulexp -> pexp MUL pexp .)
    GTE             reduce using rule 51 (mulexp -> pexp MUL pexp .)
    LTE             reduce using rule 51 (mulexp -> pexp MUL pexp .)
    NE              reduce using rule 51 (mulexp -> pexp MUL pexp .)
    AND             reduce using rule 51 (mulexp -> pexp MUL pexp .)
    OR              reduce using rule 51 (mulexp -> pexp MUL pexp .)
    RBRACKET        reduce using rule 51 (mulexp -> pexp MUL pexp .)
    SEMMICOLON      reduce using rule 51 (mulexp -> pexp MUL pexp .)
    TO              reduce using rule 51 (mulexp -> pexp MUL pexp .)
    RPAREN          reduce using rule 51 (mulexp -> pexp MUL pexp .)
    COMMA           reduce using rule 51 (mulexp -> pexp MUL pexp .)
    CTEI            reduce using rule 51 (mulexp -> pexp MUL pexp .)
    CTEF            reduce using rule 51 (mulexp -> pexp MUL pexp .)
    LPAREN          reduce using rule 51 (mulexp -> pexp MUL pexp .)
    ID              reduce using rule 51 (mulexp -> pexp MUL pexp .)
    MUL             reduce using rule 51 (mulexp -> pexp MUL pexp .)
    DIV             reduce using rule 51 (mulexp -> pexp MUL pexp .)


state 170

    (52) mulexp -> pexp DIV pexp .

    PLUS            reduce using rule 52 (mulexp -> pexp DIV pexp .)
    MINUS           reduce using rule 52 (mulexp -> pexp DIV pexp .)
    GT              reduce using rule 52 (mulexp -> pexp DIV pexp .)
    LT              reduce using rule 52 (mulexp -> pexp DIV pexp .)
    GTE             reduce using rule 52 (mulexp -> pexp DIV pexp .)
    LTE             reduce using rule 52 (mulexp -> pexp DIV pexp .)
    NE              reduce using rule 52 (mulexp -> pexp DIV pexp .)
    AND             reduce using rule 52 (mulexp -> pexp DIV pexp .)
    OR              reduce using rule 52 (mulexp -> pexp DIV pexp .)
    RBRACKET        reduce using rule 52 (mulexp -> pexp DIV pexp .)
    SEMMICOLON      reduce using rule 52 (mulexp -> pexp DIV pexp .)
    TO              reduce using rule 52 (mulexp -> pexp DIV pexp .)
    RPAREN          reduce using rule 52 (mulexp -> pexp DIV pexp .)
    COMMA           reduce using rule 52 (mulexp -> pexp DIV pexp .)
    CTEI            reduce using rule 52 (mulexp -> pexp DIV pexp .)
    CTEF            reduce using rule 52 (mulexp -> pexp DIV pexp .)
    LPAREN          reduce using rule 52 (mulexp -> pexp DIV pexp .)
    ID              reduce using rule 52 (mulexp -> pexp DIV pexp .)
    MUL             reduce using rule 52 (mulexp -> pexp DIV pexp .)
    DIV             reduce using rule 52 (mulexp -> pexp DIV pexp .)


state 171

    (57) pexp -> LPAREN exp RPAREN .

    MUL             reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    DIV             reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    AND             reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    OR              reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    SEMMICOLON      reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    TO              reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    CTEI            reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    CTEF            reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 57 (pexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 57 (pexp -> LPAREN exp RPAREN .)


state 172

    (17) assign -> ID LBRACKET exp RBRACKET EQUALS . exp
    (36) exp -> . nexp
    (37) exp -> . nexp OR nexp
    (38) nexp -> . compexp
    (39) nexp -> . compexp AND compexp
    (40) compexp -> . sumexp
    (41) compexp -> . compexp1 sumexp
    (47) sumexp -> . mulexp
    (48) sumexp -> . mulexp PLUS mulexp
    (49) sumexp -> . mulexp MINUS mulexp
    (42) compexp1 -> . sumexp GT sumexp
    (43) compexp1 -> . sumexp LT sumexp
    (44) compexp1 -> . sumexp GTE sumexp
    (45) compexp1 -> . sumexp LTE sumexp
    (46) compexp1 -> . sumexp NE sumexp
    (50) mulexp -> . pexp
    (51) mulexp -> . pexp MUL pexp
    (52) mulexp -> . pexp DIV pexp
    (53) pexp -> . var1
    (54) pexp -> . CTEI
    (55) pexp -> . CTEF
    (56) pexp -> . functionCall
    (57) pexp -> . LPAREN exp RPAREN
    (63) var1 -> . ID
    (64) var1 -> . ID COMMA var1
    (65) var1 -> . ID arr
    (66) var1 -> . ID arr COMMA var1
    (67) var1 -> . empty
    (18) functionCall -> . ID LPAREN exp RPAREN
    (84) empty -> .

    CTEI            shift and go to state 107
    CTEF            shift and go to state 98
    LPAREN          shift and go to state 100
    ID              shift and go to state 101
    MUL             reduce using rule 84 (empty -> .)
    DIV             reduce using rule 84 (empty -> .)
    PLUS            reduce using rule 84 (empty -> .)
    MINUS           reduce using rule 84 (empty -> .)
    GT              reduce using rule 84 (empty -> .)
    LT              reduce using rule 84 (empty -> .)
    GTE             reduce using rule 84 (empty -> .)
    LTE             reduce using rule 84 (empty -> .)
    NE              reduce using rule 84 (empty -> .)
    AND             reduce using rule 84 (empty -> .)
    OR              reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)
    TO              reduce using rule 84 (empty -> .)

    exp                            shift and go to state 182
    nexp                           shift and go to state 91
    compexp                        shift and go to state 92
    sumexp                         shift and go to state 93
    compexp1                       shift and go to state 94
    mulexp                         shift and go to state 95
    pexp                           shift and go to state 96
    var1                           shift and go to state 97
    functionCall                   shift and go to state 99
    empty                          shift and go to state 39

state 173

    (21) read2 -> COMMA read1 .

    RPAREN          reduce using rule 21 (read2 -> COMMA read1 .)


state 174

    (25) write1 -> write2 COMMA write2 .

    RPAREN          reduce using rule 25 (write1 -> write2 COMMA write2 .)


state 175

    (31) for -> FOR assign TO CTEI DO . LCURLY statements RCURLY

    LCURLY          shift and go to state 183


state 176

    (32) while -> WHILE LPAREN exp RPAREN DO . LCURLY statements RCURLY

    LCURLY          shift and go to state 184


state 177

    (33) if -> IF LPAREN exp RPAREN THEN . LCURLY statements RCURLY else

    LCURLY          shift and go to state 185


state 178

    (82) return -> RETURN LPAREN exp RPAREN SEMMICOLON .

    ID              reduce using rule 82 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    READ            reduce using rule 82 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WRITE           reduce using rule 82 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    FOR             reduce using rule 82 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WHILE           reduce using rule 82 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    IF              reduce using rule 82 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RETURN          reduce using rule 82 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RCURLY          reduce using rule 82 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    SEMMICOLON      reduce using rule 82 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)


state 179

    (76) functionVoid -> ID LPAREN args RPAREN vars LCURLY statements . RCURLY

    RCURLY          shift and go to state 186


state 180

    (80) MultipleArgs -> COMMA args .

    RPAREN          reduce using rule 80 (MultipleArgs -> COMMA args .)


state 181

    (77) functionType -> ID LPAREN args RPAREN vars LCURLY statements . return SEMMICOLON RCURLY
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN

    RETURN          shift and go to state 56

    return                         shift and go to state 187

state 182

    (17) assign -> ID LBRACKET exp RBRACKET EQUALS exp .

    SEMMICOLON      reduce using rule 17 (assign -> ID LBRACKET exp RBRACKET EQUALS exp .)
    TO              reduce using rule 17 (assign -> ID LBRACKET exp RBRACKET EQUALS exp .)


state 183

    (31) for -> FOR assign TO CTEI DO LCURLY . statements RCURLY
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)

    assign                         shift and go to state 41
    statements                     shift and go to state 188
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 184

    (32) while -> WHILE LPAREN exp RPAREN DO LCURLY . statements RCURLY
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)

    statements                     shift and go to state 189
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 185

    (33) if -> IF LPAREN exp RPAREN THEN LCURLY . statements RCURLY else
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)

    statements                     shift and go to state 190
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 186

    (76) functionVoid -> ID LPAREN args RPAREN vars LCURLY statements RCURLY .

    FUNCTION        reduce using rule 76 (functionVoid -> ID LPAREN args RPAREN vars LCURLY statements RCURLY .)
    PRINCIPAL       reduce using rule 76 (functionVoid -> ID LPAREN args RPAREN vars LCURLY statements RCURLY .)
    $end            reduce using rule 76 (functionVoid -> ID LPAREN args RPAREN vars LCURLY statements RCURLY .)


state 187

    (77) functionType -> ID LPAREN args RPAREN vars LCURLY statements return . SEMMICOLON RCURLY

    SEMMICOLON      shift and go to state 191


state 188

    (31) for -> FOR assign TO CTEI DO LCURLY statements . RCURLY

    RCURLY          shift and go to state 192


state 189

    (32) while -> WHILE LPAREN exp RPAREN DO LCURLY statements . RCURLY

    RCURLY          shift and go to state 193


state 190

    (33) if -> IF LPAREN exp RPAREN THEN LCURLY statements . RCURLY else

    RCURLY          shift and go to state 194


state 191

    (77) functionType -> ID LPAREN args RPAREN vars LCURLY statements return SEMMICOLON . RCURLY

    RCURLY          shift and go to state 195


state 192

    (31) for -> FOR assign TO CTEI DO LCURLY statements RCURLY .

    ID              reduce using rule 31 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    READ            reduce using rule 31 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    WRITE           reduce using rule 31 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    FOR             reduce using rule 31 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    WHILE           reduce using rule 31 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    IF              reduce using rule 31 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    RETURN          reduce using rule 31 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    RCURLY          reduce using rule 31 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 31 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)


state 193

    (32) while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .

    ID              reduce using rule 32 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    READ            reduce using rule 32 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    WRITE           reduce using rule 32 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    FOR             reduce using rule 32 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    WHILE           reduce using rule 32 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    IF              reduce using rule 32 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    RETURN          reduce using rule 32 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    RCURLY          reduce using rule 32 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 32 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)


state 194

    (33) if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY . else
    (34) else -> . ELSE LCURLY statements RCURLY
    (35) else -> . empty
    (84) empty -> .

    ELSE            shift and go to state 197
    ID              reduce using rule 84 (empty -> .)
    READ            reduce using rule 84 (empty -> .)
    WRITE           reduce using rule 84 (empty -> .)
    FOR             reduce using rule 84 (empty -> .)
    WHILE           reduce using rule 84 (empty -> .)
    IF              reduce using rule 84 (empty -> .)
    RETURN          reduce using rule 84 (empty -> .)
    RCURLY          reduce using rule 84 (empty -> .)
    SEMMICOLON      reduce using rule 84 (empty -> .)

    else                           shift and go to state 196
    empty                          shift and go to state 198

state 195

    (77) functionType -> ID LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY .

    FUNCTION        reduce using rule 77 (functionType -> ID LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY .)
    PRINCIPAL       reduce using rule 77 (functionType -> ID LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY .)
    $end            reduce using rule 77 (functionType -> ID LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY .)


state 196

    (33) if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .

    ID              reduce using rule 33 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    READ            reduce using rule 33 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    WRITE           reduce using rule 33 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    FOR             reduce using rule 33 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    WHILE           reduce using rule 33 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    IF              reduce using rule 33 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    RETURN          reduce using rule 33 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    RCURLY          reduce using rule 33 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    SEMMICOLON      reduce using rule 33 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)


state 197

    (34) else -> ELSE . LCURLY statements RCURLY

    LCURLY          shift and go to state 199


state 198

    (35) else -> empty .

    ID              reduce using rule 35 (else -> empty .)
    READ            reduce using rule 35 (else -> empty .)
    WRITE           reduce using rule 35 (else -> empty .)
    FOR             reduce using rule 35 (else -> empty .)
    WHILE           reduce using rule 35 (else -> empty .)
    IF              reduce using rule 35 (else -> empty .)
    RETURN          reduce using rule 35 (else -> empty .)
    RCURLY          reduce using rule 35 (else -> empty .)
    SEMMICOLON      reduce using rule 35 (else -> empty .)


state 199

    (34) else -> ELSE LCURLY . statements RCURLY
    (7) statements -> . assign SEMMICOLON statements
    (8) statements -> . functionCall SEMMICOLON statements
    (9) statements -> . read statements SEMMICOLON statements
    (10) statements -> . write statements SEMMICOLON statements
    (11) statements -> . for statements
    (12) statements -> . while statements
    (13) statements -> . if statements
    (14) statements -> . return statements
    (15) statements -> . empty
    (16) assign -> . ID EQUALS exp
    (17) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (18) functionCall -> . ID LPAREN exp RPAREN
    (19) read -> . READ LPAREN read1 RPAREN
    (24) write -> . WRITE LPAREN write1 RPAREN
    (31) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (32) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (33) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (82) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (83) return -> . RETURN LPAREN exp RPAREN
    (84) empty -> .

    ID              shift and go to state 50
    READ            shift and go to state 51
    WRITE           shift and go to state 52
    FOR             shift and go to state 53
    WHILE           shift and go to state 54
    IF              shift and go to state 55
    RETURN          shift and go to state 56
    RCURLY          reduce using rule 84 (empty -> .)

    statements                     shift and go to state 200
    assign                         shift and go to state 41
    functionCall                   shift and go to state 42
    read                           shift and go to state 43
    write                          shift and go to state 44
    for                            shift and go to state 45
    while                          shift and go to state 46
    if                             shift and go to state 47
    return                         shift and go to state 48
    empty                          shift and go to state 49

state 200

    (34) else -> ELSE LCURLY statements . RCURLY

    RCURLY          shift and go to state 201


state 201

    (34) else -> ELSE LCURLY statements RCURLY .

    ID              reduce using rule 34 (else -> ELSE LCURLY statements RCURLY .)
    READ            reduce using rule 34 (else -> ELSE LCURLY statements RCURLY .)
    WRITE           reduce using rule 34 (else -> ELSE LCURLY statements RCURLY .)
    FOR             reduce using rule 34 (else -> ELSE LCURLY statements RCURLY .)
    WHILE           reduce using rule 34 (else -> ELSE LCURLY statements RCURLY .)
    IF              reduce using rule 34 (else -> ELSE LCURLY statements RCURLY .)
    RETURN          reduce using rule 34 (else -> ELSE LCURLY statements RCURLY .)
    RCURLY          reduce using rule 34 (else -> ELSE LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 34 (else -> ELSE LCURLY statements RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PRINCIPAL in state 4 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 38 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 45 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 46 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 47 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 48 resolved as shift
WARNING: shift/reduce conflict for ID in state 62 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 63 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 66 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 67 resolved as shift
WARNING: shift/reduce conflict for ID in state 88 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 89 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 95 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 95 resolved as shift
WARNING: shift/reduce conflict for MUL in state 96 resolved as shift
WARNING: shift/reduce conflict for DIV in state 96 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 101 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 101 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 104 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 105 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 130 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 130 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 130 resolved as shift
WARNING: shift/reduce conflict for ID in state 130 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 131 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 131 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 131 resolved as shift
WARNING: shift/reduce conflict for ID in state 131 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 132 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 132 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 132 resolved as shift
WARNING: shift/reduce conflict for ID in state 132 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 133 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 133 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 133 resolved as shift
WARNING: shift/reduce conflict for ID in state 133 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 134 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 134 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 134 resolved as shift
WARNING: shift/reduce conflict for ID in state 134 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 136 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 136 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 136 resolved as shift
WARNING: shift/reduce conflict for ID in state 136 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 137 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 137 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 137 resolved as shift
WARNING: shift/reduce conflict for ID in state 137 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 138 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 138 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 138 resolved as shift
WARNING: shift/reduce conflict for ID in state 138 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 139 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 139 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 139 resolved as shift
WARNING: shift/reduce conflict for ID in state 139 resolved as shift
WARNING: shift/reduce conflict for SEMMICOLON in state 154 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 159 resolved as shift
WARNING: reduce/reduce conflict in state 115 resolved using rule (write2 -> CTEI)
WARNING: rejected rule (pexp -> CTEI) in state 115
WARNING: reduce/reduce conflict in state 116 resolved using rule (write2 -> CTEF)
WARNING: rejected rule (pexp -> CTEF) in state 116
