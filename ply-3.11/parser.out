Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMPARE
    END
    FROM
    MODA
    PLOTXY
    SIMPLEREGRESSION
    VARIANZA

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMMICOLON addProgram program1
Rule 2     addProgram -> <empty>
Rule 3     program1 -> vars functions program2
Rule 4     program1 -> vars functions
Rule 5     program1 -> program2
Rule 6     program2 -> principal
Rule 7     principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY
Rule 8     statements -> assign SEMMICOLON statements
Rule 9     statements -> functionCall SEMMICOLON statements
Rule 10    statements -> read statements SEMMICOLON statements
Rule 11    statements -> write statements SEMMICOLON statements
Rule 12    statements -> for statements
Rule 13    statements -> while statements
Rule 14    statements -> if statements
Rule 15    statements -> return statements
Rule 16    statements -> empty
Rule 17    assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad
Rule 18    assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
Rule 19    generateAssignQuad -> <empty>
Rule 20    add_id -> <empty>
Rule 21    add_id2 -> <empty>
Rule 22    functionCall -> ID LPAREN exp RPAREN
Rule 23    read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN
Rule 24    operatorRead -> <empty>
Rule 25    media -> MEDIA LPAREN arr RPAREN SEMMICOLON
Rule 26    write -> WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
Rule 27    writeOperator -> <empty>
Rule 28    write1 -> write2 COMMA write2
Rule 29    write1 -> write2
Rule 30    write2 -> COMILLA CTESTRING COMILLA
Rule 31    write2 -> CTEI saveCTE generateQuadPRINT
Rule 32    write2 -> CTEF saveCTE generateQuadPRINT
Rule 33    write2 -> exp
Rule 34    for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
Rule 35    forOP -> <empty>
Rule 36    generateQuadFOR -> <empty>
Rule 37    LoopEnd -> <empty>
Rule 38    while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
Rule 39    whileOP -> <empty>
Rule 40    generateQuadWHILE -> <empty>
Rule 41    if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
Rule 42    else -> ELSE generateQuadELSE LCURLY statements RCURLY
Rule 43    else -> empty
Rule 44    generateQuadOR -> <empty>
Rule 45    generateQuadAND -> <empty>
Rule 46    generateQuadCOMPARE -> <empty>
Rule 47    generateQuadIF -> <empty>
Rule 48    generateQuadSUM -> <empty>
Rule 49    generateQuadMUL -> <empty>
Rule 50    generateQuadPRINT -> <empty>
Rule 51    generateQuadREAD -> <empty>
Rule 52    endIF -> <empty>
Rule 53    generateQuadELSE -> <empty>
Rule 54    saveCTE -> <empty>
Rule 55    exp -> nexp generateQuadOR
Rule 56    exp -> nexp generateQuadOR OR saveOperator nexp
Rule 57    nexp -> compexp generateQuadAND
Rule 58    nexp -> compexp generateQuadAND AND saveOperator compexp
Rule 59    compexp -> sumexp
Rule 60    compexp -> compexp1 sumexp
Rule 61    compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE
Rule 62    compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE
Rule 63    compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE
Rule 64    compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE
Rule 65    compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE
Rule 66    sumexp -> mulexp
Rule 67    sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM
Rule 68    sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM
Rule 69    mulexp -> pexp
Rule 70    mulexp -> pexp MUL saveOperator pexp generateQuadMUL
Rule 71    mulexp -> pexp DIV saveOperator pexp generateQuadMUL
Rule 72    pexp -> var1 add_id
Rule 73    pexp -> CTEI saveCTE
Rule 74    pexp -> CTEF saveCTE
Rule 75    pexp -> CTEC saveCTE
Rule 76    pexp -> CTESTRING saveCTE
Rule 77    pexp -> functionCall
Rule 78    pexp -> LPAREN exp RPAREN
Rule 79    saveOperator -> <empty>
Rule 80    vars -> var
Rule 81    vars -> empty
Rule 82    var -> VARS var2
Rule 83    var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar
Rule 84    var2 -> empty
Rule 85    var1 -> ID
Rule 86    var1 -> ID COMMA var1 addVar
Rule 87    var1 -> ID arr
Rule 88    var1 -> ID arr COMMA var1 addVar
Rule 89    var1 -> empty
Rule 90    addVar -> <empty>
Rule 91    saveTypeVar -> <empty>
Rule 92    type -> INT saveTypeVar
Rule 93    type -> CHAR saveTypeVar
Rule 94    type -> FLOAT saveTypeVar
Rule 95    arr -> LBRACKET CTEI RBRACKET
Rule 96    arr -> LBRACKET exp RBRACKET
Rule 97    functions -> FUNCTION INT functions1 functions
Rule 98    functions -> FUNCTION CHAR functions1 functions
Rule 99    functions -> FUNCTION FLOAT functions1 functions
Rule 100   functions -> FUNCTION VOID functions1 functions
Rule 101   functions -> empty
Rule 102   functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
Rule 103   functions1 -> empty
Rule 104   saveFunction -> <empty>
Rule 105   args -> args type TWOPOINTS var1 addVar
Rule 106   args -> empty
Rule 107   args1 -> ID addVar
Rule 108   args1 -> ID COMMA args1
Rule 109   args1 -> empty
Rule 110   return -> RETURN LPAREN exp RPAREN SEMMICOLON
Rule 111   return -> RETURN LPAREN exp RPAREN
Rule 112   empty -> <empty>

Terminals, with rules where they appear

AND                  : 58
CHAR                 : 93 98
COMILLA              : 30 30
COMMA                : 28 86 88 108
COMPARE              : 
CTEC                 : 75
CTEF                 : 32 74
CTEI                 : 31 34 73 95
CTESTRING            : 30 76
DIV                  : 71
DO                   : 34 38
ELSE                 : 42
END                  : 
EQUALS               : 17 18
FLOAT                : 94 99
FOR                  : 34
FROM                 : 
FUNCTION             : 97 98 99 100
GT                   : 61
GTE                  : 63
ID                   : 1 17 18 22 85 86 87 88 102 107 108
IF                   : 41
INT                  : 92 97
LBRACKET             : 95 96
LCURLY               : 7 34 38 41 42 102
LPAREN               : 7 22 23 25 26 38 41 78 102 110 111
LT                   : 62
LTE                  : 64
MEDIA                : 25
MINUS                : 68
MODA                 : 
MUL                  : 70
NE                   : 65
OR                   : 56
PLOTXY               : 
PLUS                 : 67
PRINCIPAL            : 7
PROGRAM              : 1
RBRACKET             : 95 96
RCURLY               : 7 34 38 41 42 102
READ                 : 23
RETURN               : 110 111
RPAREN               : 7 22 23 25 26 38 41 78 102 110 111
SEMMICOLON           : 1 8 9 10 11 25 83 110
SIMPLEREGRESSION     : 
THEN                 : 41
TO                   : 34
TWOPOINTS            : 83 105
VARIANZA             : 
VARS                 : 82
VOID                 : 100
WHILE                : 38
WRITE                : 26
error                : 

Nonterminals, with rules where they appear

LoopEnd              : 34 38
addProgram           : 1
addVar               : 83 86 88 105 107
add_id               : 72
add_id2              : 17 18
args                 : 102 105
args1                : 108
arr                  : 18 25 87 88
assign               : 8 34
compexp              : 57 58 58
compexp1             : 60
else                 : 41
empty                : 16 43 81 84 89 101 103 106 109
endIF                : 41
exp                  : 17 18 22 33 38 41 78 96 110 111
for                  : 12
forOP                : 34
functionCall         : 9 77
functions            : 3 4 97 98 99 100
functions1           : 97 98 99 100
generateAssignQuad   : 17 18
generateQuadAND      : 57 58
generateQuadCOMPARE  : 61 62 63 64 65
generateQuadELSE     : 42
generateQuadFOR      : 34
generateQuadIF       : 41
generateQuadMUL      : 70 71
generateQuadOR       : 55 56
generateQuadPRINT    : 26 31 32
generateQuadREAD     : 23
generateQuadSUM      : 67 68
generateQuadWHILE    : 38
if                   : 14
media                : 
mulexp               : 66 67 67 68 68
nexp                 : 55 56 56
operatorRead         : 23
pexp                 : 69 70 70 71 71
principal            : 6
program              : 0
program1             : 1
program2             : 3 5
read                 : 10
return               : 15
saveCTE              : 31 32 73 74 75 76
saveFunction         : 7 102
saveOperator         : 17 18 56 58 61 62 63 64 65 67 68 70 71
saveTypeVar          : 92 93 94
statements           : 7 8 9 10 10 11 11 12 13 14 15 34 38 41 42 102
sumexp               : 59 60 61 61 62 62 63 63 64 64 65 65
type                 : 83 105
var                  : 80
var1                 : 23 72 83 86 88 105
var2                 : 82 83
vars                 : 3 4 7 102
while                : 13
whileOP              : 38
write                : 11
write1               : 26
write2               : 28 28 29
writeOperator        : 26

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMMICOLON addProgram program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMMICOLON addProgram program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMMICOLON addProgram program1

    SEMMICOLON      shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMMICOLON . addProgram program1
    (2) addProgram -> .

    VARS            reduce using rule 2 (addProgram -> .)
    PRINCIPAL       reduce using rule 2 (addProgram -> .)
    FUNCTION        reduce using rule 2 (addProgram -> .)
    $end            reduce using rule 2 (addProgram -> .)

    addProgram                     shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMMICOLON addProgram . program1
    (3) program1 -> . vars functions program2
    (4) program1 -> . vars functions
    (5) program1 -> . program2
    (80) vars -> . var
    (81) vars -> . empty
    (6) program2 -> . principal
    (82) var -> . VARS var2
    (112) empty -> .
    (7) principal -> . PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY

  ! shift/reduce conflict for PRINCIPAL resolved as shift
    VARS            shift and go to state 12
    FUNCTION        reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)
    PRINCIPAL       shift and go to state 13

  ! PRINCIPAL       [ reduce using rule 112 (empty -> .) ]

    program1                       shift and go to state 6
    vars                           shift and go to state 7
    program2                       shift and go to state 8
    var                            shift and go to state 9
    empty                          shift and go to state 10
    principal                      shift and go to state 11

state 6

    (1) program -> PROGRAM ID SEMMICOLON addProgram program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMMICOLON addProgram program1 .)


state 7

    (3) program1 -> vars . functions program2
    (4) program1 -> vars . functions
    (97) functions -> . FUNCTION INT functions1 functions
    (98) functions -> . FUNCTION CHAR functions1 functions
    (99) functions -> . FUNCTION FLOAT functions1 functions
    (100) functions -> . FUNCTION VOID functions1 functions
    (101) functions -> . empty
    (112) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)

    functions                      shift and go to state 14
    empty                          shift and go to state 16

state 8

    (5) program1 -> program2 .

    $end            reduce using rule 5 (program1 -> program2 .)


state 9

    (80) vars -> var .

    FUNCTION        reduce using rule 80 (vars -> var .)
    PRINCIPAL       reduce using rule 80 (vars -> var .)
    $end            reduce using rule 80 (vars -> var .)
    ID              reduce using rule 80 (vars -> var .)
    READ            reduce using rule 80 (vars -> var .)
    WRITE           reduce using rule 80 (vars -> var .)
    FOR             reduce using rule 80 (vars -> var .)
    WHILE           reduce using rule 80 (vars -> var .)
    IF              reduce using rule 80 (vars -> var .)
    RETURN          reduce using rule 80 (vars -> var .)
    RCURLY          reduce using rule 80 (vars -> var .)
    LCURLY          reduce using rule 80 (vars -> var .)


state 10

    (81) vars -> empty .

    FUNCTION        reduce using rule 81 (vars -> empty .)
    PRINCIPAL       reduce using rule 81 (vars -> empty .)
    $end            reduce using rule 81 (vars -> empty .)
    ID              reduce using rule 81 (vars -> empty .)
    READ            reduce using rule 81 (vars -> empty .)
    WRITE           reduce using rule 81 (vars -> empty .)
    FOR             reduce using rule 81 (vars -> empty .)
    WHILE           reduce using rule 81 (vars -> empty .)
    IF              reduce using rule 81 (vars -> empty .)
    RETURN          reduce using rule 81 (vars -> empty .)
    RCURLY          reduce using rule 81 (vars -> empty .)
    LCURLY          reduce using rule 81 (vars -> empty .)


state 11

    (6) program2 -> principal .

    $end            reduce using rule 6 (program2 -> principal .)


state 12

    (82) var -> VARS . var2
    (83) var2 -> . var2 type TWOPOINTS var1 SEMMICOLON addVar
    (84) var2 -> . empty
    (112) empty -> .

    INT             reduce using rule 112 (empty -> .)
    CHAR            reduce using rule 112 (empty -> .)
    FLOAT           reduce using rule 112 (empty -> .)
    FUNCTION        reduce using rule 112 (empty -> .)
    PRINCIPAL       reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)
    ID              reduce using rule 112 (empty -> .)
    READ            reduce using rule 112 (empty -> .)
    WRITE           reduce using rule 112 (empty -> .)
    FOR             reduce using rule 112 (empty -> .)
    WHILE           reduce using rule 112 (empty -> .)
    IF              reduce using rule 112 (empty -> .)
    RETURN          reduce using rule 112 (empty -> .)
    RCURLY          reduce using rule 112 (empty -> .)
    LCURLY          reduce using rule 112 (empty -> .)

    var2                           shift and go to state 17
    empty                          shift and go to state 18

state 13

    (7) principal -> PRINCIPAL . saveFunction LPAREN RPAREN LCURLY vars statements RCURLY
    (104) saveFunction -> .

    LPAREN          reduce using rule 104 (saveFunction -> .)

    saveFunction                   shift and go to state 19

state 14

    (3) program1 -> vars functions . program2
    (4) program1 -> vars functions .
    (6) program2 -> . principal
    (7) principal -> . PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY

    $end            reduce using rule 4 (program1 -> vars functions .)
    PRINCIPAL       shift and go to state 13

    program2                       shift and go to state 20
    principal                      shift and go to state 11

state 15

    (97) functions -> FUNCTION . INT functions1 functions
    (98) functions -> FUNCTION . CHAR functions1 functions
    (99) functions -> FUNCTION . FLOAT functions1 functions
    (100) functions -> FUNCTION . VOID functions1 functions

    INT             shift and go to state 21
    CHAR            shift and go to state 22
    FLOAT           shift and go to state 23
    VOID            shift and go to state 24


state 16

    (101) functions -> empty .

    PRINCIPAL       reduce using rule 101 (functions -> empty .)
    $end            reduce using rule 101 (functions -> empty .)


state 17

    (82) var -> VARS var2 .
    (83) var2 -> var2 . type TWOPOINTS var1 SEMMICOLON addVar
    (92) type -> . INT saveTypeVar
    (93) type -> . CHAR saveTypeVar
    (94) type -> . FLOAT saveTypeVar

    FUNCTION        reduce using rule 82 (var -> VARS var2 .)
    PRINCIPAL       reduce using rule 82 (var -> VARS var2 .)
    $end            reduce using rule 82 (var -> VARS var2 .)
    ID              reduce using rule 82 (var -> VARS var2 .)
    READ            reduce using rule 82 (var -> VARS var2 .)
    WRITE           reduce using rule 82 (var -> VARS var2 .)
    FOR             reduce using rule 82 (var -> VARS var2 .)
    WHILE           reduce using rule 82 (var -> VARS var2 .)
    IF              reduce using rule 82 (var -> VARS var2 .)
    RETURN          reduce using rule 82 (var -> VARS var2 .)
    RCURLY          reduce using rule 82 (var -> VARS var2 .)
    LCURLY          reduce using rule 82 (var -> VARS var2 .)
    INT             shift and go to state 26
    CHAR            shift and go to state 27
    FLOAT           shift and go to state 28

    type                           shift and go to state 25

state 18

    (84) var2 -> empty .

    INT             reduce using rule 84 (var2 -> empty .)
    CHAR            reduce using rule 84 (var2 -> empty .)
    FLOAT           reduce using rule 84 (var2 -> empty .)
    FUNCTION        reduce using rule 84 (var2 -> empty .)
    PRINCIPAL       reduce using rule 84 (var2 -> empty .)
    $end            reduce using rule 84 (var2 -> empty .)
    ID              reduce using rule 84 (var2 -> empty .)
    READ            reduce using rule 84 (var2 -> empty .)
    WRITE           reduce using rule 84 (var2 -> empty .)
    FOR             reduce using rule 84 (var2 -> empty .)
    WHILE           reduce using rule 84 (var2 -> empty .)
    IF              reduce using rule 84 (var2 -> empty .)
    RETURN          reduce using rule 84 (var2 -> empty .)
    RCURLY          reduce using rule 84 (var2 -> empty .)
    LCURLY          reduce using rule 84 (var2 -> empty .)


state 19

    (7) principal -> PRINCIPAL saveFunction . LPAREN RPAREN LCURLY vars statements RCURLY

    LPAREN          shift and go to state 29


state 20

    (3) program1 -> vars functions program2 .

    $end            reduce using rule 3 (program1 -> vars functions program2 .)


state 21

    (97) functions -> FUNCTION INT . functions1 functions
    (102) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (103) functions1 -> . empty
    (112) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 112 (empty -> .)
    PRINCIPAL       reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)

    functions1                     shift and go to state 30
    empty                          shift and go to state 32

state 22

    (98) functions -> FUNCTION CHAR . functions1 functions
    (102) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (103) functions1 -> . empty
    (112) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 112 (empty -> .)
    PRINCIPAL       reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)

    functions1                     shift and go to state 33
    empty                          shift and go to state 32

state 23

    (99) functions -> FUNCTION FLOAT . functions1 functions
    (102) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (103) functions1 -> . empty
    (112) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 112 (empty -> .)
    PRINCIPAL       reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)

    functions1                     shift and go to state 34
    empty                          shift and go to state 32

state 24

    (100) functions -> FUNCTION VOID . functions1 functions
    (102) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (103) functions1 -> . empty
    (112) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 112 (empty -> .)
    PRINCIPAL       reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)

    functions1                     shift and go to state 35
    empty                          shift and go to state 32

state 25

    (83) var2 -> var2 type . TWOPOINTS var1 SEMMICOLON addVar

    TWOPOINTS       shift and go to state 36


state 26

    (92) type -> INT . saveTypeVar
    (91) saveTypeVar -> .

    TWOPOINTS       reduce using rule 91 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 37

state 27

    (93) type -> CHAR . saveTypeVar
    (91) saveTypeVar -> .

    TWOPOINTS       reduce using rule 91 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 38

state 28

    (94) type -> FLOAT . saveTypeVar
    (91) saveTypeVar -> .

    TWOPOINTS       reduce using rule 91 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 39

state 29

    (7) principal -> PRINCIPAL saveFunction LPAREN . RPAREN LCURLY vars statements RCURLY

    RPAREN          shift and go to state 40


state 30

    (97) functions -> FUNCTION INT functions1 . functions
    (97) functions -> . FUNCTION INT functions1 functions
    (98) functions -> . FUNCTION CHAR functions1 functions
    (99) functions -> . FUNCTION FLOAT functions1 functions
    (100) functions -> . FUNCTION VOID functions1 functions
    (101) functions -> . empty
    (112) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)

    functions                      shift and go to state 41
    empty                          shift and go to state 16

state 31

    (102) functions1 -> ID . saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY
    (104) saveFunction -> .

    LPAREN          reduce using rule 104 (saveFunction -> .)

    saveFunction                   shift and go to state 42

state 32

    (103) functions1 -> empty .

    FUNCTION        reduce using rule 103 (functions1 -> empty .)
    PRINCIPAL       reduce using rule 103 (functions1 -> empty .)
    $end            reduce using rule 103 (functions1 -> empty .)


state 33

    (98) functions -> FUNCTION CHAR functions1 . functions
    (97) functions -> . FUNCTION INT functions1 functions
    (98) functions -> . FUNCTION CHAR functions1 functions
    (99) functions -> . FUNCTION FLOAT functions1 functions
    (100) functions -> . FUNCTION VOID functions1 functions
    (101) functions -> . empty
    (112) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)

    functions                      shift and go to state 43
    empty                          shift and go to state 16

state 34

    (99) functions -> FUNCTION FLOAT functions1 . functions
    (97) functions -> . FUNCTION INT functions1 functions
    (98) functions -> . FUNCTION CHAR functions1 functions
    (99) functions -> . FUNCTION FLOAT functions1 functions
    (100) functions -> . FUNCTION VOID functions1 functions
    (101) functions -> . empty
    (112) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)

    functions                      shift and go to state 44
    empty                          shift and go to state 16

state 35

    (100) functions -> FUNCTION VOID functions1 . functions
    (97) functions -> . FUNCTION INT functions1 functions
    (98) functions -> . FUNCTION CHAR functions1 functions
    (99) functions -> . FUNCTION FLOAT functions1 functions
    (100) functions -> . FUNCTION VOID functions1 functions
    (101) functions -> . empty
    (112) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 112 (empty -> .)
    $end            reduce using rule 112 (empty -> .)

    functions                      shift and go to state 45
    empty                          shift and go to state 16

state 36

    (83) var2 -> var2 type TWOPOINTS . var1 SEMMICOLON addVar
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (112) empty -> .

    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 112 (empty -> .)

    var1                           shift and go to state 46
    empty                          shift and go to state 48

state 37

    (92) type -> INT saveTypeVar .

    TWOPOINTS       reduce using rule 92 (type -> INT saveTypeVar .)


state 38

    (93) type -> CHAR saveTypeVar .

    TWOPOINTS       reduce using rule 93 (type -> CHAR saveTypeVar .)


state 39

    (94) type -> FLOAT saveTypeVar .

    TWOPOINTS       reduce using rule 94 (type -> FLOAT saveTypeVar .)


state 40

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN . LCURLY vars statements RCURLY

    LCURLY          shift and go to state 49


state 41

    (97) functions -> FUNCTION INT functions1 functions .

    PRINCIPAL       reduce using rule 97 (functions -> FUNCTION INT functions1 functions .)
    $end            reduce using rule 97 (functions -> FUNCTION INT functions1 functions .)


state 42

    (102) functions1 -> ID saveFunction . LPAREN args RPAREN vars LCURLY statements RCURLY

    LPAREN          shift and go to state 50


state 43

    (98) functions -> FUNCTION CHAR functions1 functions .

    PRINCIPAL       reduce using rule 98 (functions -> FUNCTION CHAR functions1 functions .)
    $end            reduce using rule 98 (functions -> FUNCTION CHAR functions1 functions .)


state 44

    (99) functions -> FUNCTION FLOAT functions1 functions .

    PRINCIPAL       reduce using rule 99 (functions -> FUNCTION FLOAT functions1 functions .)
    $end            reduce using rule 99 (functions -> FUNCTION FLOAT functions1 functions .)


state 45

    (100) functions -> FUNCTION VOID functions1 functions .

    PRINCIPAL       reduce using rule 100 (functions -> FUNCTION VOID functions1 functions .)
    $end            reduce using rule 100 (functions -> FUNCTION VOID functions1 functions .)


state 46

    (83) var2 -> var2 type TWOPOINTS var1 . SEMMICOLON addVar

    SEMMICOLON      shift and go to state 51


state 47

    (85) var1 -> ID .
    (86) var1 -> ID . COMMA var1 addVar
    (87) var1 -> ID . arr
    (88) var1 -> ID . arr COMMA var1 addVar
    (95) arr -> . LBRACKET CTEI RBRACKET
    (96) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 85 (var1 -> ID .)
    MUL             reduce using rule 85 (var1 -> ID .)
    DIV             reduce using rule 85 (var1 -> ID .)
    PLUS            reduce using rule 85 (var1 -> ID .)
    MINUS           reduce using rule 85 (var1 -> ID .)
    GT              reduce using rule 85 (var1 -> ID .)
    LT              reduce using rule 85 (var1 -> ID .)
    GTE             reduce using rule 85 (var1 -> ID .)
    LTE             reduce using rule 85 (var1 -> ID .)
    NE              reduce using rule 85 (var1 -> ID .)
    AND             reduce using rule 85 (var1 -> ID .)
    OR              reduce using rule 85 (var1 -> ID .)
    RBRACKET        reduce using rule 85 (var1 -> ID .)
    RPAREN          reduce using rule 85 (var1 -> ID .)
    TO              reduce using rule 85 (var1 -> ID .)
    INT             reduce using rule 85 (var1 -> ID .)
    CHAR            reduce using rule 85 (var1 -> ID .)
    FLOAT           reduce using rule 85 (var1 -> ID .)
    CTEI            reduce using rule 85 (var1 -> ID .)
    CTEF            reduce using rule 85 (var1 -> ID .)
    CTEC            reduce using rule 85 (var1 -> ID .)
    CTESTRING       reduce using rule 85 (var1 -> ID .)
    LPAREN          reduce using rule 85 (var1 -> ID .)
    ID              reduce using rule 85 (var1 -> ID .)
    COMMA           shift and go to state 52
    LBRACKET        shift and go to state 54

  ! COMMA           [ reduce using rule 85 (var1 -> ID .) ]

    arr                            shift and go to state 53

state 48

    (89) var1 -> empty .

    SEMMICOLON      reduce using rule 89 (var1 -> empty .)
    MUL             reduce using rule 89 (var1 -> empty .)
    DIV             reduce using rule 89 (var1 -> empty .)
    PLUS            reduce using rule 89 (var1 -> empty .)
    MINUS           reduce using rule 89 (var1 -> empty .)
    GT              reduce using rule 89 (var1 -> empty .)
    LT              reduce using rule 89 (var1 -> empty .)
    GTE             reduce using rule 89 (var1 -> empty .)
    LTE             reduce using rule 89 (var1 -> empty .)
    NE              reduce using rule 89 (var1 -> empty .)
    AND             reduce using rule 89 (var1 -> empty .)
    OR              reduce using rule 89 (var1 -> empty .)
    RBRACKET        reduce using rule 89 (var1 -> empty .)
    RPAREN          reduce using rule 89 (var1 -> empty .)
    COMMA           reduce using rule 89 (var1 -> empty .)
    TO              reduce using rule 89 (var1 -> empty .)
    INT             reduce using rule 89 (var1 -> empty .)
    CHAR            reduce using rule 89 (var1 -> empty .)
    FLOAT           reduce using rule 89 (var1 -> empty .)
    CTEI            reduce using rule 89 (var1 -> empty .)
    CTEF            reduce using rule 89 (var1 -> empty .)
    CTEC            reduce using rule 89 (var1 -> empty .)
    CTESTRING       reduce using rule 89 (var1 -> empty .)
    LPAREN          reduce using rule 89 (var1 -> empty .)
    ID              reduce using rule 89 (var1 -> empty .)


state 49

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY . vars statements RCURLY
    (80) vars -> . var
    (81) vars -> . empty
    (82) var -> . VARS var2
    (112) empty -> .

    VARS            shift and go to state 12
    ID              reduce using rule 112 (empty -> .)
    READ            reduce using rule 112 (empty -> .)
    WRITE           reduce using rule 112 (empty -> .)
    FOR             reduce using rule 112 (empty -> .)
    WHILE           reduce using rule 112 (empty -> .)
    IF              reduce using rule 112 (empty -> .)
    RETURN          reduce using rule 112 (empty -> .)
    RCURLY          reduce using rule 112 (empty -> .)

    vars                           shift and go to state 55
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 50

    (102) functions1 -> ID saveFunction LPAREN . args RPAREN vars LCURLY statements RCURLY
    (105) args -> . args type TWOPOINTS var1 addVar
    (106) args -> . empty
    (112) empty -> .

    RPAREN          reduce using rule 112 (empty -> .)
    INT             reduce using rule 112 (empty -> .)
    CHAR            reduce using rule 112 (empty -> .)
    FLOAT           reduce using rule 112 (empty -> .)

    args                           shift and go to state 56
    empty                          shift and go to state 57

state 51

    (83) var2 -> var2 type TWOPOINTS var1 SEMMICOLON . addVar
    (90) addVar -> .

    INT             reduce using rule 90 (addVar -> .)
    CHAR            reduce using rule 90 (addVar -> .)
    FLOAT           reduce using rule 90 (addVar -> .)
    FUNCTION        reduce using rule 90 (addVar -> .)
    PRINCIPAL       reduce using rule 90 (addVar -> .)
    $end            reduce using rule 90 (addVar -> .)
    ID              reduce using rule 90 (addVar -> .)
    READ            reduce using rule 90 (addVar -> .)
    WRITE           reduce using rule 90 (addVar -> .)
    FOR             reduce using rule 90 (addVar -> .)
    WHILE           reduce using rule 90 (addVar -> .)
    IF              reduce using rule 90 (addVar -> .)
    RETURN          reduce using rule 90 (addVar -> .)
    RCURLY          reduce using rule 90 (addVar -> .)
    LCURLY          reduce using rule 90 (addVar -> .)

    addVar                         shift and go to state 58

state 52

    (86) var1 -> ID COMMA . var1 addVar
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (112) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 112 (empty -> .)
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)
    INT             reduce using rule 112 (empty -> .)
    CHAR            reduce using rule 112 (empty -> .)
    FLOAT           reduce using rule 112 (empty -> .)
    CTEI            reduce using rule 112 (empty -> .)
    CTEF            reduce using rule 112 (empty -> .)
    CTEC            reduce using rule 112 (empty -> .)
    CTESTRING       reduce using rule 112 (empty -> .)
    LPAREN          reduce using rule 112 (empty -> .)

  ! ID              [ reduce using rule 112 (empty -> .) ]

    var1                           shift and go to state 59
    empty                          shift and go to state 48

state 53

    (87) var1 -> ID arr .
    (88) var1 -> ID arr . COMMA var1 addVar

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 87 (var1 -> ID arr .)
    MUL             reduce using rule 87 (var1 -> ID arr .)
    DIV             reduce using rule 87 (var1 -> ID arr .)
    PLUS            reduce using rule 87 (var1 -> ID arr .)
    MINUS           reduce using rule 87 (var1 -> ID arr .)
    GT              reduce using rule 87 (var1 -> ID arr .)
    LT              reduce using rule 87 (var1 -> ID arr .)
    GTE             reduce using rule 87 (var1 -> ID arr .)
    LTE             reduce using rule 87 (var1 -> ID arr .)
    NE              reduce using rule 87 (var1 -> ID arr .)
    AND             reduce using rule 87 (var1 -> ID arr .)
    OR              reduce using rule 87 (var1 -> ID arr .)
    RBRACKET        reduce using rule 87 (var1 -> ID arr .)
    RPAREN          reduce using rule 87 (var1 -> ID arr .)
    TO              reduce using rule 87 (var1 -> ID arr .)
    INT             reduce using rule 87 (var1 -> ID arr .)
    CHAR            reduce using rule 87 (var1 -> ID arr .)
    FLOAT           reduce using rule 87 (var1 -> ID arr .)
    CTEI            reduce using rule 87 (var1 -> ID arr .)
    CTEF            reduce using rule 87 (var1 -> ID arr .)
    CTEC            reduce using rule 87 (var1 -> ID arr .)
    CTESTRING       reduce using rule 87 (var1 -> ID arr .)
    LPAREN          reduce using rule 87 (var1 -> ID arr .)
    ID              reduce using rule 87 (var1 -> ID arr .)
    COMMA           shift and go to state 60

  ! COMMA           [ reduce using rule 87 (var1 -> ID arr .) ]


state 54

    (95) arr -> LBRACKET . CTEI RBRACKET
    (96) arr -> LBRACKET . exp RBRACKET
    (55) exp -> . nexp generateQuadOR
    (56) exp -> . nexp generateQuadOR OR saveOperator nexp
    (57) nexp -> . compexp generateQuadAND
    (58) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    CTEI            shift and go to state 61
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)

    exp                            shift and go to state 62
    nexp                           shift and go to state 63
    compexp                        shift and go to state 64
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 55

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)

    statements                     shift and go to state 76
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 56

    (102) functions1 -> ID saveFunction LPAREN args . RPAREN vars LCURLY statements RCURLY
    (105) args -> args . type TWOPOINTS var1 addVar
    (92) type -> . INT saveTypeVar
    (93) type -> . CHAR saveTypeVar
    (94) type -> . FLOAT saveTypeVar

    RPAREN          shift and go to state 93
    INT             shift and go to state 26
    CHAR            shift and go to state 27
    FLOAT           shift and go to state 28

    type                           shift and go to state 94

state 57

    (106) args -> empty .

    RPAREN          reduce using rule 106 (args -> empty .)
    INT             reduce using rule 106 (args -> empty .)
    CHAR            reduce using rule 106 (args -> empty .)
    FLOAT           reduce using rule 106 (args -> empty .)


state 58

    (83) var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .

    INT             reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    CHAR            reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FLOAT           reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FUNCTION        reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    PRINCIPAL       reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    $end            reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    ID              reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    READ            reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WRITE           reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FOR             reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WHILE           reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    IF              reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    RETURN          reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    RCURLY          reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    LCURLY          reduce using rule 83 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)


state 59

    (86) var1 -> ID COMMA var1 . addVar
    (90) addVar -> .

    SEMMICOLON      reduce using rule 90 (addVar -> .)
    MUL             reduce using rule 90 (addVar -> .)
    DIV             reduce using rule 90 (addVar -> .)
    PLUS            reduce using rule 90 (addVar -> .)
    MINUS           reduce using rule 90 (addVar -> .)
    GT              reduce using rule 90 (addVar -> .)
    LT              reduce using rule 90 (addVar -> .)
    GTE             reduce using rule 90 (addVar -> .)
    LTE             reduce using rule 90 (addVar -> .)
    NE              reduce using rule 90 (addVar -> .)
    AND             reduce using rule 90 (addVar -> .)
    OR              reduce using rule 90 (addVar -> .)
    RBRACKET        reduce using rule 90 (addVar -> .)
    RPAREN          reduce using rule 90 (addVar -> .)
    COMMA           reduce using rule 90 (addVar -> .)
    TO              reduce using rule 90 (addVar -> .)
    INT             reduce using rule 90 (addVar -> .)
    CHAR            reduce using rule 90 (addVar -> .)
    FLOAT           reduce using rule 90 (addVar -> .)
    CTEI            reduce using rule 90 (addVar -> .)
    CTEF            reduce using rule 90 (addVar -> .)
    CTEC            reduce using rule 90 (addVar -> .)
    CTESTRING       reduce using rule 90 (addVar -> .)
    LPAREN          reduce using rule 90 (addVar -> .)
    ID              reduce using rule 90 (addVar -> .)

    addVar                         shift and go to state 95

state 60

    (88) var1 -> ID arr COMMA . var1 addVar
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (112) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 112 (empty -> .)
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)
    INT             reduce using rule 112 (empty -> .)
    CHAR            reduce using rule 112 (empty -> .)
    FLOAT           reduce using rule 112 (empty -> .)
    CTEI            reduce using rule 112 (empty -> .)
    CTEF            reduce using rule 112 (empty -> .)
    CTEC            reduce using rule 112 (empty -> .)
    CTESTRING       reduce using rule 112 (empty -> .)
    LPAREN          reduce using rule 112 (empty -> .)

  ! ID              [ reduce using rule 112 (empty -> .) ]

    var1                           shift and go to state 96
    empty                          shift and go to state 48

state 61

    (95) arr -> LBRACKET CTEI . RBRACKET
    (73) pexp -> CTEI . saveCTE
    (54) saveCTE -> .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 97
    MUL             reduce using rule 54 (saveCTE -> .)
    DIV             reduce using rule 54 (saveCTE -> .)
    PLUS            reduce using rule 54 (saveCTE -> .)
    MINUS           reduce using rule 54 (saveCTE -> .)
    GT              reduce using rule 54 (saveCTE -> .)
    LT              reduce using rule 54 (saveCTE -> .)
    GTE             reduce using rule 54 (saveCTE -> .)
    LTE             reduce using rule 54 (saveCTE -> .)
    NE              reduce using rule 54 (saveCTE -> .)
    AND             reduce using rule 54 (saveCTE -> .)
    OR              reduce using rule 54 (saveCTE -> .)

  ! RBRACKET        [ reduce using rule 54 (saveCTE -> .) ]

    saveCTE                        shift and go to state 98

state 62

    (96) arr -> LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 99


state 63

    (55) exp -> nexp . generateQuadOR
    (56) exp -> nexp . generateQuadOR OR saveOperator nexp
    (44) generateQuadOR -> .

    OR              reduce using rule 44 (generateQuadOR -> .)
    RBRACKET        reduce using rule 44 (generateQuadOR -> .)
    RPAREN          reduce using rule 44 (generateQuadOR -> .)
    COMMA           reduce using rule 44 (generateQuadOR -> .)
    SEMMICOLON      reduce using rule 44 (generateQuadOR -> .)
    TO              reduce using rule 44 (generateQuadOR -> .)

    generateQuadOR                 shift and go to state 100

state 64

    (57) nexp -> compexp . generateQuadAND
    (58) nexp -> compexp . generateQuadAND AND saveOperator compexp
    (45) generateQuadAND -> .

    AND             reduce using rule 45 (generateQuadAND -> .)
    OR              reduce using rule 45 (generateQuadAND -> .)
    RBRACKET        reduce using rule 45 (generateQuadAND -> .)
    RPAREN          reduce using rule 45 (generateQuadAND -> .)
    COMMA           reduce using rule 45 (generateQuadAND -> .)
    SEMMICOLON      reduce using rule 45 (generateQuadAND -> .)
    TO              reduce using rule 45 (generateQuadAND -> .)

    generateQuadAND                shift and go to state 101

state 65

    (59) compexp -> sumexp .
    (61) compexp1 -> sumexp . GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> sumexp . LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> sumexp . GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> sumexp . LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> sumexp . NE saveOperator sumexp generateQuadCOMPARE

    AND             reduce using rule 59 (compexp -> sumexp .)
    OR              reduce using rule 59 (compexp -> sumexp .)
    RBRACKET        reduce using rule 59 (compexp -> sumexp .)
    RPAREN          reduce using rule 59 (compexp -> sumexp .)
    COMMA           reduce using rule 59 (compexp -> sumexp .)
    SEMMICOLON      reduce using rule 59 (compexp -> sumexp .)
    TO              reduce using rule 59 (compexp -> sumexp .)
    GT              shift and go to state 102
    LT              shift and go to state 103
    GTE             shift and go to state 104
    LTE             shift and go to state 105
    NE              shift and go to state 106


state 66

    (60) compexp -> compexp1 . sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)

    sumexp                         shift and go to state 107
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 67

    (66) sumexp -> mulexp .
    (67) sumexp -> mulexp . PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> mulexp . MINUS saveOperator mulexp generateQuadSUM

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    GT              reduce using rule 66 (sumexp -> mulexp .)
    LT              reduce using rule 66 (sumexp -> mulexp .)
    GTE             reduce using rule 66 (sumexp -> mulexp .)
    LTE             reduce using rule 66 (sumexp -> mulexp .)
    NE              reduce using rule 66 (sumexp -> mulexp .)
    AND             reduce using rule 66 (sumexp -> mulexp .)
    OR              reduce using rule 66 (sumexp -> mulexp .)
    RBRACKET        reduce using rule 66 (sumexp -> mulexp .)
    RPAREN          reduce using rule 66 (sumexp -> mulexp .)
    COMMA           reduce using rule 66 (sumexp -> mulexp .)
    SEMMICOLON      reduce using rule 66 (sumexp -> mulexp .)
    TO              reduce using rule 66 (sumexp -> mulexp .)
    CTEI            reduce using rule 66 (sumexp -> mulexp .)
    CTEF            reduce using rule 66 (sumexp -> mulexp .)
    CTEC            reduce using rule 66 (sumexp -> mulexp .)
    CTESTRING       reduce using rule 66 (sumexp -> mulexp .)
    LPAREN          reduce using rule 66 (sumexp -> mulexp .)
    ID              reduce using rule 66 (sumexp -> mulexp .)
    MUL             reduce using rule 66 (sumexp -> mulexp .)
    DIV             reduce using rule 66 (sumexp -> mulexp .)
    PLUS            shift and go to state 109
    MINUS           shift and go to state 110

  ! PLUS            [ reduce using rule 66 (sumexp -> mulexp .) ]
  ! MINUS           [ reduce using rule 66 (sumexp -> mulexp .) ]


state 68

    (69) mulexp -> pexp .
    (70) mulexp -> pexp . MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> pexp . DIV saveOperator pexp generateQuadMUL

  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    PLUS            reduce using rule 69 (mulexp -> pexp .)
    MINUS           reduce using rule 69 (mulexp -> pexp .)
    GT              reduce using rule 69 (mulexp -> pexp .)
    LT              reduce using rule 69 (mulexp -> pexp .)
    GTE             reduce using rule 69 (mulexp -> pexp .)
    LTE             reduce using rule 69 (mulexp -> pexp .)
    NE              reduce using rule 69 (mulexp -> pexp .)
    AND             reduce using rule 69 (mulexp -> pexp .)
    OR              reduce using rule 69 (mulexp -> pexp .)
    RBRACKET        reduce using rule 69 (mulexp -> pexp .)
    RPAREN          reduce using rule 69 (mulexp -> pexp .)
    COMMA           reduce using rule 69 (mulexp -> pexp .)
    SEMMICOLON      reduce using rule 69 (mulexp -> pexp .)
    TO              reduce using rule 69 (mulexp -> pexp .)
    CTEI            reduce using rule 69 (mulexp -> pexp .)
    CTEF            reduce using rule 69 (mulexp -> pexp .)
    CTEC            reduce using rule 69 (mulexp -> pexp .)
    CTESTRING       reduce using rule 69 (mulexp -> pexp .)
    LPAREN          reduce using rule 69 (mulexp -> pexp .)
    ID              reduce using rule 69 (mulexp -> pexp .)
    MUL             shift and go to state 111
    DIV             shift and go to state 112

  ! MUL             [ reduce using rule 69 (mulexp -> pexp .) ]
  ! DIV             [ reduce using rule 69 (mulexp -> pexp .) ]


state 69

    (72) pexp -> var1 . add_id
    (20) add_id -> .

    MUL             reduce using rule 20 (add_id -> .)
    DIV             reduce using rule 20 (add_id -> .)
    PLUS            reduce using rule 20 (add_id -> .)
    MINUS           reduce using rule 20 (add_id -> .)
    GT              reduce using rule 20 (add_id -> .)
    LT              reduce using rule 20 (add_id -> .)
    GTE             reduce using rule 20 (add_id -> .)
    LTE             reduce using rule 20 (add_id -> .)
    NE              reduce using rule 20 (add_id -> .)
    AND             reduce using rule 20 (add_id -> .)
    OR              reduce using rule 20 (add_id -> .)
    RBRACKET        reduce using rule 20 (add_id -> .)
    RPAREN          reduce using rule 20 (add_id -> .)
    COMMA           reduce using rule 20 (add_id -> .)
    SEMMICOLON      reduce using rule 20 (add_id -> .)
    TO              reduce using rule 20 (add_id -> .)
    CTEI            reduce using rule 20 (add_id -> .)
    CTEF            reduce using rule 20 (add_id -> .)
    CTEC            reduce using rule 20 (add_id -> .)
    CTESTRING       reduce using rule 20 (add_id -> .)
    LPAREN          reduce using rule 20 (add_id -> .)
    ID              reduce using rule 20 (add_id -> .)

    add_id                         shift and go to state 113

state 70

    (74) pexp -> CTEF . saveCTE
    (54) saveCTE -> .

    MUL             reduce using rule 54 (saveCTE -> .)
    DIV             reduce using rule 54 (saveCTE -> .)
    PLUS            reduce using rule 54 (saveCTE -> .)
    MINUS           reduce using rule 54 (saveCTE -> .)
    GT              reduce using rule 54 (saveCTE -> .)
    LT              reduce using rule 54 (saveCTE -> .)
    GTE             reduce using rule 54 (saveCTE -> .)
    LTE             reduce using rule 54 (saveCTE -> .)
    NE              reduce using rule 54 (saveCTE -> .)
    AND             reduce using rule 54 (saveCTE -> .)
    OR              reduce using rule 54 (saveCTE -> .)
    RBRACKET        reduce using rule 54 (saveCTE -> .)
    RPAREN          reduce using rule 54 (saveCTE -> .)
    COMMA           reduce using rule 54 (saveCTE -> .)
    SEMMICOLON      reduce using rule 54 (saveCTE -> .)
    TO              reduce using rule 54 (saveCTE -> .)
    CTEI            reduce using rule 54 (saveCTE -> .)
    CTEF            reduce using rule 54 (saveCTE -> .)
    CTEC            reduce using rule 54 (saveCTE -> .)
    CTESTRING       reduce using rule 54 (saveCTE -> .)
    LPAREN          reduce using rule 54 (saveCTE -> .)
    ID              reduce using rule 54 (saveCTE -> .)

    saveCTE                        shift and go to state 114

state 71

    (75) pexp -> CTEC . saveCTE
    (54) saveCTE -> .

    MUL             reduce using rule 54 (saveCTE -> .)
    DIV             reduce using rule 54 (saveCTE -> .)
    PLUS            reduce using rule 54 (saveCTE -> .)
    MINUS           reduce using rule 54 (saveCTE -> .)
    GT              reduce using rule 54 (saveCTE -> .)
    LT              reduce using rule 54 (saveCTE -> .)
    GTE             reduce using rule 54 (saveCTE -> .)
    LTE             reduce using rule 54 (saveCTE -> .)
    NE              reduce using rule 54 (saveCTE -> .)
    AND             reduce using rule 54 (saveCTE -> .)
    OR              reduce using rule 54 (saveCTE -> .)
    RBRACKET        reduce using rule 54 (saveCTE -> .)
    RPAREN          reduce using rule 54 (saveCTE -> .)
    COMMA           reduce using rule 54 (saveCTE -> .)
    SEMMICOLON      reduce using rule 54 (saveCTE -> .)
    TO              reduce using rule 54 (saveCTE -> .)
    CTEI            reduce using rule 54 (saveCTE -> .)
    CTEF            reduce using rule 54 (saveCTE -> .)
    CTEC            reduce using rule 54 (saveCTE -> .)
    CTESTRING       reduce using rule 54 (saveCTE -> .)
    LPAREN          reduce using rule 54 (saveCTE -> .)
    ID              reduce using rule 54 (saveCTE -> .)

    saveCTE                        shift and go to state 115

state 72

    (76) pexp -> CTESTRING . saveCTE
    (54) saveCTE -> .

    MUL             reduce using rule 54 (saveCTE -> .)
    DIV             reduce using rule 54 (saveCTE -> .)
    PLUS            reduce using rule 54 (saveCTE -> .)
    MINUS           reduce using rule 54 (saveCTE -> .)
    GT              reduce using rule 54 (saveCTE -> .)
    LT              reduce using rule 54 (saveCTE -> .)
    GTE             reduce using rule 54 (saveCTE -> .)
    LTE             reduce using rule 54 (saveCTE -> .)
    NE              reduce using rule 54 (saveCTE -> .)
    AND             reduce using rule 54 (saveCTE -> .)
    OR              reduce using rule 54 (saveCTE -> .)
    RBRACKET        reduce using rule 54 (saveCTE -> .)
    RPAREN          reduce using rule 54 (saveCTE -> .)
    COMMA           reduce using rule 54 (saveCTE -> .)
    SEMMICOLON      reduce using rule 54 (saveCTE -> .)
    TO              reduce using rule 54 (saveCTE -> .)
    CTEI            reduce using rule 54 (saveCTE -> .)
    CTEF            reduce using rule 54 (saveCTE -> .)
    CTEC            reduce using rule 54 (saveCTE -> .)
    CTESTRING       reduce using rule 54 (saveCTE -> .)
    LPAREN          reduce using rule 54 (saveCTE -> .)
    ID              reduce using rule 54 (saveCTE -> .)

    saveCTE                        shift and go to state 116

state 73

    (77) pexp -> functionCall .

    MUL             reduce using rule 77 (pexp -> functionCall .)
    DIV             reduce using rule 77 (pexp -> functionCall .)
    PLUS            reduce using rule 77 (pexp -> functionCall .)
    MINUS           reduce using rule 77 (pexp -> functionCall .)
    GT              reduce using rule 77 (pexp -> functionCall .)
    LT              reduce using rule 77 (pexp -> functionCall .)
    GTE             reduce using rule 77 (pexp -> functionCall .)
    LTE             reduce using rule 77 (pexp -> functionCall .)
    NE              reduce using rule 77 (pexp -> functionCall .)
    AND             reduce using rule 77 (pexp -> functionCall .)
    OR              reduce using rule 77 (pexp -> functionCall .)
    RBRACKET        reduce using rule 77 (pexp -> functionCall .)
    RPAREN          reduce using rule 77 (pexp -> functionCall .)
    COMMA           reduce using rule 77 (pexp -> functionCall .)
    SEMMICOLON      reduce using rule 77 (pexp -> functionCall .)
    TO              reduce using rule 77 (pexp -> functionCall .)
    CTEI            reduce using rule 77 (pexp -> functionCall .)
    CTEF            reduce using rule 77 (pexp -> functionCall .)
    CTEC            reduce using rule 77 (pexp -> functionCall .)
    CTESTRING       reduce using rule 77 (pexp -> functionCall .)
    LPAREN          reduce using rule 77 (pexp -> functionCall .)
    ID              reduce using rule 77 (pexp -> functionCall .)


state 74

    (78) pexp -> LPAREN . exp RPAREN
    (55) exp -> . nexp generateQuadOR
    (56) exp -> . nexp generateQuadOR OR saveOperator nexp
    (57) nexp -> . compexp generateQuadAND
    (58) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)

    exp                            shift and go to state 117
    nexp                           shift and go to state 63
    compexp                        shift and go to state 64
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 75

    (85) var1 -> ID .
    (86) var1 -> ID . COMMA var1 addVar
    (87) var1 -> ID . arr
    (88) var1 -> ID . arr COMMA var1 addVar
    (22) functionCall -> ID . LPAREN exp RPAREN
    (95) arr -> . LBRACKET CTEI RBRACKET
    (96) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    MUL             reduce using rule 85 (var1 -> ID .)
    DIV             reduce using rule 85 (var1 -> ID .)
    PLUS            reduce using rule 85 (var1 -> ID .)
    MINUS           reduce using rule 85 (var1 -> ID .)
    GT              reduce using rule 85 (var1 -> ID .)
    LT              reduce using rule 85 (var1 -> ID .)
    GTE             reduce using rule 85 (var1 -> ID .)
    LTE             reduce using rule 85 (var1 -> ID .)
    NE              reduce using rule 85 (var1 -> ID .)
    AND             reduce using rule 85 (var1 -> ID .)
    OR              reduce using rule 85 (var1 -> ID .)
    RBRACKET        reduce using rule 85 (var1 -> ID .)
    RPAREN          reduce using rule 85 (var1 -> ID .)
    SEMMICOLON      reduce using rule 85 (var1 -> ID .)
    TO              reduce using rule 85 (var1 -> ID .)
    CTEI            reduce using rule 85 (var1 -> ID .)
    CTEF            reduce using rule 85 (var1 -> ID .)
    CTEC            reduce using rule 85 (var1 -> ID .)
    CTESTRING       reduce using rule 85 (var1 -> ID .)
    ID              reduce using rule 85 (var1 -> ID .)
    COMMA           shift and go to state 52
    LPAREN          shift and go to state 118
    LBRACKET        shift and go to state 54

  ! COMMA           [ reduce using rule 85 (var1 -> ID .) ]
  ! LPAREN          [ reduce using rule 85 (var1 -> ID .) ]

    arr                            shift and go to state 53

state 76

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements . RCURLY

    RCURLY          shift and go to state 119


state 77

    (8) statements -> assign . SEMMICOLON statements

    SEMMICOLON      shift and go to state 120


state 78

    (9) statements -> functionCall . SEMMICOLON statements

    SEMMICOLON      shift and go to state 121


state 79

    (10) statements -> read . statements SEMMICOLON statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    SEMMICOLON      reduce using rule 112 (empty -> .)

    read                           shift and go to state 79
    statements                     shift and go to state 122
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 80

    (11) statements -> write . statements SEMMICOLON statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    SEMMICOLON      reduce using rule 112 (empty -> .)

    write                          shift and go to state 80
    statements                     shift and go to state 123
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 81

    (12) statements -> for . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)

    for                            shift and go to state 81
    statements                     shift and go to state 124
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 82

    (13) statements -> while . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)

    while                          shift and go to state 82
    statements                     shift and go to state 125
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    for                            shift and go to state 81
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 83

    (14) statements -> if . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)

    if                             shift and go to state 83
    statements                     shift and go to state 126
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 84

    (15) statements -> return . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)

    return                         shift and go to state 84
    statements                     shift and go to state 127
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    empty                          shift and go to state 85

state 85

    (16) statements -> empty .

    RCURLY          reduce using rule 16 (statements -> empty .)
    SEMMICOLON      reduce using rule 16 (statements -> empty .)


state 86

    (17) assign -> ID . add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> ID . add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> ID . LPAREN exp RPAREN
    (21) add_id2 -> .

    LPAREN          shift and go to state 118
    EQUALS          reduce using rule 21 (add_id2 -> .)
    LBRACKET        reduce using rule 21 (add_id2 -> .)

    add_id2                        shift and go to state 128

state 87

    (23) read -> READ . operatorRead LPAREN var1 generateQuadREAD RPAREN
    (24) operatorRead -> .

    LPAREN          reduce using rule 24 (operatorRead -> .)

    operatorRead                   shift and go to state 129

state 88

    (26) write -> WRITE . LPAREN writeOperator write1 generateQuadPRINT RPAREN

    LPAREN          shift and go to state 130


state 89

    (34) for -> FOR . forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (35) forOP -> .

    ID              reduce using rule 35 (forOP -> .)

    forOP                          shift and go to state 131

state 90

    (38) while -> WHILE . whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (39) whileOP -> .

    LPAREN          reduce using rule 39 (whileOP -> .)

    whileOP                        shift and go to state 132

state 91

    (41) if -> IF . LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF

    LPAREN          shift and go to state 133


state 92

    (110) return -> RETURN . LPAREN exp RPAREN SEMMICOLON
    (111) return -> RETURN . LPAREN exp RPAREN

    LPAREN          shift and go to state 134


state 93

    (102) functions1 -> ID saveFunction LPAREN args RPAREN . vars LCURLY statements RCURLY
    (80) vars -> . var
    (81) vars -> . empty
    (82) var -> . VARS var2
    (112) empty -> .

    VARS            shift and go to state 12
    LCURLY          reduce using rule 112 (empty -> .)

    vars                           shift and go to state 135
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 94

    (105) args -> args type . TWOPOINTS var1 addVar

    TWOPOINTS       shift and go to state 136


state 95

    (86) var1 -> ID COMMA var1 addVar .

    SEMMICOLON      reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    MUL             reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    DIV             reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    PLUS            reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    MINUS           reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    GT              reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    LT              reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    GTE             reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    LTE             reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    NE              reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    AND             reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    OR              reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    RBRACKET        reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    RPAREN          reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    COMMA           reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    TO              reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    INT             reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    CHAR            reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    FLOAT           reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    CTEI            reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    CTEF            reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    CTEC            reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    CTESTRING       reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    LPAREN          reduce using rule 86 (var1 -> ID COMMA var1 addVar .)
    ID              reduce using rule 86 (var1 -> ID COMMA var1 addVar .)


state 96

    (88) var1 -> ID arr COMMA var1 . addVar
    (90) addVar -> .

    SEMMICOLON      reduce using rule 90 (addVar -> .)
    MUL             reduce using rule 90 (addVar -> .)
    DIV             reduce using rule 90 (addVar -> .)
    PLUS            reduce using rule 90 (addVar -> .)
    MINUS           reduce using rule 90 (addVar -> .)
    GT              reduce using rule 90 (addVar -> .)
    LT              reduce using rule 90 (addVar -> .)
    GTE             reduce using rule 90 (addVar -> .)
    LTE             reduce using rule 90 (addVar -> .)
    NE              reduce using rule 90 (addVar -> .)
    AND             reduce using rule 90 (addVar -> .)
    OR              reduce using rule 90 (addVar -> .)
    RBRACKET        reduce using rule 90 (addVar -> .)
    RPAREN          reduce using rule 90 (addVar -> .)
    COMMA           reduce using rule 90 (addVar -> .)
    TO              reduce using rule 90 (addVar -> .)
    INT             reduce using rule 90 (addVar -> .)
    CHAR            reduce using rule 90 (addVar -> .)
    FLOAT           reduce using rule 90 (addVar -> .)
    CTEI            reduce using rule 90 (addVar -> .)
    CTEF            reduce using rule 90 (addVar -> .)
    CTEC            reduce using rule 90 (addVar -> .)
    CTESTRING       reduce using rule 90 (addVar -> .)
    LPAREN          reduce using rule 90 (addVar -> .)
    ID              reduce using rule 90 (addVar -> .)

    addVar                         shift and go to state 137

state 97

    (95) arr -> LBRACKET CTEI RBRACKET .

    COMMA           reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    SEMMICOLON      reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    MUL             reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    DIV             reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    PLUS            reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    MINUS           reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    GT              reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    LT              reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    GTE             reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    LTE             reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    NE              reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    AND             reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    OR              reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    RBRACKET        reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    RPAREN          reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    TO              reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    INT             reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    CHAR            reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    FLOAT           reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    CTEI            reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    CTEF            reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    CTEC            reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    CTESTRING       reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    LPAREN          reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    ID              reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)
    EQUALS          reduce using rule 95 (arr -> LBRACKET CTEI RBRACKET .)


state 98

    (73) pexp -> CTEI saveCTE .

    MUL             reduce using rule 73 (pexp -> CTEI saveCTE .)
    DIV             reduce using rule 73 (pexp -> CTEI saveCTE .)
    PLUS            reduce using rule 73 (pexp -> CTEI saveCTE .)
    MINUS           reduce using rule 73 (pexp -> CTEI saveCTE .)
    GT              reduce using rule 73 (pexp -> CTEI saveCTE .)
    LT              reduce using rule 73 (pexp -> CTEI saveCTE .)
    GTE             reduce using rule 73 (pexp -> CTEI saveCTE .)
    LTE             reduce using rule 73 (pexp -> CTEI saveCTE .)
    NE              reduce using rule 73 (pexp -> CTEI saveCTE .)
    AND             reduce using rule 73 (pexp -> CTEI saveCTE .)
    OR              reduce using rule 73 (pexp -> CTEI saveCTE .)
    RBRACKET        reduce using rule 73 (pexp -> CTEI saveCTE .)
    RPAREN          reduce using rule 73 (pexp -> CTEI saveCTE .)
    COMMA           reduce using rule 73 (pexp -> CTEI saveCTE .)
    SEMMICOLON      reduce using rule 73 (pexp -> CTEI saveCTE .)
    TO              reduce using rule 73 (pexp -> CTEI saveCTE .)
    CTEI            reduce using rule 73 (pexp -> CTEI saveCTE .)
    CTEF            reduce using rule 73 (pexp -> CTEI saveCTE .)
    CTEC            reduce using rule 73 (pexp -> CTEI saveCTE .)
    CTESTRING       reduce using rule 73 (pexp -> CTEI saveCTE .)
    LPAREN          reduce using rule 73 (pexp -> CTEI saveCTE .)
    ID              reduce using rule 73 (pexp -> CTEI saveCTE .)


state 99

    (96) arr -> LBRACKET exp RBRACKET .

    COMMA           reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    SEMMICOLON      reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    MUL             reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    DIV             reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    GT              reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    LT              reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    GTE             reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    LTE             reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    NE              reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    AND             reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    OR              reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    TO              reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    INT             reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    CHAR            reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    FLOAT           reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    CTEI            reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    CTEF            reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    CTEC            reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    CTESTRING       reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    ID              reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 96 (arr -> LBRACKET exp RBRACKET .)


state 100

    (55) exp -> nexp generateQuadOR .
    (56) exp -> nexp generateQuadOR . OR saveOperator nexp

    RBRACKET        reduce using rule 55 (exp -> nexp generateQuadOR .)
    RPAREN          reduce using rule 55 (exp -> nexp generateQuadOR .)
    COMMA           reduce using rule 55 (exp -> nexp generateQuadOR .)
    SEMMICOLON      reduce using rule 55 (exp -> nexp generateQuadOR .)
    TO              reduce using rule 55 (exp -> nexp generateQuadOR .)
    OR              shift and go to state 138


state 101

    (57) nexp -> compexp generateQuadAND .
    (58) nexp -> compexp generateQuadAND . AND saveOperator compexp

    OR              reduce using rule 57 (nexp -> compexp generateQuadAND .)
    RBRACKET        reduce using rule 57 (nexp -> compexp generateQuadAND .)
    RPAREN          reduce using rule 57 (nexp -> compexp generateQuadAND .)
    COMMA           reduce using rule 57 (nexp -> compexp generateQuadAND .)
    SEMMICOLON      reduce using rule 57 (nexp -> compexp generateQuadAND .)
    TO              reduce using rule 57 (nexp -> compexp generateQuadAND .)
    AND             shift and go to state 139


state 102

    (61) compexp1 -> sumexp GT . saveOperator sumexp generateQuadCOMPARE
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    RBRACKET        reduce using rule 79 (saveOperator -> .)
    RPAREN          reduce using rule 79 (saveOperator -> .)
    COMMA           reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 140

state 103

    (62) compexp1 -> sumexp LT . saveOperator sumexp generateQuadCOMPARE
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    RBRACKET        reduce using rule 79 (saveOperator -> .)
    RPAREN          reduce using rule 79 (saveOperator -> .)
    COMMA           reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 141

state 104

    (63) compexp1 -> sumexp GTE . saveOperator sumexp generateQuadCOMPARE
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    RBRACKET        reduce using rule 79 (saveOperator -> .)
    RPAREN          reduce using rule 79 (saveOperator -> .)
    COMMA           reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 142

state 105

    (64) compexp1 -> sumexp LTE . saveOperator sumexp generateQuadCOMPARE
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    RBRACKET        reduce using rule 79 (saveOperator -> .)
    RPAREN          reduce using rule 79 (saveOperator -> .)
    COMMA           reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 143

state 106

    (65) compexp1 -> sumexp NE . saveOperator sumexp generateQuadCOMPARE
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    RBRACKET        reduce using rule 79 (saveOperator -> .)
    RPAREN          reduce using rule 79 (saveOperator -> .)
    COMMA           reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 144

state 107

    (60) compexp -> compexp1 sumexp .

    AND             reduce using rule 60 (compexp -> compexp1 sumexp .)
    OR              reduce using rule 60 (compexp -> compexp1 sumexp .)
    RBRACKET        reduce using rule 60 (compexp -> compexp1 sumexp .)
    RPAREN          reduce using rule 60 (compexp -> compexp1 sumexp .)
    COMMA           reduce using rule 60 (compexp -> compexp1 sumexp .)
    SEMMICOLON      reduce using rule 60 (compexp -> compexp1 sumexp .)
    TO              reduce using rule 60 (compexp -> compexp1 sumexp .)


state 108

    (73) pexp -> CTEI . saveCTE
    (54) saveCTE -> .

    MUL             reduce using rule 54 (saveCTE -> .)
    DIV             reduce using rule 54 (saveCTE -> .)
    PLUS            reduce using rule 54 (saveCTE -> .)
    MINUS           reduce using rule 54 (saveCTE -> .)
    AND             reduce using rule 54 (saveCTE -> .)
    OR              reduce using rule 54 (saveCTE -> .)
    RBRACKET        reduce using rule 54 (saveCTE -> .)
    RPAREN          reduce using rule 54 (saveCTE -> .)
    COMMA           reduce using rule 54 (saveCTE -> .)
    SEMMICOLON      reduce using rule 54 (saveCTE -> .)
    TO              reduce using rule 54 (saveCTE -> .)
    GT              reduce using rule 54 (saveCTE -> .)
    LT              reduce using rule 54 (saveCTE -> .)
    GTE             reduce using rule 54 (saveCTE -> .)
    LTE             reduce using rule 54 (saveCTE -> .)
    NE              reduce using rule 54 (saveCTE -> .)
    CTEI            reduce using rule 54 (saveCTE -> .)
    CTEF            reduce using rule 54 (saveCTE -> .)
    CTEC            reduce using rule 54 (saveCTE -> .)
    CTESTRING       reduce using rule 54 (saveCTE -> .)
    LPAREN          reduce using rule 54 (saveCTE -> .)
    ID              reduce using rule 54 (saveCTE -> .)

    saveCTE                        shift and go to state 98

state 109

    (67) sumexp -> mulexp PLUS . saveOperator mulexp generateQuadSUM
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)
    GT              reduce using rule 79 (saveOperator -> .)
    LT              reduce using rule 79 (saveOperator -> .)
    GTE             reduce using rule 79 (saveOperator -> .)
    LTE             reduce using rule 79 (saveOperator -> .)
    NE              reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    RBRACKET        reduce using rule 79 (saveOperator -> .)
    RPAREN          reduce using rule 79 (saveOperator -> .)
    COMMA           reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 145

state 110

    (68) sumexp -> mulexp MINUS . saveOperator mulexp generateQuadSUM
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)
    GT              reduce using rule 79 (saveOperator -> .)
    LT              reduce using rule 79 (saveOperator -> .)
    GTE             reduce using rule 79 (saveOperator -> .)
    LTE             reduce using rule 79 (saveOperator -> .)
    NE              reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    RBRACKET        reduce using rule 79 (saveOperator -> .)
    RPAREN          reduce using rule 79 (saveOperator -> .)
    COMMA           reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 146

state 111

    (70) mulexp -> pexp MUL . saveOperator pexp generateQuadMUL
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)
    GT              reduce using rule 79 (saveOperator -> .)
    LT              reduce using rule 79 (saveOperator -> .)
    GTE             reduce using rule 79 (saveOperator -> .)
    LTE             reduce using rule 79 (saveOperator -> .)
    NE              reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    RBRACKET        reduce using rule 79 (saveOperator -> .)
    RPAREN          reduce using rule 79 (saveOperator -> .)
    COMMA           reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 147

state 112

    (71) mulexp -> pexp DIV . saveOperator pexp generateQuadMUL
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)
    GT              reduce using rule 79 (saveOperator -> .)
    LT              reduce using rule 79 (saveOperator -> .)
    GTE             reduce using rule 79 (saveOperator -> .)
    LTE             reduce using rule 79 (saveOperator -> .)
    NE              reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    RBRACKET        reduce using rule 79 (saveOperator -> .)
    RPAREN          reduce using rule 79 (saveOperator -> .)
    COMMA           reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 148

state 113

    (72) pexp -> var1 add_id .

    MUL             reduce using rule 72 (pexp -> var1 add_id .)
    DIV             reduce using rule 72 (pexp -> var1 add_id .)
    PLUS            reduce using rule 72 (pexp -> var1 add_id .)
    MINUS           reduce using rule 72 (pexp -> var1 add_id .)
    GT              reduce using rule 72 (pexp -> var1 add_id .)
    LT              reduce using rule 72 (pexp -> var1 add_id .)
    GTE             reduce using rule 72 (pexp -> var1 add_id .)
    LTE             reduce using rule 72 (pexp -> var1 add_id .)
    NE              reduce using rule 72 (pexp -> var1 add_id .)
    AND             reduce using rule 72 (pexp -> var1 add_id .)
    OR              reduce using rule 72 (pexp -> var1 add_id .)
    RBRACKET        reduce using rule 72 (pexp -> var1 add_id .)
    RPAREN          reduce using rule 72 (pexp -> var1 add_id .)
    COMMA           reduce using rule 72 (pexp -> var1 add_id .)
    SEMMICOLON      reduce using rule 72 (pexp -> var1 add_id .)
    TO              reduce using rule 72 (pexp -> var1 add_id .)
    CTEI            reduce using rule 72 (pexp -> var1 add_id .)
    CTEF            reduce using rule 72 (pexp -> var1 add_id .)
    CTEC            reduce using rule 72 (pexp -> var1 add_id .)
    CTESTRING       reduce using rule 72 (pexp -> var1 add_id .)
    LPAREN          reduce using rule 72 (pexp -> var1 add_id .)
    ID              reduce using rule 72 (pexp -> var1 add_id .)


state 114

    (74) pexp -> CTEF saveCTE .

    MUL             reduce using rule 74 (pexp -> CTEF saveCTE .)
    DIV             reduce using rule 74 (pexp -> CTEF saveCTE .)
    PLUS            reduce using rule 74 (pexp -> CTEF saveCTE .)
    MINUS           reduce using rule 74 (pexp -> CTEF saveCTE .)
    GT              reduce using rule 74 (pexp -> CTEF saveCTE .)
    LT              reduce using rule 74 (pexp -> CTEF saveCTE .)
    GTE             reduce using rule 74 (pexp -> CTEF saveCTE .)
    LTE             reduce using rule 74 (pexp -> CTEF saveCTE .)
    NE              reduce using rule 74 (pexp -> CTEF saveCTE .)
    AND             reduce using rule 74 (pexp -> CTEF saveCTE .)
    OR              reduce using rule 74 (pexp -> CTEF saveCTE .)
    RBRACKET        reduce using rule 74 (pexp -> CTEF saveCTE .)
    RPAREN          reduce using rule 74 (pexp -> CTEF saveCTE .)
    COMMA           reduce using rule 74 (pexp -> CTEF saveCTE .)
    SEMMICOLON      reduce using rule 74 (pexp -> CTEF saveCTE .)
    TO              reduce using rule 74 (pexp -> CTEF saveCTE .)
    CTEI            reduce using rule 74 (pexp -> CTEF saveCTE .)
    CTEF            reduce using rule 74 (pexp -> CTEF saveCTE .)
    CTEC            reduce using rule 74 (pexp -> CTEF saveCTE .)
    CTESTRING       reduce using rule 74 (pexp -> CTEF saveCTE .)
    LPAREN          reduce using rule 74 (pexp -> CTEF saveCTE .)
    ID              reduce using rule 74 (pexp -> CTEF saveCTE .)


state 115

    (75) pexp -> CTEC saveCTE .

    MUL             reduce using rule 75 (pexp -> CTEC saveCTE .)
    DIV             reduce using rule 75 (pexp -> CTEC saveCTE .)
    PLUS            reduce using rule 75 (pexp -> CTEC saveCTE .)
    MINUS           reduce using rule 75 (pexp -> CTEC saveCTE .)
    GT              reduce using rule 75 (pexp -> CTEC saveCTE .)
    LT              reduce using rule 75 (pexp -> CTEC saveCTE .)
    GTE             reduce using rule 75 (pexp -> CTEC saveCTE .)
    LTE             reduce using rule 75 (pexp -> CTEC saveCTE .)
    NE              reduce using rule 75 (pexp -> CTEC saveCTE .)
    AND             reduce using rule 75 (pexp -> CTEC saveCTE .)
    OR              reduce using rule 75 (pexp -> CTEC saveCTE .)
    RBRACKET        reduce using rule 75 (pexp -> CTEC saveCTE .)
    RPAREN          reduce using rule 75 (pexp -> CTEC saveCTE .)
    COMMA           reduce using rule 75 (pexp -> CTEC saveCTE .)
    SEMMICOLON      reduce using rule 75 (pexp -> CTEC saveCTE .)
    TO              reduce using rule 75 (pexp -> CTEC saveCTE .)
    CTEI            reduce using rule 75 (pexp -> CTEC saveCTE .)
    CTEF            reduce using rule 75 (pexp -> CTEC saveCTE .)
    CTEC            reduce using rule 75 (pexp -> CTEC saveCTE .)
    CTESTRING       reduce using rule 75 (pexp -> CTEC saveCTE .)
    LPAREN          reduce using rule 75 (pexp -> CTEC saveCTE .)
    ID              reduce using rule 75 (pexp -> CTEC saveCTE .)


state 116

    (76) pexp -> CTESTRING saveCTE .

    MUL             reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    DIV             reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    PLUS            reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    MINUS           reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    GT              reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    LT              reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    GTE             reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    LTE             reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    NE              reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    AND             reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    OR              reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    RBRACKET        reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    RPAREN          reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    COMMA           reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    SEMMICOLON      reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    TO              reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    CTEI            reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    CTEF            reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    CTEC            reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    CTESTRING       reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    LPAREN          reduce using rule 76 (pexp -> CTESTRING saveCTE .)
    ID              reduce using rule 76 (pexp -> CTESTRING saveCTE .)


state 117

    (78) pexp -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 149


state 118

    (22) functionCall -> ID LPAREN . exp RPAREN
    (55) exp -> . nexp generateQuadOR
    (56) exp -> . nexp generateQuadOR OR saveOperator nexp
    (57) nexp -> . compexp generateQuadAND
    (58) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)

    exp                            shift and go to state 150
    nexp                           shift and go to state 63
    compexp                        shift and go to state 64
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 119

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY .

    $end            reduce using rule 7 (principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY .)


state 120

    (8) statements -> assign SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)

    assign                         shift and go to state 77
    statements                     shift and go to state 151
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 121

    (9) statements -> functionCall SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)

    functionCall                   shift and go to state 78
    statements                     shift and go to state 152
    assign                         shift and go to state 77
    read                           shift and go to state 79
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 122

    (10) statements -> read statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 153


state 123

    (11) statements -> write statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 154


state 124

    (12) statements -> for statements .

    RCURLY          reduce using rule 12 (statements -> for statements .)
    SEMMICOLON      reduce using rule 12 (statements -> for statements .)


state 125

    (13) statements -> while statements .

    RCURLY          reduce using rule 13 (statements -> while statements .)
    SEMMICOLON      reduce using rule 13 (statements -> while statements .)


state 126

    (14) statements -> if statements .

    RCURLY          reduce using rule 14 (statements -> if statements .)
    SEMMICOLON      reduce using rule 14 (statements -> if statements .)


state 127

    (15) statements -> return statements .

    RCURLY          reduce using rule 15 (statements -> return statements .)
    SEMMICOLON      reduce using rule 15 (statements -> return statements .)


state 128

    (17) assign -> ID add_id2 . EQUALS saveOperator exp generateAssignQuad
    (18) assign -> ID add_id2 . arr EQUALS saveOperator exp generateAssignQuad
    (95) arr -> . LBRACKET CTEI RBRACKET
    (96) arr -> . LBRACKET exp RBRACKET

    EQUALS          shift and go to state 155
    LBRACKET        shift and go to state 54

    arr                            shift and go to state 156

state 129

    (23) read -> READ operatorRead . LPAREN var1 generateQuadREAD RPAREN

    LPAREN          shift and go to state 157


state 130

    (26) write -> WRITE LPAREN . writeOperator write1 generateQuadPRINT RPAREN
    (27) writeOperator -> .

    COMILLA         reduce using rule 27 (writeOperator -> .)
    CTEI            reduce using rule 27 (writeOperator -> .)
    CTEF            reduce using rule 27 (writeOperator -> .)
    CTEC            reduce using rule 27 (writeOperator -> .)
    CTESTRING       reduce using rule 27 (writeOperator -> .)
    LPAREN          reduce using rule 27 (writeOperator -> .)
    ID              reduce using rule 27 (writeOperator -> .)
    RPAREN          reduce using rule 27 (writeOperator -> .)
    COMMA           reduce using rule 27 (writeOperator -> .)
    OR              reduce using rule 27 (writeOperator -> .)
    AND             reduce using rule 27 (writeOperator -> .)
    GT              reduce using rule 27 (writeOperator -> .)
    LT              reduce using rule 27 (writeOperator -> .)
    GTE             reduce using rule 27 (writeOperator -> .)
    LTE             reduce using rule 27 (writeOperator -> .)
    NE              reduce using rule 27 (writeOperator -> .)
    PLUS            reduce using rule 27 (writeOperator -> .)
    MINUS           reduce using rule 27 (writeOperator -> .)
    MUL             reduce using rule 27 (writeOperator -> .)
    DIV             reduce using rule 27 (writeOperator -> .)

    writeOperator                  shift and go to state 158

state 131

    (34) for -> FOR forOP . assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad

    ID              shift and go to state 160

    assign                         shift and go to state 159

state 132

    (38) while -> WHILE whileOP . LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    LPAREN          shift and go to state 161


state 133

    (41) if -> IF LPAREN . exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (55) exp -> . nexp generateQuadOR
    (56) exp -> . nexp generateQuadOR OR saveOperator nexp
    (57) nexp -> . compexp generateQuadAND
    (58) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)

    exp                            shift and go to state 162
    nexp                           shift and go to state 63
    compexp                        shift and go to state 64
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 134

    (110) return -> RETURN LPAREN . exp RPAREN SEMMICOLON
    (111) return -> RETURN LPAREN . exp RPAREN
    (55) exp -> . nexp generateQuadOR
    (56) exp -> . nexp generateQuadOR OR saveOperator nexp
    (57) nexp -> . compexp generateQuadAND
    (58) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)

    exp                            shift and go to state 163
    nexp                           shift and go to state 63
    compexp                        shift and go to state 64
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 135

    (102) functions1 -> ID saveFunction LPAREN args RPAREN vars . LCURLY statements RCURLY

    LCURLY          shift and go to state 164


state 136

    (105) args -> args type TWOPOINTS . var1 addVar
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (112) empty -> .

    ID              shift and go to state 47
    RPAREN          reduce using rule 112 (empty -> .)
    INT             reduce using rule 112 (empty -> .)
    CHAR            reduce using rule 112 (empty -> .)
    FLOAT           reduce using rule 112 (empty -> .)

    var1                           shift and go to state 165
    empty                          shift and go to state 48

state 137

    (88) var1 -> ID arr COMMA var1 addVar .

    SEMMICOLON      reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    MUL             reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    DIV             reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    PLUS            reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    MINUS           reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    GT              reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    LT              reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    GTE             reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    LTE             reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    NE              reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    AND             reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    OR              reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    RBRACKET        reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    RPAREN          reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    COMMA           reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    TO              reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    INT             reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    CHAR            reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    FLOAT           reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    CTEI            reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    CTEF            reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    CTEC            reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    CTESTRING       reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    LPAREN          reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)
    ID              reduce using rule 88 (var1 -> ID arr COMMA var1 addVar .)


state 138

    (56) exp -> nexp generateQuadOR OR . saveOperator nexp
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    GT              reduce using rule 79 (saveOperator -> .)
    LT              reduce using rule 79 (saveOperator -> .)
    GTE             reduce using rule 79 (saveOperator -> .)
    LTE             reduce using rule 79 (saveOperator -> .)
    NE              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)
    RBRACKET        reduce using rule 79 (saveOperator -> .)
    RPAREN          reduce using rule 79 (saveOperator -> .)
    COMMA           reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 166

state 139

    (58) nexp -> compexp generateQuadAND AND . saveOperator compexp
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    GT              reduce using rule 79 (saveOperator -> .)
    LT              reduce using rule 79 (saveOperator -> .)
    GTE             reduce using rule 79 (saveOperator -> .)
    LTE             reduce using rule 79 (saveOperator -> .)
    NE              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    RBRACKET        reduce using rule 79 (saveOperator -> .)
    RPAREN          reduce using rule 79 (saveOperator -> .)
    COMMA           reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 167

state 140

    (61) compexp1 -> sumexp GT saveOperator . sumexp generateQuadCOMPARE
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)

  ! CTEI            [ reduce using rule 112 (empty -> .) ]
  ! CTEF            [ reduce using rule 112 (empty -> .) ]
  ! CTEC            [ reduce using rule 112 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 112 (empty -> .) ]
  ! LPAREN          [ reduce using rule 112 (empty -> .) ]
  ! ID              [ reduce using rule 112 (empty -> .) ]

    sumexp                         shift and go to state 168
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 141

    (62) compexp1 -> sumexp LT saveOperator . sumexp generateQuadCOMPARE
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)

  ! CTEI            [ reduce using rule 112 (empty -> .) ]
  ! CTEF            [ reduce using rule 112 (empty -> .) ]
  ! CTEC            [ reduce using rule 112 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 112 (empty -> .) ]
  ! LPAREN          [ reduce using rule 112 (empty -> .) ]
  ! ID              [ reduce using rule 112 (empty -> .) ]

    sumexp                         shift and go to state 169
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 142

    (63) compexp1 -> sumexp GTE saveOperator . sumexp generateQuadCOMPARE
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)

  ! CTEI            [ reduce using rule 112 (empty -> .) ]
  ! CTEF            [ reduce using rule 112 (empty -> .) ]
  ! CTEC            [ reduce using rule 112 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 112 (empty -> .) ]
  ! LPAREN          [ reduce using rule 112 (empty -> .) ]
  ! ID              [ reduce using rule 112 (empty -> .) ]

    sumexp                         shift and go to state 170
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 143

    (64) compexp1 -> sumexp LTE saveOperator . sumexp generateQuadCOMPARE
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)

  ! CTEI            [ reduce using rule 112 (empty -> .) ]
  ! CTEF            [ reduce using rule 112 (empty -> .) ]
  ! CTEC            [ reduce using rule 112 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 112 (empty -> .) ]
  ! LPAREN          [ reduce using rule 112 (empty -> .) ]
  ! ID              [ reduce using rule 112 (empty -> .) ]

    sumexp                         shift and go to state 171
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 144

    (65) compexp1 -> sumexp NE saveOperator . sumexp generateQuadCOMPARE
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)

  ! CTEI            [ reduce using rule 112 (empty -> .) ]
  ! CTEF            [ reduce using rule 112 (empty -> .) ]
  ! CTEC            [ reduce using rule 112 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 112 (empty -> .) ]
  ! LPAREN          [ reduce using rule 112 (empty -> .) ]
  ! ID              [ reduce using rule 112 (empty -> .) ]

    sumexp                         shift and go to state 172
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 145

    (67) sumexp -> mulexp PLUS saveOperator . mulexp generateQuadSUM
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)

  ! CTEI            [ reduce using rule 112 (empty -> .) ]
  ! CTEF            [ reduce using rule 112 (empty -> .) ]
  ! CTEC            [ reduce using rule 112 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 112 (empty -> .) ]
  ! LPAREN          [ reduce using rule 112 (empty -> .) ]
  ! ID              [ reduce using rule 112 (empty -> .) ]

    mulexp                         shift and go to state 173
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 146

    (68) sumexp -> mulexp MINUS saveOperator . mulexp generateQuadSUM
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)

  ! CTEI            [ reduce using rule 112 (empty -> .) ]
  ! CTEF            [ reduce using rule 112 (empty -> .) ]
  ! CTEC            [ reduce using rule 112 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 112 (empty -> .) ]
  ! LPAREN          [ reduce using rule 112 (empty -> .) ]
  ! ID              [ reduce using rule 112 (empty -> .) ]

    mulexp                         shift and go to state 174
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 147

    (70) mulexp -> pexp MUL saveOperator . pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)

  ! CTEI            [ reduce using rule 112 (empty -> .) ]
  ! CTEF            [ reduce using rule 112 (empty -> .) ]
  ! CTEC            [ reduce using rule 112 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 112 (empty -> .) ]
  ! LPAREN          [ reduce using rule 112 (empty -> .) ]
  ! ID              [ reduce using rule 112 (empty -> .) ]

    pexp                           shift and go to state 175
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 148

    (71) mulexp -> pexp DIV saveOperator . pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)

  ! CTEI            [ reduce using rule 112 (empty -> .) ]
  ! CTEF            [ reduce using rule 112 (empty -> .) ]
  ! CTEC            [ reduce using rule 112 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 112 (empty -> .) ]
  ! LPAREN          [ reduce using rule 112 (empty -> .) ]
  ! ID              [ reduce using rule 112 (empty -> .) ]

    pexp                           shift and go to state 176
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 149

    (78) pexp -> LPAREN exp RPAREN .

    MUL             reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    DIV             reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    AND             reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    OR              reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    SEMMICOLON      reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    TO              reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    CTEI            reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    CTEF            reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    CTEC            reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    CTESTRING       reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 78 (pexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 78 (pexp -> LPAREN exp RPAREN .)


state 150

    (22) functionCall -> ID LPAREN exp . RPAREN

    RPAREN          shift and go to state 177


state 151

    (8) statements -> assign SEMMICOLON statements .

    RCURLY          reduce using rule 8 (statements -> assign SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 8 (statements -> assign SEMMICOLON statements .)


state 152

    (9) statements -> functionCall SEMMICOLON statements .

    RCURLY          reduce using rule 9 (statements -> functionCall SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 9 (statements -> functionCall SEMMICOLON statements .)


state 153

    (10) statements -> read statements SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)

    read                           shift and go to state 79
    statements                     shift and go to state 178
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 154

    (11) statements -> write statements SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)

    write                          shift and go to state 80
    statements                     shift and go to state 179
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 155

    (17) assign -> ID add_id2 EQUALS . saveOperator exp generateAssignQuad
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    GT              reduce using rule 79 (saveOperator -> .)
    LT              reduce using rule 79 (saveOperator -> .)
    GTE             reduce using rule 79 (saveOperator -> .)
    LTE             reduce using rule 79 (saveOperator -> .)
    NE              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 180

state 156

    (18) assign -> ID add_id2 arr . EQUALS saveOperator exp generateAssignQuad

    EQUALS          shift and go to state 181


state 157

    (23) read -> READ operatorRead LPAREN . var1 generateQuadREAD RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (112) empty -> .

    ID              shift and go to state 47
    RPAREN          reduce using rule 112 (empty -> .)

    var1                           shift and go to state 182
    empty                          shift and go to state 48

state 158

    (26) write -> WRITE LPAREN writeOperator . write1 generateQuadPRINT RPAREN
    (28) write1 -> . write2 COMMA write2
    (29) write1 -> . write2
    (30) write2 -> . COMILLA CTESTRING COMILLA
    (31) write2 -> . CTEI saveCTE generateQuadPRINT
    (32) write2 -> . CTEF saveCTE generateQuadPRINT
    (33) write2 -> . exp
    (55) exp -> . nexp generateQuadOR
    (56) exp -> . nexp generateQuadOR OR saveOperator nexp
    (57) nexp -> . compexp generateQuadAND
    (58) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    COMILLA         shift and go to state 185
    CTEI            shift and go to state 186
    CTEF            shift and go to state 187
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)

    write1                         shift and go to state 183
    write2                         shift and go to state 184
    exp                            shift and go to state 188
    nexp                           shift and go to state 63
    compexp                        shift and go to state 64
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 159

    (34) for -> FOR forOP assign . TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    TO              shift and go to state 189


state 160

    (17) assign -> ID . add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> ID . add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (21) add_id2 -> .

    EQUALS          reduce using rule 21 (add_id2 -> .)
    LBRACKET        reduce using rule 21 (add_id2 -> .)

    add_id2                        shift and go to state 128

state 161

    (38) while -> WHILE whileOP LPAREN . exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) exp -> . nexp generateQuadOR
    (56) exp -> . nexp generateQuadOR OR saveOperator nexp
    (57) nexp -> . compexp generateQuadAND
    (58) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)

    exp                            shift and go to state 190
    nexp                           shift and go to state 63
    compexp                        shift and go to state 64
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 162

    (41) if -> IF LPAREN exp . RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF

    RPAREN          shift and go to state 191


state 163

    (110) return -> RETURN LPAREN exp . RPAREN SEMMICOLON
    (111) return -> RETURN LPAREN exp . RPAREN

    RPAREN          shift and go to state 192


state 164

    (102) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)

    statements                     shift and go to state 193
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 165

    (105) args -> args type TWOPOINTS var1 . addVar
    (90) addVar -> .

    RPAREN          reduce using rule 90 (addVar -> .)
    INT             reduce using rule 90 (addVar -> .)
    CHAR            reduce using rule 90 (addVar -> .)
    FLOAT           reduce using rule 90 (addVar -> .)

    addVar                         shift and go to state 194

state 166

    (56) exp -> nexp generateQuadOR OR saveOperator . nexp
    (57) nexp -> . compexp generateQuadAND
    (58) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)

    nexp                           shift and go to state 195
    compexp                        shift and go to state 64
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 167

    (58) nexp -> compexp generateQuadAND AND saveOperator . compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RBRACKET        reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)
    COMMA           reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)

    compexp                        shift and go to state 196
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 168

    (61) compexp1 -> sumexp GT saveOperator sumexp . generateQuadCOMPARE
    (46) generateQuadCOMPARE -> .

    CTEI            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 46 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 46 (generateQuadCOMPARE -> .)
    ID              reduce using rule 46 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 46 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 46 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 46 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 46 (generateQuadCOMPARE -> .)
    AND             reduce using rule 46 (generateQuadCOMPARE -> .)
    OR              reduce using rule 46 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 46 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 46 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 46 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 46 (generateQuadCOMPARE -> .)
    TO              reduce using rule 46 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 197

state 169

    (62) compexp1 -> sumexp LT saveOperator sumexp . generateQuadCOMPARE
    (46) generateQuadCOMPARE -> .

    CTEI            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 46 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 46 (generateQuadCOMPARE -> .)
    ID              reduce using rule 46 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 46 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 46 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 46 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 46 (generateQuadCOMPARE -> .)
    AND             reduce using rule 46 (generateQuadCOMPARE -> .)
    OR              reduce using rule 46 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 46 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 46 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 46 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 46 (generateQuadCOMPARE -> .)
    TO              reduce using rule 46 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 198

state 170

    (63) compexp1 -> sumexp GTE saveOperator sumexp . generateQuadCOMPARE
    (46) generateQuadCOMPARE -> .

    CTEI            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 46 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 46 (generateQuadCOMPARE -> .)
    ID              reduce using rule 46 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 46 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 46 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 46 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 46 (generateQuadCOMPARE -> .)
    AND             reduce using rule 46 (generateQuadCOMPARE -> .)
    OR              reduce using rule 46 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 46 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 46 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 46 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 46 (generateQuadCOMPARE -> .)
    TO              reduce using rule 46 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 199

state 171

    (64) compexp1 -> sumexp LTE saveOperator sumexp . generateQuadCOMPARE
    (46) generateQuadCOMPARE -> .

    CTEI            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 46 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 46 (generateQuadCOMPARE -> .)
    ID              reduce using rule 46 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 46 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 46 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 46 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 46 (generateQuadCOMPARE -> .)
    AND             reduce using rule 46 (generateQuadCOMPARE -> .)
    OR              reduce using rule 46 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 46 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 46 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 46 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 46 (generateQuadCOMPARE -> .)
    TO              reduce using rule 46 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 200

state 172

    (65) compexp1 -> sumexp NE saveOperator sumexp . generateQuadCOMPARE
    (46) generateQuadCOMPARE -> .

    CTEI            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 46 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 46 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 46 (generateQuadCOMPARE -> .)
    ID              reduce using rule 46 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 46 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 46 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 46 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 46 (generateQuadCOMPARE -> .)
    AND             reduce using rule 46 (generateQuadCOMPARE -> .)
    OR              reduce using rule 46 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 46 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 46 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 46 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 46 (generateQuadCOMPARE -> .)
    TO              reduce using rule 46 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 201

state 173

    (67) sumexp -> mulexp PLUS saveOperator mulexp . generateQuadSUM
    (48) generateQuadSUM -> .

    GT              reduce using rule 48 (generateQuadSUM -> .)
    LT              reduce using rule 48 (generateQuadSUM -> .)
    GTE             reduce using rule 48 (generateQuadSUM -> .)
    LTE             reduce using rule 48 (generateQuadSUM -> .)
    NE              reduce using rule 48 (generateQuadSUM -> .)
    AND             reduce using rule 48 (generateQuadSUM -> .)
    OR              reduce using rule 48 (generateQuadSUM -> .)
    RBRACKET        reduce using rule 48 (generateQuadSUM -> .)
    RPAREN          reduce using rule 48 (generateQuadSUM -> .)
    COMMA           reduce using rule 48 (generateQuadSUM -> .)
    SEMMICOLON      reduce using rule 48 (generateQuadSUM -> .)
    TO              reduce using rule 48 (generateQuadSUM -> .)
    CTEI            reduce using rule 48 (generateQuadSUM -> .)
    CTEF            reduce using rule 48 (generateQuadSUM -> .)
    CTEC            reduce using rule 48 (generateQuadSUM -> .)
    CTESTRING       reduce using rule 48 (generateQuadSUM -> .)
    LPAREN          reduce using rule 48 (generateQuadSUM -> .)
    ID              reduce using rule 48 (generateQuadSUM -> .)
    PLUS            reduce using rule 48 (generateQuadSUM -> .)
    MINUS           reduce using rule 48 (generateQuadSUM -> .)
    MUL             reduce using rule 48 (generateQuadSUM -> .)
    DIV             reduce using rule 48 (generateQuadSUM -> .)

    generateQuadSUM                shift and go to state 202

state 174

    (68) sumexp -> mulexp MINUS saveOperator mulexp . generateQuadSUM
    (48) generateQuadSUM -> .

    GT              reduce using rule 48 (generateQuadSUM -> .)
    LT              reduce using rule 48 (generateQuadSUM -> .)
    GTE             reduce using rule 48 (generateQuadSUM -> .)
    LTE             reduce using rule 48 (generateQuadSUM -> .)
    NE              reduce using rule 48 (generateQuadSUM -> .)
    AND             reduce using rule 48 (generateQuadSUM -> .)
    OR              reduce using rule 48 (generateQuadSUM -> .)
    RBRACKET        reduce using rule 48 (generateQuadSUM -> .)
    RPAREN          reduce using rule 48 (generateQuadSUM -> .)
    COMMA           reduce using rule 48 (generateQuadSUM -> .)
    SEMMICOLON      reduce using rule 48 (generateQuadSUM -> .)
    TO              reduce using rule 48 (generateQuadSUM -> .)
    CTEI            reduce using rule 48 (generateQuadSUM -> .)
    CTEF            reduce using rule 48 (generateQuadSUM -> .)
    CTEC            reduce using rule 48 (generateQuadSUM -> .)
    CTESTRING       reduce using rule 48 (generateQuadSUM -> .)
    LPAREN          reduce using rule 48 (generateQuadSUM -> .)
    ID              reduce using rule 48 (generateQuadSUM -> .)
    PLUS            reduce using rule 48 (generateQuadSUM -> .)
    MINUS           reduce using rule 48 (generateQuadSUM -> .)
    MUL             reduce using rule 48 (generateQuadSUM -> .)
    DIV             reduce using rule 48 (generateQuadSUM -> .)

    generateQuadSUM                shift and go to state 203

state 175

    (70) mulexp -> pexp MUL saveOperator pexp . generateQuadMUL
    (49) generateQuadMUL -> .

    PLUS            reduce using rule 49 (generateQuadMUL -> .)
    MINUS           reduce using rule 49 (generateQuadMUL -> .)
    GT              reduce using rule 49 (generateQuadMUL -> .)
    LT              reduce using rule 49 (generateQuadMUL -> .)
    GTE             reduce using rule 49 (generateQuadMUL -> .)
    LTE             reduce using rule 49 (generateQuadMUL -> .)
    NE              reduce using rule 49 (generateQuadMUL -> .)
    AND             reduce using rule 49 (generateQuadMUL -> .)
    OR              reduce using rule 49 (generateQuadMUL -> .)
    RBRACKET        reduce using rule 49 (generateQuadMUL -> .)
    RPAREN          reduce using rule 49 (generateQuadMUL -> .)
    COMMA           reduce using rule 49 (generateQuadMUL -> .)
    SEMMICOLON      reduce using rule 49 (generateQuadMUL -> .)
    TO              reduce using rule 49 (generateQuadMUL -> .)
    CTEI            reduce using rule 49 (generateQuadMUL -> .)
    CTEF            reduce using rule 49 (generateQuadMUL -> .)
    CTEC            reduce using rule 49 (generateQuadMUL -> .)
    CTESTRING       reduce using rule 49 (generateQuadMUL -> .)
    LPAREN          reduce using rule 49 (generateQuadMUL -> .)
    ID              reduce using rule 49 (generateQuadMUL -> .)
    MUL             reduce using rule 49 (generateQuadMUL -> .)
    DIV             reduce using rule 49 (generateQuadMUL -> .)

    generateQuadMUL                shift and go to state 204

state 176

    (71) mulexp -> pexp DIV saveOperator pexp . generateQuadMUL
    (49) generateQuadMUL -> .

    PLUS            reduce using rule 49 (generateQuadMUL -> .)
    MINUS           reduce using rule 49 (generateQuadMUL -> .)
    GT              reduce using rule 49 (generateQuadMUL -> .)
    LT              reduce using rule 49 (generateQuadMUL -> .)
    GTE             reduce using rule 49 (generateQuadMUL -> .)
    LTE             reduce using rule 49 (generateQuadMUL -> .)
    NE              reduce using rule 49 (generateQuadMUL -> .)
    AND             reduce using rule 49 (generateQuadMUL -> .)
    OR              reduce using rule 49 (generateQuadMUL -> .)
    RBRACKET        reduce using rule 49 (generateQuadMUL -> .)
    RPAREN          reduce using rule 49 (generateQuadMUL -> .)
    COMMA           reduce using rule 49 (generateQuadMUL -> .)
    SEMMICOLON      reduce using rule 49 (generateQuadMUL -> .)
    TO              reduce using rule 49 (generateQuadMUL -> .)
    CTEI            reduce using rule 49 (generateQuadMUL -> .)
    CTEF            reduce using rule 49 (generateQuadMUL -> .)
    CTEC            reduce using rule 49 (generateQuadMUL -> .)
    CTESTRING       reduce using rule 49 (generateQuadMUL -> .)
    LPAREN          reduce using rule 49 (generateQuadMUL -> .)
    ID              reduce using rule 49 (generateQuadMUL -> .)
    MUL             reduce using rule 49 (generateQuadMUL -> .)
    DIV             reduce using rule 49 (generateQuadMUL -> .)

    generateQuadMUL                shift and go to state 205

state 177

    (22) functionCall -> ID LPAREN exp RPAREN .

    MUL             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    DIV             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    PLUS            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    MINUS           reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    GT              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    LT              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    GTE             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    LTE             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    NE              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    AND             reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    OR              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    SEMMICOLON      reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    RPAREN          reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    COMMA           reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    TO              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTEI            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTEF            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTEC            reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    CTESTRING       reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    LPAREN          reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)
    ID              reduce using rule 22 (functionCall -> ID LPAREN exp RPAREN .)


state 178

    (10) statements -> read statements SEMMICOLON statements .

    RCURLY          reduce using rule 10 (statements -> read statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 10 (statements -> read statements SEMMICOLON statements .)


state 179

    (11) statements -> write statements SEMMICOLON statements .

    RCURLY          reduce using rule 11 (statements -> write statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 11 (statements -> write statements SEMMICOLON statements .)


state 180

    (17) assign -> ID add_id2 EQUALS saveOperator . exp generateAssignQuad
    (55) exp -> . nexp generateQuadOR
    (56) exp -> . nexp generateQuadOR OR saveOperator nexp
    (57) nexp -> . compexp generateQuadAND
    (58) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)

    exp                            shift and go to state 206
    nexp                           shift and go to state 63
    compexp                        shift and go to state 64
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 181

    (18) assign -> ID add_id2 arr EQUALS . saveOperator exp generateAssignQuad
    (79) saveOperator -> .

    CTEI            reduce using rule 79 (saveOperator -> .)
    CTEF            reduce using rule 79 (saveOperator -> .)
    CTEC            reduce using rule 79 (saveOperator -> .)
    CTESTRING       reduce using rule 79 (saveOperator -> .)
    LPAREN          reduce using rule 79 (saveOperator -> .)
    ID              reduce using rule 79 (saveOperator -> .)
    OR              reduce using rule 79 (saveOperator -> .)
    AND             reduce using rule 79 (saveOperator -> .)
    GT              reduce using rule 79 (saveOperator -> .)
    LT              reduce using rule 79 (saveOperator -> .)
    GTE             reduce using rule 79 (saveOperator -> .)
    LTE             reduce using rule 79 (saveOperator -> .)
    NE              reduce using rule 79 (saveOperator -> .)
    PLUS            reduce using rule 79 (saveOperator -> .)
    MINUS           reduce using rule 79 (saveOperator -> .)
    MUL             reduce using rule 79 (saveOperator -> .)
    DIV             reduce using rule 79 (saveOperator -> .)
    SEMMICOLON      reduce using rule 79 (saveOperator -> .)
    TO              reduce using rule 79 (saveOperator -> .)

    saveOperator                   shift and go to state 207

state 182

    (23) read -> READ operatorRead LPAREN var1 . generateQuadREAD RPAREN
    (51) generateQuadREAD -> .

    RPAREN          reduce using rule 51 (generateQuadREAD -> .)

    generateQuadREAD               shift and go to state 208

state 183

    (26) write -> WRITE LPAREN writeOperator write1 . generateQuadPRINT RPAREN
    (50) generateQuadPRINT -> .

    RPAREN          reduce using rule 50 (generateQuadPRINT -> .)

    generateQuadPRINT              shift and go to state 209

state 184

    (28) write1 -> write2 . COMMA write2
    (29) write1 -> write2 .

    COMMA           shift and go to state 210
    RPAREN          reduce using rule 29 (write1 -> write2 .)


state 185

    (30) write2 -> COMILLA . CTESTRING COMILLA

    CTESTRING       shift and go to state 211


state 186

    (31) write2 -> CTEI . saveCTE generateQuadPRINT
    (73) pexp -> CTEI . saveCTE
    (54) saveCTE -> .

    COMMA           reduce using rule 54 (saveCTE -> .)
    RPAREN          reduce using rule 54 (saveCTE -> .)
    MUL             reduce using rule 54 (saveCTE -> .)
    DIV             reduce using rule 54 (saveCTE -> .)
    PLUS            reduce using rule 54 (saveCTE -> .)
    MINUS           reduce using rule 54 (saveCTE -> .)
    GT              reduce using rule 54 (saveCTE -> .)
    LT              reduce using rule 54 (saveCTE -> .)
    GTE             reduce using rule 54 (saveCTE -> .)
    LTE             reduce using rule 54 (saveCTE -> .)
    NE              reduce using rule 54 (saveCTE -> .)
    AND             reduce using rule 54 (saveCTE -> .)
    OR              reduce using rule 54 (saveCTE -> .)

    saveCTE                        shift and go to state 212

state 187

    (32) write2 -> CTEF . saveCTE generateQuadPRINT
    (74) pexp -> CTEF . saveCTE
    (54) saveCTE -> .

    COMMA           reduce using rule 54 (saveCTE -> .)
    RPAREN          reduce using rule 54 (saveCTE -> .)
    MUL             reduce using rule 54 (saveCTE -> .)
    DIV             reduce using rule 54 (saveCTE -> .)
    PLUS            reduce using rule 54 (saveCTE -> .)
    MINUS           reduce using rule 54 (saveCTE -> .)
    GT              reduce using rule 54 (saveCTE -> .)
    LT              reduce using rule 54 (saveCTE -> .)
    GTE             reduce using rule 54 (saveCTE -> .)
    LTE             reduce using rule 54 (saveCTE -> .)
    NE              reduce using rule 54 (saveCTE -> .)
    AND             reduce using rule 54 (saveCTE -> .)
    OR              reduce using rule 54 (saveCTE -> .)

    saveCTE                        shift and go to state 213

state 188

    (33) write2 -> exp .

    COMMA           reduce using rule 33 (write2 -> exp .)
    RPAREN          reduce using rule 33 (write2 -> exp .)


state 189

    (34) for -> FOR forOP assign TO . CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    CTEI            shift and go to state 214


state 190

    (38) while -> WHILE whileOP LPAREN exp . RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    RPAREN          shift and go to state 215


state 191

    (41) if -> IF LPAREN exp RPAREN . generateQuadIF THEN LCURLY statements RCURLY else endIF
    (47) generateQuadIF -> .

    THEN            reduce using rule 47 (generateQuadIF -> .)

    generateQuadIF                 shift and go to state 216

state 192

    (110) return -> RETURN LPAREN exp RPAREN . SEMMICOLON
    (111) return -> RETURN LPAREN exp RPAREN .

  ! shift/reduce conflict for SEMMICOLON resolved as shift
    SEMMICOLON      shift and go to state 217
    ID              reduce using rule 111 (return -> RETURN LPAREN exp RPAREN .)
    READ            reduce using rule 111 (return -> RETURN LPAREN exp RPAREN .)
    WRITE           reduce using rule 111 (return -> RETURN LPAREN exp RPAREN .)
    FOR             reduce using rule 111 (return -> RETURN LPAREN exp RPAREN .)
    WHILE           reduce using rule 111 (return -> RETURN LPAREN exp RPAREN .)
    IF              reduce using rule 111 (return -> RETURN LPAREN exp RPAREN .)
    RETURN          reduce using rule 111 (return -> RETURN LPAREN exp RPAREN .)
    RCURLY          reduce using rule 111 (return -> RETURN LPAREN exp RPAREN .)

  ! SEMMICOLON      [ reduce using rule 111 (return -> RETURN LPAREN exp RPAREN .) ]


state 193

    (102) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements . RCURLY

    RCURLY          shift and go to state 218


state 194

    (105) args -> args type TWOPOINTS var1 addVar .

    RPAREN          reduce using rule 105 (args -> args type TWOPOINTS var1 addVar .)
    INT             reduce using rule 105 (args -> args type TWOPOINTS var1 addVar .)
    CHAR            reduce using rule 105 (args -> args type TWOPOINTS var1 addVar .)
    FLOAT           reduce using rule 105 (args -> args type TWOPOINTS var1 addVar .)


state 195

    (56) exp -> nexp generateQuadOR OR saveOperator nexp .

    RBRACKET        reduce using rule 56 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    RPAREN          reduce using rule 56 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    COMMA           reduce using rule 56 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    SEMMICOLON      reduce using rule 56 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    TO              reduce using rule 56 (exp -> nexp generateQuadOR OR saveOperator nexp .)


state 196

    (58) nexp -> compexp generateQuadAND AND saveOperator compexp .

    OR              reduce using rule 58 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    RBRACKET        reduce using rule 58 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    RPAREN          reduce using rule 58 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    COMMA           reduce using rule 58 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    SEMMICOLON      reduce using rule 58 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    TO              reduce using rule 58 (nexp -> compexp generateQuadAND AND saveOperator compexp .)


state 197

    (61) compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 61 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)


state 198

    (62) compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 62 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)


state 199

    (63) compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 63 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)


state 200

    (64) compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 64 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)


state 201

    (65) compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .

    CTEI            reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    ID              reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 65 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)


state 202

    (67) sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .

    GT              reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LT              reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    GTE             reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LTE             reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    NE              reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    AND             reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    OR              reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    RBRACKET        reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    RPAREN          reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    COMMA           reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    SEMMICOLON      reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    TO              reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEI            reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEF            reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEC            reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTESTRING       reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LPAREN          reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    ID              reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    PLUS            reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    MINUS           reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    MUL             reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    DIV             reduce using rule 67 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)


state 203

    (68) sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .

    GT              reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LT              reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    GTE             reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LTE             reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    NE              reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    AND             reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    OR              reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    RBRACKET        reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    RPAREN          reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    COMMA           reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    SEMMICOLON      reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    TO              reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEI            reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEF            reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEC            reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTESTRING       reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LPAREN          reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    ID              reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    PLUS            reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    MINUS           reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    MUL             reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    DIV             reduce using rule 68 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)


state 204

    (70) mulexp -> pexp MUL saveOperator pexp generateQuadMUL .

    PLUS            reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    MINUS           reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    GT              reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LT              reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    GTE             reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LTE             reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    NE              reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    AND             reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    OR              reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    RBRACKET        reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    RPAREN          reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    COMMA           reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    SEMMICOLON      reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    TO              reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEI            reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEF            reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEC            reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTESTRING       reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LPAREN          reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    ID              reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    MUL             reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    DIV             reduce using rule 70 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)


state 205

    (71) mulexp -> pexp DIV saveOperator pexp generateQuadMUL .

    PLUS            reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    MINUS           reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    GT              reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LT              reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    GTE             reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LTE             reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    NE              reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    AND             reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    OR              reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    RBRACKET        reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    RPAREN          reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    COMMA           reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    SEMMICOLON      reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    TO              reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEI            reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEF            reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEC            reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTESTRING       reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LPAREN          reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    ID              reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    MUL             reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    DIV             reduce using rule 71 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)


state 206

    (17) assign -> ID add_id2 EQUALS saveOperator exp . generateAssignQuad
    (19) generateAssignQuad -> .

    SEMMICOLON      reduce using rule 19 (generateAssignQuad -> .)
    TO              reduce using rule 19 (generateAssignQuad -> .)

    generateAssignQuad             shift and go to state 219

state 207

    (18) assign -> ID add_id2 arr EQUALS saveOperator . exp generateAssignQuad
    (55) exp -> . nexp generateQuadOR
    (56) exp -> . nexp generateQuadOR OR saveOperator nexp
    (57) nexp -> . compexp generateQuadAND
    (58) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 70
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)
    TO              reduce using rule 112 (empty -> .)

    exp                            shift and go to state 220
    nexp                           shift and go to state 63
    compexp                        shift and go to state 64
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 208

    (23) read -> READ operatorRead LPAREN var1 generateQuadREAD . RPAREN

    RPAREN          shift and go to state 221


state 209

    (26) write -> WRITE LPAREN writeOperator write1 generateQuadPRINT . RPAREN

    RPAREN          shift and go to state 222


state 210

    (28) write1 -> write2 COMMA . write2
    (30) write2 -> . COMILLA CTESTRING COMILLA
    (31) write2 -> . CTEI saveCTE generateQuadPRINT
    (32) write2 -> . CTEF saveCTE generateQuadPRINT
    (33) write2 -> . exp
    (55) exp -> . nexp generateQuadOR
    (56) exp -> . nexp generateQuadOR OR saveOperator nexp
    (57) nexp -> . compexp generateQuadAND
    (58) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (59) compexp -> . sumexp
    (60) compexp -> . compexp1 sumexp
    (66) sumexp -> . mulexp
    (67) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (68) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (61) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (62) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (63) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (64) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (65) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (69) mulexp -> . pexp
    (70) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (71) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (72) pexp -> . var1 add_id
    (73) pexp -> . CTEI saveCTE
    (74) pexp -> . CTEF saveCTE
    (75) pexp -> . CTEC saveCTE
    (76) pexp -> . CTESTRING saveCTE
    (77) pexp -> . functionCall
    (78) pexp -> . LPAREN exp RPAREN
    (85) var1 -> . ID
    (86) var1 -> . ID COMMA var1 addVar
    (87) var1 -> . ID arr
    (88) var1 -> . ID arr COMMA var1 addVar
    (89) var1 -> . empty
    (22) functionCall -> . ID LPAREN exp RPAREN
    (112) empty -> .

    COMILLA         shift and go to state 185
    CTEI            shift and go to state 186
    CTEF            shift and go to state 187
    CTEC            shift and go to state 71
    CTESTRING       shift and go to state 72
    LPAREN          shift and go to state 74
    ID              shift and go to state 75
    MUL             reduce using rule 112 (empty -> .)
    DIV             reduce using rule 112 (empty -> .)
    PLUS            reduce using rule 112 (empty -> .)
    MINUS           reduce using rule 112 (empty -> .)
    GT              reduce using rule 112 (empty -> .)
    LT              reduce using rule 112 (empty -> .)
    GTE             reduce using rule 112 (empty -> .)
    LTE             reduce using rule 112 (empty -> .)
    NE              reduce using rule 112 (empty -> .)
    AND             reduce using rule 112 (empty -> .)
    OR              reduce using rule 112 (empty -> .)
    RPAREN          reduce using rule 112 (empty -> .)

    write2                         shift and go to state 223
    exp                            shift and go to state 188
    nexp                           shift and go to state 63
    compexp                        shift and go to state 64
    sumexp                         shift and go to state 65
    compexp1                       shift and go to state 66
    mulexp                         shift and go to state 67
    pexp                           shift and go to state 68
    var1                           shift and go to state 69
    functionCall                   shift and go to state 73
    empty                          shift and go to state 48

state 211

    (30) write2 -> COMILLA CTESTRING . COMILLA

    COMILLA         shift and go to state 224


state 212

    (31) write2 -> CTEI saveCTE . generateQuadPRINT
    (73) pexp -> CTEI saveCTE .
    (50) generateQuadPRINT -> .

  ! reduce/reduce conflict for COMMA resolved using rule 50 (generateQuadPRINT -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 50 (generateQuadPRINT -> .)
    MUL             reduce using rule 73 (pexp -> CTEI saveCTE .)
    DIV             reduce using rule 73 (pexp -> CTEI saveCTE .)
    PLUS            reduce using rule 73 (pexp -> CTEI saveCTE .)
    MINUS           reduce using rule 73 (pexp -> CTEI saveCTE .)
    GT              reduce using rule 73 (pexp -> CTEI saveCTE .)
    LT              reduce using rule 73 (pexp -> CTEI saveCTE .)
    GTE             reduce using rule 73 (pexp -> CTEI saveCTE .)
    LTE             reduce using rule 73 (pexp -> CTEI saveCTE .)
    NE              reduce using rule 73 (pexp -> CTEI saveCTE .)
    AND             reduce using rule 73 (pexp -> CTEI saveCTE .)
    OR              reduce using rule 73 (pexp -> CTEI saveCTE .)
    COMMA           reduce using rule 50 (generateQuadPRINT -> .)
    RPAREN          reduce using rule 50 (generateQuadPRINT -> .)

  ! COMMA           [ reduce using rule 73 (pexp -> CTEI saveCTE .) ]
  ! RPAREN          [ reduce using rule 73 (pexp -> CTEI saveCTE .) ]

    generateQuadPRINT              shift and go to state 225

state 213

    (32) write2 -> CTEF saveCTE . generateQuadPRINT
    (74) pexp -> CTEF saveCTE .
    (50) generateQuadPRINT -> .

  ! reduce/reduce conflict for COMMA resolved using rule 50 (generateQuadPRINT -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 50 (generateQuadPRINT -> .)
    MUL             reduce using rule 74 (pexp -> CTEF saveCTE .)
    DIV             reduce using rule 74 (pexp -> CTEF saveCTE .)
    PLUS            reduce using rule 74 (pexp -> CTEF saveCTE .)
    MINUS           reduce using rule 74 (pexp -> CTEF saveCTE .)
    GT              reduce using rule 74 (pexp -> CTEF saveCTE .)
    LT              reduce using rule 74 (pexp -> CTEF saveCTE .)
    GTE             reduce using rule 74 (pexp -> CTEF saveCTE .)
    LTE             reduce using rule 74 (pexp -> CTEF saveCTE .)
    NE              reduce using rule 74 (pexp -> CTEF saveCTE .)
    AND             reduce using rule 74 (pexp -> CTEF saveCTE .)
    OR              reduce using rule 74 (pexp -> CTEF saveCTE .)
    COMMA           reduce using rule 50 (generateQuadPRINT -> .)
    RPAREN          reduce using rule 50 (generateQuadPRINT -> .)

  ! COMMA           [ reduce using rule 74 (pexp -> CTEF saveCTE .) ]
  ! RPAREN          [ reduce using rule 74 (pexp -> CTEF saveCTE .) ]

    generateQuadPRINT              shift and go to state 226

state 214

    (34) for -> FOR forOP assign TO CTEI . DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    DO              shift and go to state 227


state 215

    (38) while -> WHILE whileOP LPAREN exp RPAREN . DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    DO              shift and go to state 228


state 216

    (41) if -> IF LPAREN exp RPAREN generateQuadIF . THEN LCURLY statements RCURLY else endIF

    THEN            shift and go to state 229


state 217

    (110) return -> RETURN LPAREN exp RPAREN SEMMICOLON .

    ID              reduce using rule 110 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    READ            reduce using rule 110 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WRITE           reduce using rule 110 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    FOR             reduce using rule 110 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WHILE           reduce using rule 110 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    IF              reduce using rule 110 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RETURN          reduce using rule 110 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RCURLY          reduce using rule 110 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    SEMMICOLON      reduce using rule 110 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)


state 218

    (102) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .

    FUNCTION        reduce using rule 102 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .)
    PRINCIPAL       reduce using rule 102 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .)
    $end            reduce using rule 102 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY .)


state 219

    (17) assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .

    SEMMICOLON      reduce using rule 17 (assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .)
    TO              reduce using rule 17 (assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .)


state 220

    (18) assign -> ID add_id2 arr EQUALS saveOperator exp . generateAssignQuad
    (19) generateAssignQuad -> .

    SEMMICOLON      reduce using rule 19 (generateAssignQuad -> .)
    TO              reduce using rule 19 (generateAssignQuad -> .)

    generateAssignQuad             shift and go to state 230

state 221

    (23) read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .

    ID              reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    READ            reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    WRITE           reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    FOR             reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    WHILE           reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    IF              reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    RETURN          reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)
    SEMMICOLON      reduce using rule 23 (read -> READ operatorRead LPAREN var1 generateQuadREAD RPAREN .)


state 222

    (26) write -> WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN .

    ID              reduce using rule 26 (write -> WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN .)
    READ            reduce using rule 26 (write -> WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN .)
    WRITE           reduce using rule 26 (write -> WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN .)
    FOR             reduce using rule 26 (write -> WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN .)
    WHILE           reduce using rule 26 (write -> WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN .)
    IF              reduce using rule 26 (write -> WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN .)
    RETURN          reduce using rule 26 (write -> WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN .)
    SEMMICOLON      reduce using rule 26 (write -> WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN .)


state 223

    (28) write1 -> write2 COMMA write2 .

    RPAREN          reduce using rule 28 (write1 -> write2 COMMA write2 .)


state 224

    (30) write2 -> COMILLA CTESTRING COMILLA .

    COMMA           reduce using rule 30 (write2 -> COMILLA CTESTRING COMILLA .)
    RPAREN          reduce using rule 30 (write2 -> COMILLA CTESTRING COMILLA .)


state 225

    (31) write2 -> CTEI saveCTE generateQuadPRINT .

    COMMA           reduce using rule 31 (write2 -> CTEI saveCTE generateQuadPRINT .)
    RPAREN          reduce using rule 31 (write2 -> CTEI saveCTE generateQuadPRINT .)


state 226

    (32) write2 -> CTEF saveCTE generateQuadPRINT .

    COMMA           reduce using rule 32 (write2 -> CTEF saveCTE generateQuadPRINT .)
    RPAREN          reduce using rule 32 (write2 -> CTEF saveCTE generateQuadPRINT .)


state 227

    (34) for -> FOR forOP assign TO CTEI DO . generateQuadFOR LCURLY statements RCURLY LoopEnd
    (36) generateQuadFOR -> .

    LCURLY          reduce using rule 36 (generateQuadFOR -> .)

    generateQuadFOR                shift and go to state 231

state 228

    (38) while -> WHILE whileOP LPAREN exp RPAREN DO . generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (40) generateQuadWHILE -> .

    LCURLY          reduce using rule 40 (generateQuadWHILE -> .)

    generateQuadWHILE              shift and go to state 232

state 229

    (41) if -> IF LPAREN exp RPAREN generateQuadIF THEN . LCURLY statements RCURLY else endIF

    LCURLY          shift and go to state 233


state 230

    (18) assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .

    SEMMICOLON      reduce using rule 18 (assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .)
    TO              reduce using rule 18 (assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .)


state 231

    (34) for -> FOR forOP assign TO CTEI DO generateQuadFOR . LCURLY statements RCURLY LoopEnd

    LCURLY          shift and go to state 234


state 232

    (38) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE . LCURLY statements RCURLY LoopEnd

    LCURLY          shift and go to state 235


state 233

    (41) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY . statements RCURLY else endIF
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)

    statements                     shift and go to state 236
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 234

    (34) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY . statements RCURLY LoopEnd
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)

    assign                         shift and go to state 77
    statements                     shift and go to state 237
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 235

    (38) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY . statements RCURLY LoopEnd
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)

    statements                     shift and go to state 238
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 236

    (41) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements . RCURLY else endIF

    RCURLY          shift and go to state 239


state 237

    (34) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements . RCURLY LoopEnd

    RCURLY          shift and go to state 240


state 238

    (38) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements . RCURLY LoopEnd

    RCURLY          shift and go to state 241


state 239

    (41) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY . else endIF
    (42) else -> . ELSE generateQuadELSE LCURLY statements RCURLY
    (43) else -> . empty
    (112) empty -> .

    ELSE            shift and go to state 243
    ID              reduce using rule 112 (empty -> .)
    READ            reduce using rule 112 (empty -> .)
    WRITE           reduce using rule 112 (empty -> .)
    FOR             reduce using rule 112 (empty -> .)
    WHILE           reduce using rule 112 (empty -> .)
    IF              reduce using rule 112 (empty -> .)
    RETURN          reduce using rule 112 (empty -> .)
    RCURLY          reduce using rule 112 (empty -> .)
    SEMMICOLON      reduce using rule 112 (empty -> .)

    else                           shift and go to state 242
    empty                          shift and go to state 244

state 240

    (34) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY . LoopEnd
    (37) LoopEnd -> .

    ID              reduce using rule 37 (LoopEnd -> .)
    READ            reduce using rule 37 (LoopEnd -> .)
    WRITE           reduce using rule 37 (LoopEnd -> .)
    FOR             reduce using rule 37 (LoopEnd -> .)
    WHILE           reduce using rule 37 (LoopEnd -> .)
    IF              reduce using rule 37 (LoopEnd -> .)
    RETURN          reduce using rule 37 (LoopEnd -> .)
    RCURLY          reduce using rule 37 (LoopEnd -> .)
    SEMMICOLON      reduce using rule 37 (LoopEnd -> .)

    LoopEnd                        shift and go to state 245

state 241

    (38) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY . LoopEnd
    (37) LoopEnd -> .

    ID              reduce using rule 37 (LoopEnd -> .)
    READ            reduce using rule 37 (LoopEnd -> .)
    WRITE           reduce using rule 37 (LoopEnd -> .)
    FOR             reduce using rule 37 (LoopEnd -> .)
    WHILE           reduce using rule 37 (LoopEnd -> .)
    IF              reduce using rule 37 (LoopEnd -> .)
    RETURN          reduce using rule 37 (LoopEnd -> .)
    RCURLY          reduce using rule 37 (LoopEnd -> .)
    SEMMICOLON      reduce using rule 37 (LoopEnd -> .)

    LoopEnd                        shift and go to state 246

state 242

    (41) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else . endIF
    (52) endIF -> .

    ID              reduce using rule 52 (endIF -> .)
    READ            reduce using rule 52 (endIF -> .)
    WRITE           reduce using rule 52 (endIF -> .)
    FOR             reduce using rule 52 (endIF -> .)
    WHILE           reduce using rule 52 (endIF -> .)
    IF              reduce using rule 52 (endIF -> .)
    RETURN          reduce using rule 52 (endIF -> .)
    RCURLY          reduce using rule 52 (endIF -> .)
    SEMMICOLON      reduce using rule 52 (endIF -> .)

    endIF                          shift and go to state 247

state 243

    (42) else -> ELSE . generateQuadELSE LCURLY statements RCURLY
    (53) generateQuadELSE -> .

    LCURLY          reduce using rule 53 (generateQuadELSE -> .)

    generateQuadELSE               shift and go to state 248

state 244

    (43) else -> empty .

    ID              reduce using rule 43 (else -> empty .)
    READ            reduce using rule 43 (else -> empty .)
    WRITE           reduce using rule 43 (else -> empty .)
    FOR             reduce using rule 43 (else -> empty .)
    WHILE           reduce using rule 43 (else -> empty .)
    IF              reduce using rule 43 (else -> empty .)
    RETURN          reduce using rule 43 (else -> empty .)
    RCURLY          reduce using rule 43 (else -> empty .)
    SEMMICOLON      reduce using rule 43 (else -> empty .)


state 245

    (34) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .

    ID              reduce using rule 34 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    READ            reduce using rule 34 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    WRITE           reduce using rule 34 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    FOR             reduce using rule 34 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    WHILE           reduce using rule 34 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    IF              reduce using rule 34 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    RETURN          reduce using rule 34 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    RCURLY          reduce using rule 34 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    SEMMICOLON      reduce using rule 34 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)


state 246

    (38) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .

    ID              reduce using rule 38 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    READ            reduce using rule 38 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    WRITE           reduce using rule 38 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    FOR             reduce using rule 38 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    WHILE           reduce using rule 38 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    IF              reduce using rule 38 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    RETURN          reduce using rule 38 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    RCURLY          reduce using rule 38 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    SEMMICOLON      reduce using rule 38 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)


state 247

    (41) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .

    ID              reduce using rule 41 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    READ            reduce using rule 41 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    WRITE           reduce using rule 41 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    FOR             reduce using rule 41 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    WHILE           reduce using rule 41 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    IF              reduce using rule 41 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    RETURN          reduce using rule 41 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    RCURLY          reduce using rule 41 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    SEMMICOLON      reduce using rule 41 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)


state 248

    (42) else -> ELSE generateQuadELSE . LCURLY statements RCURLY

    LCURLY          shift and go to state 249


state 249

    (42) else -> ELSE generateQuadELSE LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (18) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (22) functionCall -> . ID LPAREN exp RPAREN
    (23) read -> . READ operatorRead LPAREN var1 generateQuadREAD RPAREN
    (26) write -> . WRITE LPAREN writeOperator write1 generateQuadPRINT RPAREN
    (34) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (38) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (41) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (110) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (111) return -> . RETURN LPAREN exp RPAREN
    (112) empty -> .

    ID              shift and go to state 86
    READ            shift and go to state 87
    WRITE           shift and go to state 88
    FOR             shift and go to state 89
    WHILE           shift and go to state 90
    IF              shift and go to state 91
    RETURN          shift and go to state 92
    RCURLY          reduce using rule 112 (empty -> .)

    statements                     shift and go to state 250
    assign                         shift and go to state 77
    functionCall                   shift and go to state 78
    read                           shift and go to state 79
    write                          shift and go to state 80
    for                            shift and go to state 81
    while                          shift and go to state 82
    if                             shift and go to state 83
    return                         shift and go to state 84
    empty                          shift and go to state 85

state 250

    (42) else -> ELSE generateQuadELSE LCURLY statements . RCURLY

    RCURLY          shift and go to state 251


state 251

    (42) else -> ELSE generateQuadELSE LCURLY statements RCURLY .

    ID              reduce using rule 42 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    READ            reduce using rule 42 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    WRITE           reduce using rule 42 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    FOR             reduce using rule 42 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    WHILE           reduce using rule 42 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    IF              reduce using rule 42 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    RETURN          reduce using rule 42 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    RCURLY          reduce using rule 42 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 42 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PRINCIPAL in state 5 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 47 resolved as shift
WARNING: shift/reduce conflict for ID in state 52 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 53 resolved as shift
WARNING: shift/reduce conflict for ID in state 60 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 61 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MUL in state 68 resolved as shift
WARNING: shift/reduce conflict for DIV in state 68 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 75 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 75 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 140 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 140 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 140 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 140 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 140 resolved as shift
WARNING: shift/reduce conflict for ID in state 140 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 141 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 141 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 141 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 141 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 141 resolved as shift
WARNING: shift/reduce conflict for ID in state 141 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 142 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 142 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 142 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 142 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 142 resolved as shift
WARNING: shift/reduce conflict for ID in state 142 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 143 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 143 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 143 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 143 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 143 resolved as shift
WARNING: shift/reduce conflict for ID in state 143 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 144 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 144 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 144 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 144 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 144 resolved as shift
WARNING: shift/reduce conflict for ID in state 144 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 145 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 145 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 145 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 145 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 145 resolved as shift
WARNING: shift/reduce conflict for ID in state 145 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 146 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 146 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 146 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 146 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 146 resolved as shift
WARNING: shift/reduce conflict for ID in state 146 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 147 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 147 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 147 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 147 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 147 resolved as shift
WARNING: shift/reduce conflict for ID in state 147 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 148 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 148 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 148 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 148 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 148 resolved as shift
WARNING: shift/reduce conflict for ID in state 148 resolved as shift
WARNING: shift/reduce conflict for SEMMICOLON in state 192 resolved as shift
WARNING: reduce/reduce conflict in state 212 resolved using rule (generateQuadPRINT -> <empty>)
WARNING: rejected rule (pexp -> CTEI saveCTE) in state 212
WARNING: reduce/reduce conflict in state 213 resolved using rule (generateQuadPRINT -> <empty>)
WARNING: rejected rule (pexp -> CTEF saveCTE) in state 213
