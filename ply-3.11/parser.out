Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMILLA
    COMPARE
    END
    FROM
    MODA
    PLOTXY
    SIMPLEREGRESSION
    VARIANZA

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMMICOLON addProgram program1
Rule 2     addProgram -> <empty>
Rule 3     program1 -> vars mainQuad functions mainEnd program2
Rule 4     program1 -> vars mainQuad functions
Rule 5     program1 -> program2
Rule 6     program2 -> principal
Rule 7     principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY
Rule 8     mainQuad -> <empty>
Rule 9     mainEnd -> <empty>
Rule 10    statements -> assign SEMMICOLON statements
Rule 11    statements -> functionCall SEMMICOLON statements
Rule 12    statements -> read statements SEMMICOLON statements
Rule 13    statements -> write statements SEMMICOLON statements
Rule 14    statements -> for statements
Rule 15    statements -> while statements
Rule 16    statements -> if statements
Rule 17    statements -> return statements
Rule 18    statements -> empty
Rule 19    assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad
Rule 20    assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
Rule 21    generateAssignQuad -> <empty>
Rule 22    add_id -> <empty>
Rule 23    add_id2 -> <empty>
Rule 24    add_id3 -> <empty>
Rule 25    media -> MEDIA LPAREN arr RPAREN SEMMICOLON
Rule 26    functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
Rule 27    generateQuadPARAM -> <empty>
Rule 28    expAux -> exp
Rule 29    expAux -> exp COMMA expAux
Rule 30    expAux -> empty
Rule 31    generateQuadGOSUB -> <empty>
Rule 32    fillEndProc -> <empty>
Rule 33    functionERA -> <empty>
Rule 34    read -> READ operatorRead LPAREN paramReadAux RPAREN
Rule 35    paramRead -> paramReadAux
Rule 36    paramRead -> empty
Rule 37    paramReadAux -> exp generateQuadREAD
Rule 38    paramReadAux -> exp generateQuadREAD COMMA operatorRead paramReadAux
Rule 39    operatorRead -> <empty>
Rule 40    generateQuadREAD -> <empty>
Rule 41    write -> WRITE writeOperator LPAREN paramWrite RPAREN
Rule 42    paramWrite -> paramWriteAux
Rule 43    paramWrite -> empty
Rule 44    paramWriteAux -> exp generateQuadPRINT
Rule 45    paramWriteAux -> exp generateQuadPRINT COMMA writeOperator paramWriteAux
Rule 46    writeOperator -> <empty>
Rule 47    generateQuadPRINT -> <empty>
Rule 48    LoopEnd -> <empty>
Rule 49    for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
Rule 50    forOP -> <empty>
Rule 51    generateQuadFOR -> <empty>
Rule 52    while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
Rule 53    whileOP -> <empty>
Rule 54    generateQuadWHILE -> <empty>
Rule 55    if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
Rule 56    else -> ELSE generateQuadELSE LCURLY statements RCURLY
Rule 57    else -> empty
Rule 58    generateQuadIF -> <empty>
Rule 59    endIF -> <empty>
Rule 60    generateQuadELSE -> <empty>
Rule 61    exp -> nexp generateQuadOR
Rule 62    exp -> nexp generateQuadOR OR saveOperator nexp
Rule 63    generateQuadOR -> <empty>
Rule 64    nexp -> compexp generateQuadAND
Rule 65    nexp -> compexp generateQuadAND AND saveOperator compexp
Rule 66    generateQuadAND -> <empty>
Rule 67    compexp -> sumexp
Rule 68    compexp -> compexp1 sumexp
Rule 69    compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE
Rule 70    compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE
Rule 71    compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE
Rule 72    compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE
Rule 73    compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE
Rule 74    generateQuadCOMPARE -> <empty>
Rule 75    sumexp -> mulexp
Rule 76    sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM
Rule 77    sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM
Rule 78    generateQuadSUM -> <empty>
Rule 79    mulexp -> pexp
Rule 80    mulexp -> pexp MUL saveOperator pexp generateQuadMUL
Rule 81    mulexp -> pexp DIV saveOperator pexp generateQuadMUL
Rule 82    generateQuadMUL -> <empty>
Rule 83    pexp -> ID add_id2
Rule 84    pexp -> CTEI saveCTE
Rule 85    pexp -> CTEF saveCTE
Rule 86    pexp -> CTEC saveCTE
Rule 87    pexp -> CTESTRING saveCTE
Rule 88    pexp -> functionCall
Rule 89    pexp -> LPAREN exp RPAREN
Rule 90    pexp -> ID arr add_id3
Rule 91    pexp -> empty
Rule 92    saveCTE -> <empty>
Rule 93    saveOperator -> <empty>
Rule 94    vars -> var
Rule 95    vars -> empty
Rule 96    var -> VARS var2
Rule 97    var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar
Rule 98    var2 -> empty
Rule 99    var1 -> ID
Rule 100   var1 -> ID COMMA var1 addVar
Rule 101   var1 -> ID arr
Rule 102   var1 -> ID arr COMMA var1 addVar
Rule 103   var1 -> empty
Rule 104   addVar -> <empty>
Rule 105   saveTypeVar -> <empty>
Rule 106   type -> INT saveTypeVar
Rule 107   type -> CHAR saveTypeVar
Rule 108   type -> FLOAT saveTypeVar
Rule 109   arr -> LBRACKET CTEI RBRACKET
Rule 110   arr -> LBRACKET exp RBRACKET
Rule 111   functions -> FUNCTION INT functions1 endFunc functions
Rule 112   functions -> FUNCTION CHAR functions1 endFunc functions
Rule 113   functions -> FUNCTION FLOAT functions1 endFunc functions
Rule 114   functions -> FUNCTION VOID functions1 endFunc functions
Rule 115   functions -> empty
Rule 116   functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY statements RCURLY
Rule 117   functions1 -> empty
Rule 118   addParameter -> <empty>
Rule 119   parameters -> paramsAux
Rule 120   parameters -> empty
Rule 121   paramsAux -> INT saveTypeVar TWOPOINTS ID addParameter nextParam
Rule 122   paramsAux -> FLOAT saveTypeVar TWOPOINTS ID addParameter nextParam
Rule 123   paramsAux -> CHAR saveTypeVar TWOPOINTS ID addParameter nextParam
Rule 124   nextParam -> COMMA paramsAux
Rule 125   nextParam -> empty
Rule 126   endFunc -> <empty>
Rule 127   saveFunction -> <empty>
Rule 128   args -> args type TWOPOINTS var1 addVar
Rule 129   args -> empty
Rule 130   args1 -> ID addVar
Rule 131   args1 -> ID COMMA args1
Rule 132   args1 -> empty
Rule 133   return -> RETURN LPAREN exp RPAREN SEMMICOLON
Rule 134   return -> RETURN LPAREN exp RPAREN
Rule 135   empty -> <empty>

Terminals, with rules where they appear

AND                  : 65
CHAR                 : 107 112 123
COMILLA              : 
COMMA                : 29 38 45 100 102 124 131
COMPARE              : 
CTEC                 : 86
CTEF                 : 85
CTEI                 : 49 84 109
CTESTRING            : 87
DIV                  : 81
DO                   : 49 52
ELSE                 : 56
END                  : 
EQUALS               : 19 20
FLOAT                : 108 113 122
FOR                  : 49
FROM                 : 
FUNCTION             : 111 112 113 114
GT                   : 69
GTE                  : 71
ID                   : 1 19 20 26 83 90 99 100 101 102 116 121 122 123 130 131
IF                   : 55
INT                  : 106 111 121
LBRACKET             : 109 110
LCURLY               : 7 49 52 55 56 116
LPAREN               : 7 25 26 34 41 52 55 89 116 133 134
LT                   : 70
LTE                  : 72
MEDIA                : 25
MINUS                : 77
MODA                 : 
MUL                  : 80
NE                   : 73
OR                   : 62
PLOTXY               : 
PLUS                 : 76
PRINCIPAL            : 7
PROGRAM              : 1
RBRACKET             : 109 110
RCURLY               : 7 49 52 55 56 116
READ                 : 34
RETURN               : 133 134
RPAREN               : 7 25 26 34 41 52 55 89 116 133 134
SEMMICOLON           : 1 10 11 12 13 25 97 133
SIMPLEREGRESSION     : 
THEN                 : 55
TO                   : 49
TWOPOINTS            : 97 121 122 123 128
VARIANZA             : 
VARS                 : 96
VOID                 : 114
WHILE                : 52
WRITE                : 41
error                : 

Nonterminals, with rules where they appear

LoopEnd              : 49 52
addParameter         : 121 122 123
addProgram           : 1
addVar               : 97 100 102 128 130
add_id               : 
add_id2              : 19 20 83
add_id3              : 90
args                 : 128
args1                : 131
arr                  : 20 25 90 101 102
assign               : 10 49
compexp              : 64 65 65
compexp1             : 68
else                 : 55
empty                : 18 30 36 43 57 91 95 98 103 115 117 120 125 129 132
endFunc              : 111 112 113 114
endIF                : 55
exp                  : 19 20 28 29 37 38 44 45 52 55 89 110 133 134
expAux               : 26 29
fillEndProc          : 
for                  : 14
forOP                : 49
functionCall         : 11 88
functionERA          : 26
functions            : 3 4 111 112 113 114
functions1           : 111 112 113 114
generateAssignQuad   : 19 20
generateQuadAND      : 64 65
generateQuadCOMPARE  : 69 70 71 72 73
generateQuadELSE     : 56
generateQuadFOR      : 49
generateQuadGOSUB    : 26
generateQuadIF       : 55
generateQuadMUL      : 80 81
generateQuadOR       : 61 62
generateQuadPARAM    : 26
generateQuadPRINT    : 44 45
generateQuadREAD     : 37 38
generateQuadSUM      : 76 77
generateQuadWHILE    : 52
if                   : 16
mainEnd              : 3
mainQuad             : 3 4
media                : 
mulexp               : 75 76 76 77 77
nexp                 : 61 62 62
nextParam            : 121 122 123
operatorRead         : 34 38
paramRead            : 
paramReadAux         : 34 35 38
paramWrite           : 41
paramWriteAux        : 42 45
parameters           : 116
paramsAux            : 119 124
pexp                 : 79 80 80 81 81
principal            : 6
program              : 0
program1             : 1
program2             : 3 5
read                 : 12
return               : 17
saveCTE              : 84 85 86 87
saveFunction         : 7 116
saveOperator         : 19 20 62 65 69 70 71 72 73 76 77 80 81
saveTypeVar          : 106 107 108 121 122 123
statements           : 7 10 11 12 12 13 13 14 15 16 17 49 52 55 56 116
sumexp               : 67 68 69 69 70 70 71 71 72 72 73 73
type                 : 97 128
var                  : 94
var1                 : 97 100 102 128
var2                 : 96 97
vars                 : 3 4 7 116
while                : 15
whileOP              : 52
write                : 13
writeOperator        : 41 45

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMMICOLON addProgram program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMMICOLON addProgram program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMMICOLON addProgram program1

    SEMMICOLON      shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMMICOLON . addProgram program1
    (2) addProgram -> .

    VARS            reduce using rule 2 (addProgram -> .)
    PRINCIPAL       reduce using rule 2 (addProgram -> .)
    FUNCTION        reduce using rule 2 (addProgram -> .)
    $end            reduce using rule 2 (addProgram -> .)

    addProgram                     shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMMICOLON addProgram . program1
    (3) program1 -> . vars mainQuad functions mainEnd program2
    (4) program1 -> . vars mainQuad functions
    (5) program1 -> . program2
    (94) vars -> . var
    (95) vars -> . empty
    (6) program2 -> . principal
    (96) var -> . VARS var2
    (135) empty -> .
    (7) principal -> . PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY

  ! shift/reduce conflict for PRINCIPAL resolved as shift
    VARS            shift and go to state 12
    FUNCTION        reduce using rule 135 (empty -> .)
    $end            reduce using rule 135 (empty -> .)
    PRINCIPAL       shift and go to state 13

  ! PRINCIPAL       [ reduce using rule 135 (empty -> .) ]

    program1                       shift and go to state 6
    vars                           shift and go to state 7
    program2                       shift and go to state 8
    var                            shift and go to state 9
    empty                          shift and go to state 10
    principal                      shift and go to state 11

state 6

    (1) program -> PROGRAM ID SEMMICOLON addProgram program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMMICOLON addProgram program1 .)


state 7

    (3) program1 -> vars . mainQuad functions mainEnd program2
    (4) program1 -> vars . mainQuad functions
    (8) mainQuad -> .

    FUNCTION        reduce using rule 8 (mainQuad -> .)
    PRINCIPAL       reduce using rule 8 (mainQuad -> .)
    $end            reduce using rule 8 (mainQuad -> .)

    mainQuad                       shift and go to state 14

state 8

    (5) program1 -> program2 .

    $end            reduce using rule 5 (program1 -> program2 .)


state 9

    (94) vars -> var .

    FUNCTION        reduce using rule 94 (vars -> var .)
    PRINCIPAL       reduce using rule 94 (vars -> var .)
    $end            reduce using rule 94 (vars -> var .)
    ID              reduce using rule 94 (vars -> var .)
    READ            reduce using rule 94 (vars -> var .)
    WRITE           reduce using rule 94 (vars -> var .)
    FOR             reduce using rule 94 (vars -> var .)
    WHILE           reduce using rule 94 (vars -> var .)
    IF              reduce using rule 94 (vars -> var .)
    RETURN          reduce using rule 94 (vars -> var .)
    RCURLY          reduce using rule 94 (vars -> var .)
    LCURLY          reduce using rule 94 (vars -> var .)


state 10

    (95) vars -> empty .

    FUNCTION        reduce using rule 95 (vars -> empty .)
    PRINCIPAL       reduce using rule 95 (vars -> empty .)
    $end            reduce using rule 95 (vars -> empty .)
    ID              reduce using rule 95 (vars -> empty .)
    READ            reduce using rule 95 (vars -> empty .)
    WRITE           reduce using rule 95 (vars -> empty .)
    FOR             reduce using rule 95 (vars -> empty .)
    WHILE           reduce using rule 95 (vars -> empty .)
    IF              reduce using rule 95 (vars -> empty .)
    RETURN          reduce using rule 95 (vars -> empty .)
    RCURLY          reduce using rule 95 (vars -> empty .)
    LCURLY          reduce using rule 95 (vars -> empty .)


state 11

    (6) program2 -> principal .

    $end            reduce using rule 6 (program2 -> principal .)


state 12

    (96) var -> VARS . var2
    (97) var2 -> . var2 type TWOPOINTS var1 SEMMICOLON addVar
    (98) var2 -> . empty
    (135) empty -> .

    INT             reduce using rule 135 (empty -> .)
    CHAR            reduce using rule 135 (empty -> .)
    FLOAT           reduce using rule 135 (empty -> .)
    FUNCTION        reduce using rule 135 (empty -> .)
    PRINCIPAL       reduce using rule 135 (empty -> .)
    $end            reduce using rule 135 (empty -> .)
    ID              reduce using rule 135 (empty -> .)
    READ            reduce using rule 135 (empty -> .)
    WRITE           reduce using rule 135 (empty -> .)
    FOR             reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    RCURLY          reduce using rule 135 (empty -> .)
    LCURLY          reduce using rule 135 (empty -> .)

    var2                           shift and go to state 15
    empty                          shift and go to state 16

state 13

    (7) principal -> PRINCIPAL . saveFunction LPAREN RPAREN LCURLY vars statements RCURLY
    (127) saveFunction -> .

    LPAREN          reduce using rule 127 (saveFunction -> .)

    saveFunction                   shift and go to state 17

state 14

    (3) program1 -> vars mainQuad . functions mainEnd program2
    (4) program1 -> vars mainQuad . functions
    (111) functions -> . FUNCTION INT functions1 endFunc functions
    (112) functions -> . FUNCTION CHAR functions1 endFunc functions
    (113) functions -> . FUNCTION FLOAT functions1 endFunc functions
    (114) functions -> . FUNCTION VOID functions1 endFunc functions
    (115) functions -> . empty
    (135) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 135 (empty -> .)
    $end            reduce using rule 135 (empty -> .)

    functions                      shift and go to state 18
    empty                          shift and go to state 20

state 15

    (96) var -> VARS var2 .
    (97) var2 -> var2 . type TWOPOINTS var1 SEMMICOLON addVar
    (106) type -> . INT saveTypeVar
    (107) type -> . CHAR saveTypeVar
    (108) type -> . FLOAT saveTypeVar

    FUNCTION        reduce using rule 96 (var -> VARS var2 .)
    PRINCIPAL       reduce using rule 96 (var -> VARS var2 .)
    $end            reduce using rule 96 (var -> VARS var2 .)
    ID              reduce using rule 96 (var -> VARS var2 .)
    READ            reduce using rule 96 (var -> VARS var2 .)
    WRITE           reduce using rule 96 (var -> VARS var2 .)
    FOR             reduce using rule 96 (var -> VARS var2 .)
    WHILE           reduce using rule 96 (var -> VARS var2 .)
    IF              reduce using rule 96 (var -> VARS var2 .)
    RETURN          reduce using rule 96 (var -> VARS var2 .)
    RCURLY          reduce using rule 96 (var -> VARS var2 .)
    LCURLY          reduce using rule 96 (var -> VARS var2 .)
    INT             shift and go to state 22
    CHAR            shift and go to state 23
    FLOAT           shift and go to state 24

    type                           shift and go to state 21

state 16

    (98) var2 -> empty .

    INT             reduce using rule 98 (var2 -> empty .)
    CHAR            reduce using rule 98 (var2 -> empty .)
    FLOAT           reduce using rule 98 (var2 -> empty .)
    FUNCTION        reduce using rule 98 (var2 -> empty .)
    PRINCIPAL       reduce using rule 98 (var2 -> empty .)
    $end            reduce using rule 98 (var2 -> empty .)
    ID              reduce using rule 98 (var2 -> empty .)
    READ            reduce using rule 98 (var2 -> empty .)
    WRITE           reduce using rule 98 (var2 -> empty .)
    FOR             reduce using rule 98 (var2 -> empty .)
    WHILE           reduce using rule 98 (var2 -> empty .)
    IF              reduce using rule 98 (var2 -> empty .)
    RETURN          reduce using rule 98 (var2 -> empty .)
    RCURLY          reduce using rule 98 (var2 -> empty .)
    LCURLY          reduce using rule 98 (var2 -> empty .)


state 17

    (7) principal -> PRINCIPAL saveFunction . LPAREN RPAREN LCURLY vars statements RCURLY

    LPAREN          shift and go to state 25


state 18

    (3) program1 -> vars mainQuad functions . mainEnd program2
    (4) program1 -> vars mainQuad functions .
    (9) mainEnd -> .

    $end            reduce using rule 4 (program1 -> vars mainQuad functions .)
    PRINCIPAL       reduce using rule 9 (mainEnd -> .)

    mainEnd                        shift and go to state 26

state 19

    (111) functions -> FUNCTION . INT functions1 endFunc functions
    (112) functions -> FUNCTION . CHAR functions1 endFunc functions
    (113) functions -> FUNCTION . FLOAT functions1 endFunc functions
    (114) functions -> FUNCTION . VOID functions1 endFunc functions

    INT             shift and go to state 27
    CHAR            shift and go to state 28
    FLOAT           shift and go to state 29
    VOID            shift and go to state 30


state 20

    (115) functions -> empty .

    PRINCIPAL       reduce using rule 115 (functions -> empty .)
    $end            reduce using rule 115 (functions -> empty .)


state 21

    (97) var2 -> var2 type . TWOPOINTS var1 SEMMICOLON addVar

    TWOPOINTS       shift and go to state 31


state 22

    (106) type -> INT . saveTypeVar
    (105) saveTypeVar -> .

    TWOPOINTS       reduce using rule 105 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 32

state 23

    (107) type -> CHAR . saveTypeVar
    (105) saveTypeVar -> .

    TWOPOINTS       reduce using rule 105 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 33

state 24

    (108) type -> FLOAT . saveTypeVar
    (105) saveTypeVar -> .

    TWOPOINTS       reduce using rule 105 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 34

state 25

    (7) principal -> PRINCIPAL saveFunction LPAREN . RPAREN LCURLY vars statements RCURLY

    RPAREN          shift and go to state 35


state 26

    (3) program1 -> vars mainQuad functions mainEnd . program2
    (6) program2 -> . principal
    (7) principal -> . PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY

    PRINCIPAL       shift and go to state 13

    program2                       shift and go to state 36
    principal                      shift and go to state 11

state 27

    (111) functions -> FUNCTION INT . functions1 endFunc functions
    (116) functions1 -> . ID saveFunction LPAREN parameters RPAREN vars LCURLY statements RCURLY
    (117) functions1 -> . empty
    (135) empty -> .

    ID              shift and go to state 38
    FUNCTION        reduce using rule 135 (empty -> .)
    PRINCIPAL       reduce using rule 135 (empty -> .)
    $end            reduce using rule 135 (empty -> .)

    functions1                     shift and go to state 37
    empty                          shift and go to state 39

state 28

    (112) functions -> FUNCTION CHAR . functions1 endFunc functions
    (116) functions1 -> . ID saveFunction LPAREN parameters RPAREN vars LCURLY statements RCURLY
    (117) functions1 -> . empty
    (135) empty -> .

    ID              shift and go to state 38
    FUNCTION        reduce using rule 135 (empty -> .)
    PRINCIPAL       reduce using rule 135 (empty -> .)
    $end            reduce using rule 135 (empty -> .)

    functions1                     shift and go to state 40
    empty                          shift and go to state 39

state 29

    (113) functions -> FUNCTION FLOAT . functions1 endFunc functions
    (116) functions1 -> . ID saveFunction LPAREN parameters RPAREN vars LCURLY statements RCURLY
    (117) functions1 -> . empty
    (135) empty -> .

    ID              shift and go to state 38
    FUNCTION        reduce using rule 135 (empty -> .)
    PRINCIPAL       reduce using rule 135 (empty -> .)
    $end            reduce using rule 135 (empty -> .)

    functions1                     shift and go to state 41
    empty                          shift and go to state 39

state 30

    (114) functions -> FUNCTION VOID . functions1 endFunc functions
    (116) functions1 -> . ID saveFunction LPAREN parameters RPAREN vars LCURLY statements RCURLY
    (117) functions1 -> . empty
    (135) empty -> .

    ID              shift and go to state 38
    FUNCTION        reduce using rule 135 (empty -> .)
    PRINCIPAL       reduce using rule 135 (empty -> .)
    $end            reduce using rule 135 (empty -> .)

    functions1                     shift and go to state 42
    empty                          shift and go to state 39

state 31

    (97) var2 -> var2 type TWOPOINTS . var1 SEMMICOLON addVar
    (99) var1 -> . ID
    (100) var1 -> . ID COMMA var1 addVar
    (101) var1 -> . ID arr
    (102) var1 -> . ID arr COMMA var1 addVar
    (103) var1 -> . empty
    (135) empty -> .

    ID              shift and go to state 44
    SEMMICOLON      reduce using rule 135 (empty -> .)

    var1                           shift and go to state 43
    empty                          shift and go to state 45

state 32

    (106) type -> INT saveTypeVar .

    TWOPOINTS       reduce using rule 106 (type -> INT saveTypeVar .)


state 33

    (107) type -> CHAR saveTypeVar .

    TWOPOINTS       reduce using rule 107 (type -> CHAR saveTypeVar .)


state 34

    (108) type -> FLOAT saveTypeVar .

    TWOPOINTS       reduce using rule 108 (type -> FLOAT saveTypeVar .)


state 35

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN . LCURLY vars statements RCURLY

    LCURLY          shift and go to state 46


state 36

    (3) program1 -> vars mainQuad functions mainEnd program2 .

    $end            reduce using rule 3 (program1 -> vars mainQuad functions mainEnd program2 .)


state 37

    (111) functions -> FUNCTION INT functions1 . endFunc functions
    (126) endFunc -> .

    FUNCTION        reduce using rule 126 (endFunc -> .)
    PRINCIPAL       reduce using rule 126 (endFunc -> .)
    $end            reduce using rule 126 (endFunc -> .)

    endFunc                        shift and go to state 47

state 38

    (116) functions1 -> ID . saveFunction LPAREN parameters RPAREN vars LCURLY statements RCURLY
    (127) saveFunction -> .

    LPAREN          reduce using rule 127 (saveFunction -> .)

    saveFunction                   shift and go to state 48

state 39

    (117) functions1 -> empty .

    FUNCTION        reduce using rule 117 (functions1 -> empty .)
    PRINCIPAL       reduce using rule 117 (functions1 -> empty .)
    $end            reduce using rule 117 (functions1 -> empty .)


state 40

    (112) functions -> FUNCTION CHAR functions1 . endFunc functions
    (126) endFunc -> .

    FUNCTION        reduce using rule 126 (endFunc -> .)
    PRINCIPAL       reduce using rule 126 (endFunc -> .)
    $end            reduce using rule 126 (endFunc -> .)

    endFunc                        shift and go to state 49

state 41

    (113) functions -> FUNCTION FLOAT functions1 . endFunc functions
    (126) endFunc -> .

    FUNCTION        reduce using rule 126 (endFunc -> .)
    PRINCIPAL       reduce using rule 126 (endFunc -> .)
    $end            reduce using rule 126 (endFunc -> .)

    endFunc                        shift and go to state 50

state 42

    (114) functions -> FUNCTION VOID functions1 . endFunc functions
    (126) endFunc -> .

    FUNCTION        reduce using rule 126 (endFunc -> .)
    PRINCIPAL       reduce using rule 126 (endFunc -> .)
    $end            reduce using rule 126 (endFunc -> .)

    endFunc                        shift and go to state 51

state 43

    (97) var2 -> var2 type TWOPOINTS var1 . SEMMICOLON addVar

    SEMMICOLON      shift and go to state 52


state 44

    (99) var1 -> ID .
    (100) var1 -> ID . COMMA var1 addVar
    (101) var1 -> ID . arr
    (102) var1 -> ID . arr COMMA var1 addVar
    (109) arr -> . LBRACKET CTEI RBRACKET
    (110) arr -> . LBRACKET exp RBRACKET

    SEMMICOLON      reduce using rule 99 (var1 -> ID .)
    COMMA           shift and go to state 53
    LBRACKET        shift and go to state 55

    arr                            shift and go to state 54

state 45

    (103) var1 -> empty .

    SEMMICOLON      reduce using rule 103 (var1 -> empty .)


state 46

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY . vars statements RCURLY
    (94) vars -> . var
    (95) vars -> . empty
    (96) var -> . VARS var2
    (135) empty -> .

    VARS            shift and go to state 12
    ID              reduce using rule 135 (empty -> .)
    READ            reduce using rule 135 (empty -> .)
    WRITE           reduce using rule 135 (empty -> .)
    FOR             reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    RCURLY          reduce using rule 135 (empty -> .)

    vars                           shift and go to state 56
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 47

    (111) functions -> FUNCTION INT functions1 endFunc . functions
    (111) functions -> . FUNCTION INT functions1 endFunc functions
    (112) functions -> . FUNCTION CHAR functions1 endFunc functions
    (113) functions -> . FUNCTION FLOAT functions1 endFunc functions
    (114) functions -> . FUNCTION VOID functions1 endFunc functions
    (115) functions -> . empty
    (135) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 135 (empty -> .)
    $end            reduce using rule 135 (empty -> .)

    functions                      shift and go to state 57
    empty                          shift and go to state 20

state 48

    (116) functions1 -> ID saveFunction . LPAREN parameters RPAREN vars LCURLY statements RCURLY

    LPAREN          shift and go to state 58


state 49

    (112) functions -> FUNCTION CHAR functions1 endFunc . functions
    (111) functions -> . FUNCTION INT functions1 endFunc functions
    (112) functions -> . FUNCTION CHAR functions1 endFunc functions
    (113) functions -> . FUNCTION FLOAT functions1 endFunc functions
    (114) functions -> . FUNCTION VOID functions1 endFunc functions
    (115) functions -> . empty
    (135) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 135 (empty -> .)
    $end            reduce using rule 135 (empty -> .)

    functions                      shift and go to state 59
    empty                          shift and go to state 20

state 50

    (113) functions -> FUNCTION FLOAT functions1 endFunc . functions
    (111) functions -> . FUNCTION INT functions1 endFunc functions
    (112) functions -> . FUNCTION CHAR functions1 endFunc functions
    (113) functions -> . FUNCTION FLOAT functions1 endFunc functions
    (114) functions -> . FUNCTION VOID functions1 endFunc functions
    (115) functions -> . empty
    (135) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 135 (empty -> .)
    $end            reduce using rule 135 (empty -> .)

    functions                      shift and go to state 60
    empty                          shift and go to state 20

state 51

    (114) functions -> FUNCTION VOID functions1 endFunc . functions
    (111) functions -> . FUNCTION INT functions1 endFunc functions
    (112) functions -> . FUNCTION CHAR functions1 endFunc functions
    (113) functions -> . FUNCTION FLOAT functions1 endFunc functions
    (114) functions -> . FUNCTION VOID functions1 endFunc functions
    (115) functions -> . empty
    (135) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 135 (empty -> .)
    $end            reduce using rule 135 (empty -> .)

    functions                      shift and go to state 61
    empty                          shift and go to state 20

state 52

    (97) var2 -> var2 type TWOPOINTS var1 SEMMICOLON . addVar
    (104) addVar -> .

    INT             reduce using rule 104 (addVar -> .)
    CHAR            reduce using rule 104 (addVar -> .)
    FLOAT           reduce using rule 104 (addVar -> .)
    FUNCTION        reduce using rule 104 (addVar -> .)
    PRINCIPAL       reduce using rule 104 (addVar -> .)
    $end            reduce using rule 104 (addVar -> .)
    ID              reduce using rule 104 (addVar -> .)
    READ            reduce using rule 104 (addVar -> .)
    WRITE           reduce using rule 104 (addVar -> .)
    FOR             reduce using rule 104 (addVar -> .)
    WHILE           reduce using rule 104 (addVar -> .)
    IF              reduce using rule 104 (addVar -> .)
    RETURN          reduce using rule 104 (addVar -> .)
    RCURLY          reduce using rule 104 (addVar -> .)
    LCURLY          reduce using rule 104 (addVar -> .)

    addVar                         shift and go to state 62

state 53

    (100) var1 -> ID COMMA . var1 addVar
    (99) var1 -> . ID
    (100) var1 -> . ID COMMA var1 addVar
    (101) var1 -> . ID arr
    (102) var1 -> . ID arr COMMA var1 addVar
    (103) var1 -> . empty
    (135) empty -> .

    ID              shift and go to state 44
    SEMMICOLON      reduce using rule 135 (empty -> .)

    var1                           shift and go to state 63
    empty                          shift and go to state 45

state 54

    (101) var1 -> ID arr .
    (102) var1 -> ID arr . COMMA var1 addVar

    SEMMICOLON      reduce using rule 101 (var1 -> ID arr .)
    COMMA           shift and go to state 64


state 55

    (109) arr -> LBRACKET . CTEI RBRACKET
    (110) arr -> LBRACKET . exp RBRACKET
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    CTEI            shift and go to state 65
    ID              shift and go to state 73
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)

    exp                            shift and go to state 66
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 56

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars . statements RCURLY
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)

    statements                     shift and go to state 80
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 57

    (111) functions -> FUNCTION INT functions1 endFunc functions .

    PRINCIPAL       reduce using rule 111 (functions -> FUNCTION INT functions1 endFunc functions .)
    $end            reduce using rule 111 (functions -> FUNCTION INT functions1 endFunc functions .)


state 58

    (116) functions1 -> ID saveFunction LPAREN . parameters RPAREN vars LCURLY statements RCURLY
    (119) parameters -> . paramsAux
    (120) parameters -> . empty
    (121) paramsAux -> . INT saveTypeVar TWOPOINTS ID addParameter nextParam
    (122) paramsAux -> . FLOAT saveTypeVar TWOPOINTS ID addParameter nextParam
    (123) paramsAux -> . CHAR saveTypeVar TWOPOINTS ID addParameter nextParam
    (135) empty -> .

    INT             shift and go to state 100
    FLOAT           shift and go to state 101
    CHAR            shift and go to state 102
    RPAREN          reduce using rule 135 (empty -> .)

    parameters                     shift and go to state 97
    paramsAux                      shift and go to state 98
    empty                          shift and go to state 99

state 59

    (112) functions -> FUNCTION CHAR functions1 endFunc functions .

    PRINCIPAL       reduce using rule 112 (functions -> FUNCTION CHAR functions1 endFunc functions .)
    $end            reduce using rule 112 (functions -> FUNCTION CHAR functions1 endFunc functions .)


state 60

    (113) functions -> FUNCTION FLOAT functions1 endFunc functions .

    PRINCIPAL       reduce using rule 113 (functions -> FUNCTION FLOAT functions1 endFunc functions .)
    $end            reduce using rule 113 (functions -> FUNCTION FLOAT functions1 endFunc functions .)


state 61

    (114) functions -> FUNCTION VOID functions1 endFunc functions .

    PRINCIPAL       reduce using rule 114 (functions -> FUNCTION VOID functions1 endFunc functions .)
    $end            reduce using rule 114 (functions -> FUNCTION VOID functions1 endFunc functions .)


state 62

    (97) var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .

    INT             reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    CHAR            reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FLOAT           reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FUNCTION        reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    PRINCIPAL       reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    $end            reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    ID              reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    READ            reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WRITE           reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FOR             reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WHILE           reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    IF              reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    RETURN          reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    RCURLY          reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    LCURLY          reduce using rule 97 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)


state 63

    (100) var1 -> ID COMMA var1 . addVar
    (104) addVar -> .

    SEMMICOLON      reduce using rule 104 (addVar -> .)

    addVar                         shift and go to state 103

state 64

    (102) var1 -> ID arr COMMA . var1 addVar
    (99) var1 -> . ID
    (100) var1 -> . ID COMMA var1 addVar
    (101) var1 -> . ID arr
    (102) var1 -> . ID arr COMMA var1 addVar
    (103) var1 -> . empty
    (135) empty -> .

    ID              shift and go to state 44
    SEMMICOLON      reduce using rule 135 (empty -> .)

    var1                           shift and go to state 104
    empty                          shift and go to state 45

state 65

    (109) arr -> LBRACKET CTEI . RBRACKET
    (84) pexp -> CTEI . saveCTE
    (92) saveCTE -> .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 105
    MUL             reduce using rule 92 (saveCTE -> .)
    DIV             reduce using rule 92 (saveCTE -> .)
    PLUS            reduce using rule 92 (saveCTE -> .)
    MINUS           reduce using rule 92 (saveCTE -> .)
    GT              reduce using rule 92 (saveCTE -> .)
    LT              reduce using rule 92 (saveCTE -> .)
    GTE             reduce using rule 92 (saveCTE -> .)
    LTE             reduce using rule 92 (saveCTE -> .)
    NE              reduce using rule 92 (saveCTE -> .)
    AND             reduce using rule 92 (saveCTE -> .)
    OR              reduce using rule 92 (saveCTE -> .)

  ! RBRACKET        [ reduce using rule 92 (saveCTE -> .) ]

    saveCTE                        shift and go to state 106

state 66

    (110) arr -> LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 107


state 67

    (61) exp -> nexp . generateQuadOR
    (62) exp -> nexp . generateQuadOR OR saveOperator nexp
    (63) generateQuadOR -> .

    OR              reduce using rule 63 (generateQuadOR -> .)
    RBRACKET        reduce using rule 63 (generateQuadOR -> .)
    RPAREN          reduce using rule 63 (generateQuadOR -> .)
    COMMA           reduce using rule 63 (generateQuadOR -> .)
    SEMMICOLON      reduce using rule 63 (generateQuadOR -> .)
    TO              reduce using rule 63 (generateQuadOR -> .)

    generateQuadOR                 shift and go to state 108

state 68

    (64) nexp -> compexp . generateQuadAND
    (65) nexp -> compexp . generateQuadAND AND saveOperator compexp
    (66) generateQuadAND -> .

    AND             reduce using rule 66 (generateQuadAND -> .)
    OR              reduce using rule 66 (generateQuadAND -> .)
    RBRACKET        reduce using rule 66 (generateQuadAND -> .)
    RPAREN          reduce using rule 66 (generateQuadAND -> .)
    COMMA           reduce using rule 66 (generateQuadAND -> .)
    SEMMICOLON      reduce using rule 66 (generateQuadAND -> .)
    TO              reduce using rule 66 (generateQuadAND -> .)

    generateQuadAND                shift and go to state 109

state 69

    (67) compexp -> sumexp .
    (69) compexp1 -> sumexp . GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> sumexp . LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> sumexp . GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> sumexp . LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> sumexp . NE saveOperator sumexp generateQuadCOMPARE

    AND             reduce using rule 67 (compexp -> sumexp .)
    OR              reduce using rule 67 (compexp -> sumexp .)
    RBRACKET        reduce using rule 67 (compexp -> sumexp .)
    RPAREN          reduce using rule 67 (compexp -> sumexp .)
    COMMA           reduce using rule 67 (compexp -> sumexp .)
    SEMMICOLON      reduce using rule 67 (compexp -> sumexp .)
    TO              reduce using rule 67 (compexp -> sumexp .)
    GT              shift and go to state 110
    LT              shift and go to state 111
    GTE             shift and go to state 112
    LTE             shift and go to state 113
    NE              shift and go to state 114


state 70

    (68) compexp -> compexp1 . sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)

    sumexp                         shift and go to state 115
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 71

    (75) sumexp -> mulexp .
    (76) sumexp -> mulexp . PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> mulexp . MINUS saveOperator mulexp generateQuadSUM

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    GT              reduce using rule 75 (sumexp -> mulexp .)
    LT              reduce using rule 75 (sumexp -> mulexp .)
    GTE             reduce using rule 75 (sumexp -> mulexp .)
    LTE             reduce using rule 75 (sumexp -> mulexp .)
    NE              reduce using rule 75 (sumexp -> mulexp .)
    AND             reduce using rule 75 (sumexp -> mulexp .)
    OR              reduce using rule 75 (sumexp -> mulexp .)
    RBRACKET        reduce using rule 75 (sumexp -> mulexp .)
    RPAREN          reduce using rule 75 (sumexp -> mulexp .)
    COMMA           reduce using rule 75 (sumexp -> mulexp .)
    SEMMICOLON      reduce using rule 75 (sumexp -> mulexp .)
    TO              reduce using rule 75 (sumexp -> mulexp .)
    ID              reduce using rule 75 (sumexp -> mulexp .)
    CTEI            reduce using rule 75 (sumexp -> mulexp .)
    CTEF            reduce using rule 75 (sumexp -> mulexp .)
    CTEC            reduce using rule 75 (sumexp -> mulexp .)
    CTESTRING       reduce using rule 75 (sumexp -> mulexp .)
    LPAREN          reduce using rule 75 (sumexp -> mulexp .)
    MUL             reduce using rule 75 (sumexp -> mulexp .)
    DIV             reduce using rule 75 (sumexp -> mulexp .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118

  ! PLUS            [ reduce using rule 75 (sumexp -> mulexp .) ]
  ! MINUS           [ reduce using rule 75 (sumexp -> mulexp .) ]


state 72

    (79) mulexp -> pexp .
    (80) mulexp -> pexp . MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> pexp . DIV saveOperator pexp generateQuadMUL

  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    PLUS            reduce using rule 79 (mulexp -> pexp .)
    MINUS           reduce using rule 79 (mulexp -> pexp .)
    GT              reduce using rule 79 (mulexp -> pexp .)
    LT              reduce using rule 79 (mulexp -> pexp .)
    GTE             reduce using rule 79 (mulexp -> pexp .)
    LTE             reduce using rule 79 (mulexp -> pexp .)
    NE              reduce using rule 79 (mulexp -> pexp .)
    AND             reduce using rule 79 (mulexp -> pexp .)
    OR              reduce using rule 79 (mulexp -> pexp .)
    RBRACKET        reduce using rule 79 (mulexp -> pexp .)
    RPAREN          reduce using rule 79 (mulexp -> pexp .)
    COMMA           reduce using rule 79 (mulexp -> pexp .)
    SEMMICOLON      reduce using rule 79 (mulexp -> pexp .)
    TO              reduce using rule 79 (mulexp -> pexp .)
    ID              reduce using rule 79 (mulexp -> pexp .)
    CTEI            reduce using rule 79 (mulexp -> pexp .)
    CTEF            reduce using rule 79 (mulexp -> pexp .)
    CTEC            reduce using rule 79 (mulexp -> pexp .)
    CTESTRING       reduce using rule 79 (mulexp -> pexp .)
    LPAREN          reduce using rule 79 (mulexp -> pexp .)
    MUL             shift and go to state 119
    DIV             shift and go to state 120

  ! MUL             [ reduce using rule 79 (mulexp -> pexp .) ]
  ! DIV             [ reduce using rule 79 (mulexp -> pexp .) ]


state 73

    (83) pexp -> ID . add_id2
    (90) pexp -> ID . arr add_id3
    (26) functionCall -> ID . functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (23) add_id2 -> .
    (109) arr -> . LBRACKET CTEI RBRACKET
    (110) arr -> . LBRACKET exp RBRACKET
    (33) functionERA -> .

  ! reduce/reduce conflict for LPAREN resolved using rule 23 (add_id2 -> .)
    MUL             reduce using rule 23 (add_id2 -> .)
    DIV             reduce using rule 23 (add_id2 -> .)
    PLUS            reduce using rule 23 (add_id2 -> .)
    MINUS           reduce using rule 23 (add_id2 -> .)
    GT              reduce using rule 23 (add_id2 -> .)
    LT              reduce using rule 23 (add_id2 -> .)
    GTE             reduce using rule 23 (add_id2 -> .)
    LTE             reduce using rule 23 (add_id2 -> .)
    NE              reduce using rule 23 (add_id2 -> .)
    AND             reduce using rule 23 (add_id2 -> .)
    OR              reduce using rule 23 (add_id2 -> .)
    RBRACKET        reduce using rule 23 (add_id2 -> .)
    RPAREN          reduce using rule 23 (add_id2 -> .)
    COMMA           reduce using rule 23 (add_id2 -> .)
    SEMMICOLON      reduce using rule 23 (add_id2 -> .)
    TO              reduce using rule 23 (add_id2 -> .)
    ID              reduce using rule 23 (add_id2 -> .)
    CTEI            reduce using rule 23 (add_id2 -> .)
    CTEF            reduce using rule 23 (add_id2 -> .)
    CTEC            reduce using rule 23 (add_id2 -> .)
    CTESTRING       reduce using rule 23 (add_id2 -> .)
    LPAREN          reduce using rule 23 (add_id2 -> .)
    LBRACKET        shift and go to state 55

  ! LPAREN          [ reduce using rule 33 (functionERA -> .) ]

    add_id2                        shift and go to state 121
    arr                            shift and go to state 122
    functionERA                    shift and go to state 123

state 74

    (85) pexp -> CTEF . saveCTE
    (92) saveCTE -> .

    MUL             reduce using rule 92 (saveCTE -> .)
    DIV             reduce using rule 92 (saveCTE -> .)
    PLUS            reduce using rule 92 (saveCTE -> .)
    MINUS           reduce using rule 92 (saveCTE -> .)
    GT              reduce using rule 92 (saveCTE -> .)
    LT              reduce using rule 92 (saveCTE -> .)
    GTE             reduce using rule 92 (saveCTE -> .)
    LTE             reduce using rule 92 (saveCTE -> .)
    NE              reduce using rule 92 (saveCTE -> .)
    AND             reduce using rule 92 (saveCTE -> .)
    OR              reduce using rule 92 (saveCTE -> .)
    RBRACKET        reduce using rule 92 (saveCTE -> .)
    RPAREN          reduce using rule 92 (saveCTE -> .)
    COMMA           reduce using rule 92 (saveCTE -> .)
    SEMMICOLON      reduce using rule 92 (saveCTE -> .)
    TO              reduce using rule 92 (saveCTE -> .)
    ID              reduce using rule 92 (saveCTE -> .)
    CTEI            reduce using rule 92 (saveCTE -> .)
    CTEF            reduce using rule 92 (saveCTE -> .)
    CTEC            reduce using rule 92 (saveCTE -> .)
    CTESTRING       reduce using rule 92 (saveCTE -> .)
    LPAREN          reduce using rule 92 (saveCTE -> .)

    saveCTE                        shift and go to state 124

state 75

    (86) pexp -> CTEC . saveCTE
    (92) saveCTE -> .

    MUL             reduce using rule 92 (saveCTE -> .)
    DIV             reduce using rule 92 (saveCTE -> .)
    PLUS            reduce using rule 92 (saveCTE -> .)
    MINUS           reduce using rule 92 (saveCTE -> .)
    GT              reduce using rule 92 (saveCTE -> .)
    LT              reduce using rule 92 (saveCTE -> .)
    GTE             reduce using rule 92 (saveCTE -> .)
    LTE             reduce using rule 92 (saveCTE -> .)
    NE              reduce using rule 92 (saveCTE -> .)
    AND             reduce using rule 92 (saveCTE -> .)
    OR              reduce using rule 92 (saveCTE -> .)
    RBRACKET        reduce using rule 92 (saveCTE -> .)
    RPAREN          reduce using rule 92 (saveCTE -> .)
    COMMA           reduce using rule 92 (saveCTE -> .)
    SEMMICOLON      reduce using rule 92 (saveCTE -> .)
    TO              reduce using rule 92 (saveCTE -> .)
    ID              reduce using rule 92 (saveCTE -> .)
    CTEI            reduce using rule 92 (saveCTE -> .)
    CTEF            reduce using rule 92 (saveCTE -> .)
    CTEC            reduce using rule 92 (saveCTE -> .)
    CTESTRING       reduce using rule 92 (saveCTE -> .)
    LPAREN          reduce using rule 92 (saveCTE -> .)

    saveCTE                        shift and go to state 125

state 76

    (87) pexp -> CTESTRING . saveCTE
    (92) saveCTE -> .

    MUL             reduce using rule 92 (saveCTE -> .)
    DIV             reduce using rule 92 (saveCTE -> .)
    PLUS            reduce using rule 92 (saveCTE -> .)
    MINUS           reduce using rule 92 (saveCTE -> .)
    GT              reduce using rule 92 (saveCTE -> .)
    LT              reduce using rule 92 (saveCTE -> .)
    GTE             reduce using rule 92 (saveCTE -> .)
    LTE             reduce using rule 92 (saveCTE -> .)
    NE              reduce using rule 92 (saveCTE -> .)
    AND             reduce using rule 92 (saveCTE -> .)
    OR              reduce using rule 92 (saveCTE -> .)
    RBRACKET        reduce using rule 92 (saveCTE -> .)
    RPAREN          reduce using rule 92 (saveCTE -> .)
    COMMA           reduce using rule 92 (saveCTE -> .)
    SEMMICOLON      reduce using rule 92 (saveCTE -> .)
    TO              reduce using rule 92 (saveCTE -> .)
    ID              reduce using rule 92 (saveCTE -> .)
    CTEI            reduce using rule 92 (saveCTE -> .)
    CTEF            reduce using rule 92 (saveCTE -> .)
    CTEC            reduce using rule 92 (saveCTE -> .)
    CTESTRING       reduce using rule 92 (saveCTE -> .)
    LPAREN          reduce using rule 92 (saveCTE -> .)

    saveCTE                        shift and go to state 126

state 77

    (88) pexp -> functionCall .

    MUL             reduce using rule 88 (pexp -> functionCall .)
    DIV             reduce using rule 88 (pexp -> functionCall .)
    PLUS            reduce using rule 88 (pexp -> functionCall .)
    MINUS           reduce using rule 88 (pexp -> functionCall .)
    GT              reduce using rule 88 (pexp -> functionCall .)
    LT              reduce using rule 88 (pexp -> functionCall .)
    GTE             reduce using rule 88 (pexp -> functionCall .)
    LTE             reduce using rule 88 (pexp -> functionCall .)
    NE              reduce using rule 88 (pexp -> functionCall .)
    AND             reduce using rule 88 (pexp -> functionCall .)
    OR              reduce using rule 88 (pexp -> functionCall .)
    RBRACKET        reduce using rule 88 (pexp -> functionCall .)
    RPAREN          reduce using rule 88 (pexp -> functionCall .)
    COMMA           reduce using rule 88 (pexp -> functionCall .)
    SEMMICOLON      reduce using rule 88 (pexp -> functionCall .)
    TO              reduce using rule 88 (pexp -> functionCall .)
    ID              reduce using rule 88 (pexp -> functionCall .)
    CTEI            reduce using rule 88 (pexp -> functionCall .)
    CTEF            reduce using rule 88 (pexp -> functionCall .)
    CTEC            reduce using rule 88 (pexp -> functionCall .)
    CTESTRING       reduce using rule 88 (pexp -> functionCall .)
    LPAREN          reduce using rule 88 (pexp -> functionCall .)


state 78

    (89) pexp -> LPAREN . exp RPAREN
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)

    exp                            shift and go to state 127
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 79

    (91) pexp -> empty .

    MUL             reduce using rule 91 (pexp -> empty .)
    DIV             reduce using rule 91 (pexp -> empty .)
    PLUS            reduce using rule 91 (pexp -> empty .)
    MINUS           reduce using rule 91 (pexp -> empty .)
    GT              reduce using rule 91 (pexp -> empty .)
    LT              reduce using rule 91 (pexp -> empty .)
    GTE             reduce using rule 91 (pexp -> empty .)
    LTE             reduce using rule 91 (pexp -> empty .)
    NE              reduce using rule 91 (pexp -> empty .)
    AND             reduce using rule 91 (pexp -> empty .)
    OR              reduce using rule 91 (pexp -> empty .)
    RBRACKET        reduce using rule 91 (pexp -> empty .)
    RPAREN          reduce using rule 91 (pexp -> empty .)
    COMMA           reduce using rule 91 (pexp -> empty .)
    SEMMICOLON      reduce using rule 91 (pexp -> empty .)
    TO              reduce using rule 91 (pexp -> empty .)
    ID              reduce using rule 91 (pexp -> empty .)
    CTEI            reduce using rule 91 (pexp -> empty .)
    CTEF            reduce using rule 91 (pexp -> empty .)
    CTEC            reduce using rule 91 (pexp -> empty .)
    CTESTRING       reduce using rule 91 (pexp -> empty .)
    LPAREN          reduce using rule 91 (pexp -> empty .)


state 80

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements . RCURLY

    RCURLY          shift and go to state 128


state 81

    (10) statements -> assign . SEMMICOLON statements

    SEMMICOLON      shift and go to state 129


state 82

    (11) statements -> functionCall . SEMMICOLON statements

    SEMMICOLON      shift and go to state 130


state 83

    (12) statements -> read . statements SEMMICOLON statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    SEMMICOLON      reduce using rule 135 (empty -> .)

    read                           shift and go to state 83
    statements                     shift and go to state 131
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 84

    (13) statements -> write . statements SEMMICOLON statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    SEMMICOLON      reduce using rule 135 (empty -> .)

    write                          shift and go to state 84
    statements                     shift and go to state 132
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 85

    (14) statements -> for . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)

    for                            shift and go to state 85
    statements                     shift and go to state 133
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 86

    (15) statements -> while . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)

    while                          shift and go to state 86
    statements                     shift and go to state 134
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    for                            shift and go to state 85
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 87

    (16) statements -> if . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)

    if                             shift and go to state 87
    statements                     shift and go to state 135
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 88

    (17) statements -> return . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)

    return                         shift and go to state 88
    statements                     shift and go to state 136
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    empty                          shift and go to state 89

state 89

    (18) statements -> empty .

    RCURLY          reduce using rule 18 (statements -> empty .)
    SEMMICOLON      reduce using rule 18 (statements -> empty .)


state 90

    (19) assign -> ID . add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> ID . add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> ID . functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (23) add_id2 -> .
    (33) functionERA -> .

    EQUALS          reduce using rule 23 (add_id2 -> .)
    LBRACKET        reduce using rule 23 (add_id2 -> .)
    LPAREN          reduce using rule 33 (functionERA -> .)

    add_id2                        shift and go to state 137
    functionERA                    shift and go to state 123

state 91

    (34) read -> READ . operatorRead LPAREN paramReadAux RPAREN
    (39) operatorRead -> .

    LPAREN          reduce using rule 39 (operatorRead -> .)

    operatorRead                   shift and go to state 138

state 92

    (41) write -> WRITE . writeOperator LPAREN paramWrite RPAREN
    (46) writeOperator -> .

    LPAREN          reduce using rule 46 (writeOperator -> .)

    writeOperator                  shift and go to state 139

state 93

    (49) for -> FOR . forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (50) forOP -> .

    ID              reduce using rule 50 (forOP -> .)

    forOP                          shift and go to state 140

state 94

    (52) while -> WHILE . whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (53) whileOP -> .

    LPAREN          reduce using rule 53 (whileOP -> .)

    whileOP                        shift and go to state 141

state 95

    (55) if -> IF . LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF

    LPAREN          shift and go to state 142


state 96

    (133) return -> RETURN . LPAREN exp RPAREN SEMMICOLON
    (134) return -> RETURN . LPAREN exp RPAREN

    LPAREN          shift and go to state 143


state 97

    (116) functions1 -> ID saveFunction LPAREN parameters . RPAREN vars LCURLY statements RCURLY

    RPAREN          shift and go to state 144


state 98

    (119) parameters -> paramsAux .

    RPAREN          reduce using rule 119 (parameters -> paramsAux .)


state 99

    (120) parameters -> empty .

    RPAREN          reduce using rule 120 (parameters -> empty .)


state 100

    (121) paramsAux -> INT . saveTypeVar TWOPOINTS ID addParameter nextParam
    (105) saveTypeVar -> .

    TWOPOINTS       reduce using rule 105 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 145

state 101

    (122) paramsAux -> FLOAT . saveTypeVar TWOPOINTS ID addParameter nextParam
    (105) saveTypeVar -> .

    TWOPOINTS       reduce using rule 105 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 146

state 102

    (123) paramsAux -> CHAR . saveTypeVar TWOPOINTS ID addParameter nextParam
    (105) saveTypeVar -> .

    TWOPOINTS       reduce using rule 105 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 147

state 103

    (100) var1 -> ID COMMA var1 addVar .

    SEMMICOLON      reduce using rule 100 (var1 -> ID COMMA var1 addVar .)


state 104

    (102) var1 -> ID arr COMMA var1 . addVar
    (104) addVar -> .

    SEMMICOLON      reduce using rule 104 (addVar -> .)

    addVar                         shift and go to state 148

state 105

    (109) arr -> LBRACKET CTEI RBRACKET .

    COMMA           reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    SEMMICOLON      reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    MUL             reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    DIV             reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    PLUS            reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    MINUS           reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    GT              reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    LT              reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    GTE             reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    LTE             reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    NE              reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    AND             reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    OR              reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    RBRACKET        reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    RPAREN          reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    TO              reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    ID              reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    CTEI            reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    CTEF            reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    CTEC            reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    CTESTRING       reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    LPAREN          reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)
    EQUALS          reduce using rule 109 (arr -> LBRACKET CTEI RBRACKET .)


state 106

    (84) pexp -> CTEI saveCTE .

    MUL             reduce using rule 84 (pexp -> CTEI saveCTE .)
    DIV             reduce using rule 84 (pexp -> CTEI saveCTE .)
    PLUS            reduce using rule 84 (pexp -> CTEI saveCTE .)
    MINUS           reduce using rule 84 (pexp -> CTEI saveCTE .)
    GT              reduce using rule 84 (pexp -> CTEI saveCTE .)
    LT              reduce using rule 84 (pexp -> CTEI saveCTE .)
    GTE             reduce using rule 84 (pexp -> CTEI saveCTE .)
    LTE             reduce using rule 84 (pexp -> CTEI saveCTE .)
    NE              reduce using rule 84 (pexp -> CTEI saveCTE .)
    AND             reduce using rule 84 (pexp -> CTEI saveCTE .)
    OR              reduce using rule 84 (pexp -> CTEI saveCTE .)
    RBRACKET        reduce using rule 84 (pexp -> CTEI saveCTE .)
    RPAREN          reduce using rule 84 (pexp -> CTEI saveCTE .)
    COMMA           reduce using rule 84 (pexp -> CTEI saveCTE .)
    SEMMICOLON      reduce using rule 84 (pexp -> CTEI saveCTE .)
    TO              reduce using rule 84 (pexp -> CTEI saveCTE .)
    ID              reduce using rule 84 (pexp -> CTEI saveCTE .)
    CTEI            reduce using rule 84 (pexp -> CTEI saveCTE .)
    CTEF            reduce using rule 84 (pexp -> CTEI saveCTE .)
    CTEC            reduce using rule 84 (pexp -> CTEI saveCTE .)
    CTESTRING       reduce using rule 84 (pexp -> CTEI saveCTE .)
    LPAREN          reduce using rule 84 (pexp -> CTEI saveCTE .)


state 107

    (110) arr -> LBRACKET exp RBRACKET .

    COMMA           reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    SEMMICOLON      reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    MUL             reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    DIV             reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    GT              reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    LT              reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    GTE             reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    LTE             reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    NE              reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    AND             reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    OR              reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    TO              reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    ID              reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    CTEI            reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    CTEF            reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    CTEC            reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    CTESTRING       reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 110 (arr -> LBRACKET exp RBRACKET .)


state 108

    (61) exp -> nexp generateQuadOR .
    (62) exp -> nexp generateQuadOR . OR saveOperator nexp

    RBRACKET        reduce using rule 61 (exp -> nexp generateQuadOR .)
    RPAREN          reduce using rule 61 (exp -> nexp generateQuadOR .)
    COMMA           reduce using rule 61 (exp -> nexp generateQuadOR .)
    SEMMICOLON      reduce using rule 61 (exp -> nexp generateQuadOR .)
    TO              reduce using rule 61 (exp -> nexp generateQuadOR .)
    OR              shift and go to state 149


state 109

    (64) nexp -> compexp generateQuadAND .
    (65) nexp -> compexp generateQuadAND . AND saveOperator compexp

    OR              reduce using rule 64 (nexp -> compexp generateQuadAND .)
    RBRACKET        reduce using rule 64 (nexp -> compexp generateQuadAND .)
    RPAREN          reduce using rule 64 (nexp -> compexp generateQuadAND .)
    COMMA           reduce using rule 64 (nexp -> compexp generateQuadAND .)
    SEMMICOLON      reduce using rule 64 (nexp -> compexp generateQuadAND .)
    TO              reduce using rule 64 (nexp -> compexp generateQuadAND .)
    AND             shift and go to state 150


state 110

    (69) compexp1 -> sumexp GT . saveOperator sumexp generateQuadCOMPARE
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    RBRACKET        reduce using rule 93 (saveOperator -> .)
    RPAREN          reduce using rule 93 (saveOperator -> .)
    COMMA           reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 151

state 111

    (70) compexp1 -> sumexp LT . saveOperator sumexp generateQuadCOMPARE
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    RBRACKET        reduce using rule 93 (saveOperator -> .)
    RPAREN          reduce using rule 93 (saveOperator -> .)
    COMMA           reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 152

state 112

    (71) compexp1 -> sumexp GTE . saveOperator sumexp generateQuadCOMPARE
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    RBRACKET        reduce using rule 93 (saveOperator -> .)
    RPAREN          reduce using rule 93 (saveOperator -> .)
    COMMA           reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 153

state 113

    (72) compexp1 -> sumexp LTE . saveOperator sumexp generateQuadCOMPARE
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    RBRACKET        reduce using rule 93 (saveOperator -> .)
    RPAREN          reduce using rule 93 (saveOperator -> .)
    COMMA           reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 154

state 114

    (73) compexp1 -> sumexp NE . saveOperator sumexp generateQuadCOMPARE
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    RBRACKET        reduce using rule 93 (saveOperator -> .)
    RPAREN          reduce using rule 93 (saveOperator -> .)
    COMMA           reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 155

state 115

    (68) compexp -> compexp1 sumexp .

    AND             reduce using rule 68 (compexp -> compexp1 sumexp .)
    OR              reduce using rule 68 (compexp -> compexp1 sumexp .)
    RBRACKET        reduce using rule 68 (compexp -> compexp1 sumexp .)
    RPAREN          reduce using rule 68 (compexp -> compexp1 sumexp .)
    COMMA           reduce using rule 68 (compexp -> compexp1 sumexp .)
    SEMMICOLON      reduce using rule 68 (compexp -> compexp1 sumexp .)
    TO              reduce using rule 68 (compexp -> compexp1 sumexp .)


state 116

    (84) pexp -> CTEI . saveCTE
    (92) saveCTE -> .

    MUL             reduce using rule 92 (saveCTE -> .)
    DIV             reduce using rule 92 (saveCTE -> .)
    PLUS            reduce using rule 92 (saveCTE -> .)
    MINUS           reduce using rule 92 (saveCTE -> .)
    AND             reduce using rule 92 (saveCTE -> .)
    OR              reduce using rule 92 (saveCTE -> .)
    RBRACKET        reduce using rule 92 (saveCTE -> .)
    RPAREN          reduce using rule 92 (saveCTE -> .)
    COMMA           reduce using rule 92 (saveCTE -> .)
    SEMMICOLON      reduce using rule 92 (saveCTE -> .)
    TO              reduce using rule 92 (saveCTE -> .)
    GT              reduce using rule 92 (saveCTE -> .)
    LT              reduce using rule 92 (saveCTE -> .)
    GTE             reduce using rule 92 (saveCTE -> .)
    LTE             reduce using rule 92 (saveCTE -> .)
    NE              reduce using rule 92 (saveCTE -> .)
    ID              reduce using rule 92 (saveCTE -> .)
    CTEI            reduce using rule 92 (saveCTE -> .)
    CTEF            reduce using rule 92 (saveCTE -> .)
    CTEC            reduce using rule 92 (saveCTE -> .)
    CTESTRING       reduce using rule 92 (saveCTE -> .)
    LPAREN          reduce using rule 92 (saveCTE -> .)

    saveCTE                        shift and go to state 106

state 117

    (76) sumexp -> mulexp PLUS . saveOperator mulexp generateQuadSUM
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)
    GT              reduce using rule 93 (saveOperator -> .)
    LT              reduce using rule 93 (saveOperator -> .)
    GTE             reduce using rule 93 (saveOperator -> .)
    LTE             reduce using rule 93 (saveOperator -> .)
    NE              reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    RBRACKET        reduce using rule 93 (saveOperator -> .)
    RPAREN          reduce using rule 93 (saveOperator -> .)
    COMMA           reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 156

state 118

    (77) sumexp -> mulexp MINUS . saveOperator mulexp generateQuadSUM
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)
    GT              reduce using rule 93 (saveOperator -> .)
    LT              reduce using rule 93 (saveOperator -> .)
    GTE             reduce using rule 93 (saveOperator -> .)
    LTE             reduce using rule 93 (saveOperator -> .)
    NE              reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    RBRACKET        reduce using rule 93 (saveOperator -> .)
    RPAREN          reduce using rule 93 (saveOperator -> .)
    COMMA           reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 157

state 119

    (80) mulexp -> pexp MUL . saveOperator pexp generateQuadMUL
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)
    GT              reduce using rule 93 (saveOperator -> .)
    LT              reduce using rule 93 (saveOperator -> .)
    GTE             reduce using rule 93 (saveOperator -> .)
    LTE             reduce using rule 93 (saveOperator -> .)
    NE              reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    RBRACKET        reduce using rule 93 (saveOperator -> .)
    RPAREN          reduce using rule 93 (saveOperator -> .)
    COMMA           reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 158

state 120

    (81) mulexp -> pexp DIV . saveOperator pexp generateQuadMUL
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)
    GT              reduce using rule 93 (saveOperator -> .)
    LT              reduce using rule 93 (saveOperator -> .)
    GTE             reduce using rule 93 (saveOperator -> .)
    LTE             reduce using rule 93 (saveOperator -> .)
    NE              reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    RBRACKET        reduce using rule 93 (saveOperator -> .)
    RPAREN          reduce using rule 93 (saveOperator -> .)
    COMMA           reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 159

state 121

    (83) pexp -> ID add_id2 .

    MUL             reduce using rule 83 (pexp -> ID add_id2 .)
    DIV             reduce using rule 83 (pexp -> ID add_id2 .)
    PLUS            reduce using rule 83 (pexp -> ID add_id2 .)
    MINUS           reduce using rule 83 (pexp -> ID add_id2 .)
    GT              reduce using rule 83 (pexp -> ID add_id2 .)
    LT              reduce using rule 83 (pexp -> ID add_id2 .)
    GTE             reduce using rule 83 (pexp -> ID add_id2 .)
    LTE             reduce using rule 83 (pexp -> ID add_id2 .)
    NE              reduce using rule 83 (pexp -> ID add_id2 .)
    AND             reduce using rule 83 (pexp -> ID add_id2 .)
    OR              reduce using rule 83 (pexp -> ID add_id2 .)
    RBRACKET        reduce using rule 83 (pexp -> ID add_id2 .)
    RPAREN          reduce using rule 83 (pexp -> ID add_id2 .)
    COMMA           reduce using rule 83 (pexp -> ID add_id2 .)
    SEMMICOLON      reduce using rule 83 (pexp -> ID add_id2 .)
    TO              reduce using rule 83 (pexp -> ID add_id2 .)
    ID              reduce using rule 83 (pexp -> ID add_id2 .)
    CTEI            reduce using rule 83 (pexp -> ID add_id2 .)
    CTEF            reduce using rule 83 (pexp -> ID add_id2 .)
    CTEC            reduce using rule 83 (pexp -> ID add_id2 .)
    CTESTRING       reduce using rule 83 (pexp -> ID add_id2 .)
    LPAREN          reduce using rule 83 (pexp -> ID add_id2 .)


state 122

    (90) pexp -> ID arr . add_id3
    (24) add_id3 -> .

    MUL             reduce using rule 24 (add_id3 -> .)
    DIV             reduce using rule 24 (add_id3 -> .)
    PLUS            reduce using rule 24 (add_id3 -> .)
    MINUS           reduce using rule 24 (add_id3 -> .)
    GT              reduce using rule 24 (add_id3 -> .)
    LT              reduce using rule 24 (add_id3 -> .)
    GTE             reduce using rule 24 (add_id3 -> .)
    LTE             reduce using rule 24 (add_id3 -> .)
    NE              reduce using rule 24 (add_id3 -> .)
    AND             reduce using rule 24 (add_id3 -> .)
    OR              reduce using rule 24 (add_id3 -> .)
    RBRACKET        reduce using rule 24 (add_id3 -> .)
    RPAREN          reduce using rule 24 (add_id3 -> .)
    COMMA           reduce using rule 24 (add_id3 -> .)
    SEMMICOLON      reduce using rule 24 (add_id3 -> .)
    TO              reduce using rule 24 (add_id3 -> .)
    ID              reduce using rule 24 (add_id3 -> .)
    CTEI            reduce using rule 24 (add_id3 -> .)
    CTEF            reduce using rule 24 (add_id3 -> .)
    CTEC            reduce using rule 24 (add_id3 -> .)
    CTESTRING       reduce using rule 24 (add_id3 -> .)
    LPAREN          reduce using rule 24 (add_id3 -> .)

    add_id3                        shift and go to state 160

state 123

    (26) functionCall -> ID functionERA . LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB

    LPAREN          shift and go to state 161


state 124

    (85) pexp -> CTEF saveCTE .

    MUL             reduce using rule 85 (pexp -> CTEF saveCTE .)
    DIV             reduce using rule 85 (pexp -> CTEF saveCTE .)
    PLUS            reduce using rule 85 (pexp -> CTEF saveCTE .)
    MINUS           reduce using rule 85 (pexp -> CTEF saveCTE .)
    GT              reduce using rule 85 (pexp -> CTEF saveCTE .)
    LT              reduce using rule 85 (pexp -> CTEF saveCTE .)
    GTE             reduce using rule 85 (pexp -> CTEF saveCTE .)
    LTE             reduce using rule 85 (pexp -> CTEF saveCTE .)
    NE              reduce using rule 85 (pexp -> CTEF saveCTE .)
    AND             reduce using rule 85 (pexp -> CTEF saveCTE .)
    OR              reduce using rule 85 (pexp -> CTEF saveCTE .)
    RBRACKET        reduce using rule 85 (pexp -> CTEF saveCTE .)
    RPAREN          reduce using rule 85 (pexp -> CTEF saveCTE .)
    COMMA           reduce using rule 85 (pexp -> CTEF saveCTE .)
    SEMMICOLON      reduce using rule 85 (pexp -> CTEF saveCTE .)
    TO              reduce using rule 85 (pexp -> CTEF saveCTE .)
    ID              reduce using rule 85 (pexp -> CTEF saveCTE .)
    CTEI            reduce using rule 85 (pexp -> CTEF saveCTE .)
    CTEF            reduce using rule 85 (pexp -> CTEF saveCTE .)
    CTEC            reduce using rule 85 (pexp -> CTEF saveCTE .)
    CTESTRING       reduce using rule 85 (pexp -> CTEF saveCTE .)
    LPAREN          reduce using rule 85 (pexp -> CTEF saveCTE .)


state 125

    (86) pexp -> CTEC saveCTE .

    MUL             reduce using rule 86 (pexp -> CTEC saveCTE .)
    DIV             reduce using rule 86 (pexp -> CTEC saveCTE .)
    PLUS            reduce using rule 86 (pexp -> CTEC saveCTE .)
    MINUS           reduce using rule 86 (pexp -> CTEC saveCTE .)
    GT              reduce using rule 86 (pexp -> CTEC saveCTE .)
    LT              reduce using rule 86 (pexp -> CTEC saveCTE .)
    GTE             reduce using rule 86 (pexp -> CTEC saveCTE .)
    LTE             reduce using rule 86 (pexp -> CTEC saveCTE .)
    NE              reduce using rule 86 (pexp -> CTEC saveCTE .)
    AND             reduce using rule 86 (pexp -> CTEC saveCTE .)
    OR              reduce using rule 86 (pexp -> CTEC saveCTE .)
    RBRACKET        reduce using rule 86 (pexp -> CTEC saveCTE .)
    RPAREN          reduce using rule 86 (pexp -> CTEC saveCTE .)
    COMMA           reduce using rule 86 (pexp -> CTEC saveCTE .)
    SEMMICOLON      reduce using rule 86 (pexp -> CTEC saveCTE .)
    TO              reduce using rule 86 (pexp -> CTEC saveCTE .)
    ID              reduce using rule 86 (pexp -> CTEC saveCTE .)
    CTEI            reduce using rule 86 (pexp -> CTEC saveCTE .)
    CTEF            reduce using rule 86 (pexp -> CTEC saveCTE .)
    CTEC            reduce using rule 86 (pexp -> CTEC saveCTE .)
    CTESTRING       reduce using rule 86 (pexp -> CTEC saveCTE .)
    LPAREN          reduce using rule 86 (pexp -> CTEC saveCTE .)


state 126

    (87) pexp -> CTESTRING saveCTE .

    MUL             reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    DIV             reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    PLUS            reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    MINUS           reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    GT              reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    LT              reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    GTE             reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    LTE             reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    NE              reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    AND             reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    OR              reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    RBRACKET        reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    RPAREN          reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    COMMA           reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    SEMMICOLON      reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    TO              reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    ID              reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    CTEI            reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    CTEF            reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    CTEC            reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    CTESTRING       reduce using rule 87 (pexp -> CTESTRING saveCTE .)
    LPAREN          reduce using rule 87 (pexp -> CTESTRING saveCTE .)


state 127

    (89) pexp -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 162


state 128

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY .

    $end            reduce using rule 7 (principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY .)


state 129

    (10) statements -> assign SEMMICOLON . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)

    assign                         shift and go to state 81
    statements                     shift and go to state 163
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 130

    (11) statements -> functionCall SEMMICOLON . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)

    functionCall                   shift and go to state 82
    statements                     shift and go to state 164
    assign                         shift and go to state 81
    read                           shift and go to state 83
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 131

    (12) statements -> read statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 165


state 132

    (13) statements -> write statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 166


state 133

    (14) statements -> for statements .

    RCURLY          reduce using rule 14 (statements -> for statements .)
    SEMMICOLON      reduce using rule 14 (statements -> for statements .)


state 134

    (15) statements -> while statements .

    RCURLY          reduce using rule 15 (statements -> while statements .)
    SEMMICOLON      reduce using rule 15 (statements -> while statements .)


state 135

    (16) statements -> if statements .

    RCURLY          reduce using rule 16 (statements -> if statements .)
    SEMMICOLON      reduce using rule 16 (statements -> if statements .)


state 136

    (17) statements -> return statements .

    RCURLY          reduce using rule 17 (statements -> return statements .)
    SEMMICOLON      reduce using rule 17 (statements -> return statements .)


state 137

    (19) assign -> ID add_id2 . EQUALS saveOperator exp generateAssignQuad
    (20) assign -> ID add_id2 . arr EQUALS saveOperator exp generateAssignQuad
    (109) arr -> . LBRACKET CTEI RBRACKET
    (110) arr -> . LBRACKET exp RBRACKET

    EQUALS          shift and go to state 167
    LBRACKET        shift and go to state 55

    arr                            shift and go to state 168

state 138

    (34) read -> READ operatorRead . LPAREN paramReadAux RPAREN

    LPAREN          shift and go to state 169


state 139

    (41) write -> WRITE writeOperator . LPAREN paramWrite RPAREN

    LPAREN          shift and go to state 170


state 140

    (49) for -> FOR forOP . assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad

    ID              shift and go to state 172

    assign                         shift and go to state 171

state 141

    (52) while -> WHILE whileOP . LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    LPAREN          shift and go to state 173


state 142

    (55) if -> IF LPAREN . exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)

    exp                            shift and go to state 174
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 143

    (133) return -> RETURN LPAREN . exp RPAREN SEMMICOLON
    (134) return -> RETURN LPAREN . exp RPAREN
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)

    exp                            shift and go to state 175
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 144

    (116) functions1 -> ID saveFunction LPAREN parameters RPAREN . vars LCURLY statements RCURLY
    (94) vars -> . var
    (95) vars -> . empty
    (96) var -> . VARS var2
    (135) empty -> .

    VARS            shift and go to state 12
    LCURLY          reduce using rule 135 (empty -> .)

    vars                           shift and go to state 176
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 145

    (121) paramsAux -> INT saveTypeVar . TWOPOINTS ID addParameter nextParam

    TWOPOINTS       shift and go to state 177


state 146

    (122) paramsAux -> FLOAT saveTypeVar . TWOPOINTS ID addParameter nextParam

    TWOPOINTS       shift and go to state 178


state 147

    (123) paramsAux -> CHAR saveTypeVar . TWOPOINTS ID addParameter nextParam

    TWOPOINTS       shift and go to state 179


state 148

    (102) var1 -> ID arr COMMA var1 addVar .

    SEMMICOLON      reduce using rule 102 (var1 -> ID arr COMMA var1 addVar .)


state 149

    (62) exp -> nexp generateQuadOR OR . saveOperator nexp
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    GT              reduce using rule 93 (saveOperator -> .)
    LT              reduce using rule 93 (saveOperator -> .)
    GTE             reduce using rule 93 (saveOperator -> .)
    LTE             reduce using rule 93 (saveOperator -> .)
    NE              reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)
    RBRACKET        reduce using rule 93 (saveOperator -> .)
    RPAREN          reduce using rule 93 (saveOperator -> .)
    COMMA           reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 180

state 150

    (65) nexp -> compexp generateQuadAND AND . saveOperator compexp
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    GT              reduce using rule 93 (saveOperator -> .)
    LT              reduce using rule 93 (saveOperator -> .)
    GTE             reduce using rule 93 (saveOperator -> .)
    LTE             reduce using rule 93 (saveOperator -> .)
    NE              reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    RBRACKET        reduce using rule 93 (saveOperator -> .)
    RPAREN          reduce using rule 93 (saveOperator -> .)
    COMMA           reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 181

state 151

    (69) compexp1 -> sumexp GT saveOperator . sumexp generateQuadCOMPARE
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)

  ! ID              [ reduce using rule 135 (empty -> .) ]
  ! CTEI            [ reduce using rule 135 (empty -> .) ]
  ! CTEF            [ reduce using rule 135 (empty -> .) ]
  ! CTEC            [ reduce using rule 135 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 135 (empty -> .) ]
  ! LPAREN          [ reduce using rule 135 (empty -> .) ]

    sumexp                         shift and go to state 182
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 152

    (70) compexp1 -> sumexp LT saveOperator . sumexp generateQuadCOMPARE
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)

  ! ID              [ reduce using rule 135 (empty -> .) ]
  ! CTEI            [ reduce using rule 135 (empty -> .) ]
  ! CTEF            [ reduce using rule 135 (empty -> .) ]
  ! CTEC            [ reduce using rule 135 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 135 (empty -> .) ]
  ! LPAREN          [ reduce using rule 135 (empty -> .) ]

    sumexp                         shift and go to state 183
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 153

    (71) compexp1 -> sumexp GTE saveOperator . sumexp generateQuadCOMPARE
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)

  ! ID              [ reduce using rule 135 (empty -> .) ]
  ! CTEI            [ reduce using rule 135 (empty -> .) ]
  ! CTEF            [ reduce using rule 135 (empty -> .) ]
  ! CTEC            [ reduce using rule 135 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 135 (empty -> .) ]
  ! LPAREN          [ reduce using rule 135 (empty -> .) ]

    sumexp                         shift and go to state 184
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 154

    (72) compexp1 -> sumexp LTE saveOperator . sumexp generateQuadCOMPARE
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)

  ! ID              [ reduce using rule 135 (empty -> .) ]
  ! CTEI            [ reduce using rule 135 (empty -> .) ]
  ! CTEF            [ reduce using rule 135 (empty -> .) ]
  ! CTEC            [ reduce using rule 135 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 135 (empty -> .) ]
  ! LPAREN          [ reduce using rule 135 (empty -> .) ]

    sumexp                         shift and go to state 185
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 155

    (73) compexp1 -> sumexp NE saveOperator . sumexp generateQuadCOMPARE
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)

  ! ID              [ reduce using rule 135 (empty -> .) ]
  ! CTEI            [ reduce using rule 135 (empty -> .) ]
  ! CTEF            [ reduce using rule 135 (empty -> .) ]
  ! CTEC            [ reduce using rule 135 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 135 (empty -> .) ]
  ! LPAREN          [ reduce using rule 135 (empty -> .) ]

    sumexp                         shift and go to state 186
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 156

    (76) sumexp -> mulexp PLUS saveOperator . mulexp generateQuadSUM
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)

  ! ID              [ reduce using rule 135 (empty -> .) ]
  ! CTEI            [ reduce using rule 135 (empty -> .) ]
  ! CTEF            [ reduce using rule 135 (empty -> .) ]
  ! CTEC            [ reduce using rule 135 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 135 (empty -> .) ]
  ! LPAREN          [ reduce using rule 135 (empty -> .) ]

    mulexp                         shift and go to state 187
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 157

    (77) sumexp -> mulexp MINUS saveOperator . mulexp generateQuadSUM
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)

  ! ID              [ reduce using rule 135 (empty -> .) ]
  ! CTEI            [ reduce using rule 135 (empty -> .) ]
  ! CTEF            [ reduce using rule 135 (empty -> .) ]
  ! CTEC            [ reduce using rule 135 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 135 (empty -> .) ]
  ! LPAREN          [ reduce using rule 135 (empty -> .) ]

    mulexp                         shift and go to state 188
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 158

    (80) mulexp -> pexp MUL saveOperator . pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)

  ! ID              [ reduce using rule 135 (empty -> .) ]
  ! CTEI            [ reduce using rule 135 (empty -> .) ]
  ! CTEF            [ reduce using rule 135 (empty -> .) ]
  ! CTEC            [ reduce using rule 135 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 135 (empty -> .) ]
  ! LPAREN          [ reduce using rule 135 (empty -> .) ]

    pexp                           shift and go to state 189
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 159

    (81) mulexp -> pexp DIV saveOperator . pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)

  ! ID              [ reduce using rule 135 (empty -> .) ]
  ! CTEI            [ reduce using rule 135 (empty -> .) ]
  ! CTEF            [ reduce using rule 135 (empty -> .) ]
  ! CTEC            [ reduce using rule 135 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 135 (empty -> .) ]
  ! LPAREN          [ reduce using rule 135 (empty -> .) ]

    pexp                           shift and go to state 190
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 160

    (90) pexp -> ID arr add_id3 .

    MUL             reduce using rule 90 (pexp -> ID arr add_id3 .)
    DIV             reduce using rule 90 (pexp -> ID arr add_id3 .)
    PLUS            reduce using rule 90 (pexp -> ID arr add_id3 .)
    MINUS           reduce using rule 90 (pexp -> ID arr add_id3 .)
    GT              reduce using rule 90 (pexp -> ID arr add_id3 .)
    LT              reduce using rule 90 (pexp -> ID arr add_id3 .)
    GTE             reduce using rule 90 (pexp -> ID arr add_id3 .)
    LTE             reduce using rule 90 (pexp -> ID arr add_id3 .)
    NE              reduce using rule 90 (pexp -> ID arr add_id3 .)
    AND             reduce using rule 90 (pexp -> ID arr add_id3 .)
    OR              reduce using rule 90 (pexp -> ID arr add_id3 .)
    RBRACKET        reduce using rule 90 (pexp -> ID arr add_id3 .)
    RPAREN          reduce using rule 90 (pexp -> ID arr add_id3 .)
    COMMA           reduce using rule 90 (pexp -> ID arr add_id3 .)
    SEMMICOLON      reduce using rule 90 (pexp -> ID arr add_id3 .)
    TO              reduce using rule 90 (pexp -> ID arr add_id3 .)
    ID              reduce using rule 90 (pexp -> ID arr add_id3 .)
    CTEI            reduce using rule 90 (pexp -> ID arr add_id3 .)
    CTEF            reduce using rule 90 (pexp -> ID arr add_id3 .)
    CTEC            reduce using rule 90 (pexp -> ID arr add_id3 .)
    CTESTRING       reduce using rule 90 (pexp -> ID arr add_id3 .)
    LPAREN          reduce using rule 90 (pexp -> ID arr add_id3 .)


state 161

    (26) functionCall -> ID functionERA LPAREN . expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (28) expAux -> . exp
    (29) expAux -> . exp COMMA expAux
    (30) expAux -> . empty
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (135) empty -> .
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB

    RPAREN          reduce using rule 135 (empty -> .)
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78

    expAux                         shift and go to state 191
    exp                            shift and go to state 192
    empty                          shift and go to state 193
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77

state 162

    (89) pexp -> LPAREN exp RPAREN .

    MUL             reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    DIV             reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    AND             reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    OR              reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    SEMMICOLON      reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    TO              reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    CTEI            reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    CTEF            reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    CTEC            reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    CTESTRING       reduce using rule 89 (pexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 89 (pexp -> LPAREN exp RPAREN .)


state 163

    (10) statements -> assign SEMMICOLON statements .

    RCURLY          reduce using rule 10 (statements -> assign SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 10 (statements -> assign SEMMICOLON statements .)


state 164

    (11) statements -> functionCall SEMMICOLON statements .

    RCURLY          reduce using rule 11 (statements -> functionCall SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 11 (statements -> functionCall SEMMICOLON statements .)


state 165

    (12) statements -> read statements SEMMICOLON . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)

    read                           shift and go to state 83
    statements                     shift and go to state 194
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 166

    (13) statements -> write statements SEMMICOLON . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)

    write                          shift and go to state 84
    statements                     shift and go to state 195
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 167

    (19) assign -> ID add_id2 EQUALS . saveOperator exp generateAssignQuad
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    GT              reduce using rule 93 (saveOperator -> .)
    LT              reduce using rule 93 (saveOperator -> .)
    GTE             reduce using rule 93 (saveOperator -> .)
    LTE             reduce using rule 93 (saveOperator -> .)
    NE              reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 196

state 168

    (20) assign -> ID add_id2 arr . EQUALS saveOperator exp generateAssignQuad

    EQUALS          shift and go to state 197


state 169

    (34) read -> READ operatorRead LPAREN . paramReadAux RPAREN
    (37) paramReadAux -> . exp generateQuadREAD
    (38) paramReadAux -> . exp generateQuadREAD COMMA operatorRead paramReadAux
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)

    paramReadAux                   shift and go to state 198
    exp                            shift and go to state 199
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 170

    (41) write -> WRITE writeOperator LPAREN . paramWrite RPAREN
    (42) paramWrite -> . paramWriteAux
    (43) paramWrite -> . empty
    (44) paramWriteAux -> . exp generateQuadPRINT
    (45) paramWriteAux -> . exp generateQuadPRINT COMMA writeOperator paramWriteAux
    (135) empty -> .
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB

    RPAREN          reduce using rule 135 (empty -> .)
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78

    paramWrite                     shift and go to state 200
    paramWriteAux                  shift and go to state 201
    empty                          shift and go to state 202
    exp                            shift and go to state 203
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77

state 171

    (49) for -> FOR forOP assign . TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    TO              shift and go to state 204


state 172

    (19) assign -> ID . add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> ID . add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (23) add_id2 -> .

    EQUALS          reduce using rule 23 (add_id2 -> .)
    LBRACKET        reduce using rule 23 (add_id2 -> .)

    add_id2                        shift and go to state 137

state 173

    (52) while -> WHILE whileOP LPAREN . exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)

    exp                            shift and go to state 205
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 174

    (55) if -> IF LPAREN exp . RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF

    RPAREN          shift and go to state 206


state 175

    (133) return -> RETURN LPAREN exp . RPAREN SEMMICOLON
    (134) return -> RETURN LPAREN exp . RPAREN

    RPAREN          shift and go to state 207


state 176

    (116) functions1 -> ID saveFunction LPAREN parameters RPAREN vars . LCURLY statements RCURLY

    LCURLY          shift and go to state 208


state 177

    (121) paramsAux -> INT saveTypeVar TWOPOINTS . ID addParameter nextParam

    ID              shift and go to state 209


state 178

    (122) paramsAux -> FLOAT saveTypeVar TWOPOINTS . ID addParameter nextParam

    ID              shift and go to state 210


state 179

    (123) paramsAux -> CHAR saveTypeVar TWOPOINTS . ID addParameter nextParam

    ID              shift and go to state 211


state 180

    (62) exp -> nexp generateQuadOR OR saveOperator . nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)

    nexp                           shift and go to state 212
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 181

    (65) nexp -> compexp generateQuadAND AND saveOperator . compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    RBRACKET        reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)

    compexp                        shift and go to state 213
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 182

    (69) compexp1 -> sumexp GT saveOperator sumexp . generateQuadCOMPARE
    (74) generateQuadCOMPARE -> .

    ID              reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEI            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 74 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 74 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 74 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 74 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 74 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 74 (generateQuadCOMPARE -> .)
    AND             reduce using rule 74 (generateQuadCOMPARE -> .)
    OR              reduce using rule 74 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 74 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 74 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 74 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 74 (generateQuadCOMPARE -> .)
    TO              reduce using rule 74 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 214

state 183

    (70) compexp1 -> sumexp LT saveOperator sumexp . generateQuadCOMPARE
    (74) generateQuadCOMPARE -> .

    ID              reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEI            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 74 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 74 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 74 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 74 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 74 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 74 (generateQuadCOMPARE -> .)
    AND             reduce using rule 74 (generateQuadCOMPARE -> .)
    OR              reduce using rule 74 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 74 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 74 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 74 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 74 (generateQuadCOMPARE -> .)
    TO              reduce using rule 74 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 215

state 184

    (71) compexp1 -> sumexp GTE saveOperator sumexp . generateQuadCOMPARE
    (74) generateQuadCOMPARE -> .

    ID              reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEI            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 74 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 74 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 74 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 74 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 74 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 74 (generateQuadCOMPARE -> .)
    AND             reduce using rule 74 (generateQuadCOMPARE -> .)
    OR              reduce using rule 74 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 74 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 74 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 74 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 74 (generateQuadCOMPARE -> .)
    TO              reduce using rule 74 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 216

state 185

    (72) compexp1 -> sumexp LTE saveOperator sumexp . generateQuadCOMPARE
    (74) generateQuadCOMPARE -> .

    ID              reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEI            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 74 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 74 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 74 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 74 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 74 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 74 (generateQuadCOMPARE -> .)
    AND             reduce using rule 74 (generateQuadCOMPARE -> .)
    OR              reduce using rule 74 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 74 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 74 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 74 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 74 (generateQuadCOMPARE -> .)
    TO              reduce using rule 74 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 217

state 186

    (73) compexp1 -> sumexp NE saveOperator sumexp . generateQuadCOMPARE
    (74) generateQuadCOMPARE -> .

    ID              reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEI            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 74 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 74 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 74 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 74 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 74 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 74 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 74 (generateQuadCOMPARE -> .)
    AND             reduce using rule 74 (generateQuadCOMPARE -> .)
    OR              reduce using rule 74 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 74 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 74 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 74 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 74 (generateQuadCOMPARE -> .)
    TO              reduce using rule 74 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 218

state 187

    (76) sumexp -> mulexp PLUS saveOperator mulexp . generateQuadSUM
    (78) generateQuadSUM -> .

    GT              reduce using rule 78 (generateQuadSUM -> .)
    LT              reduce using rule 78 (generateQuadSUM -> .)
    GTE             reduce using rule 78 (generateQuadSUM -> .)
    LTE             reduce using rule 78 (generateQuadSUM -> .)
    NE              reduce using rule 78 (generateQuadSUM -> .)
    AND             reduce using rule 78 (generateQuadSUM -> .)
    OR              reduce using rule 78 (generateQuadSUM -> .)
    RBRACKET        reduce using rule 78 (generateQuadSUM -> .)
    RPAREN          reduce using rule 78 (generateQuadSUM -> .)
    COMMA           reduce using rule 78 (generateQuadSUM -> .)
    SEMMICOLON      reduce using rule 78 (generateQuadSUM -> .)
    TO              reduce using rule 78 (generateQuadSUM -> .)
    ID              reduce using rule 78 (generateQuadSUM -> .)
    CTEI            reduce using rule 78 (generateQuadSUM -> .)
    CTEF            reduce using rule 78 (generateQuadSUM -> .)
    CTEC            reduce using rule 78 (generateQuadSUM -> .)
    CTESTRING       reduce using rule 78 (generateQuadSUM -> .)
    LPAREN          reduce using rule 78 (generateQuadSUM -> .)
    PLUS            reduce using rule 78 (generateQuadSUM -> .)
    MINUS           reduce using rule 78 (generateQuadSUM -> .)
    MUL             reduce using rule 78 (generateQuadSUM -> .)
    DIV             reduce using rule 78 (generateQuadSUM -> .)

    generateQuadSUM                shift and go to state 219

state 188

    (77) sumexp -> mulexp MINUS saveOperator mulexp . generateQuadSUM
    (78) generateQuadSUM -> .

    GT              reduce using rule 78 (generateQuadSUM -> .)
    LT              reduce using rule 78 (generateQuadSUM -> .)
    GTE             reduce using rule 78 (generateQuadSUM -> .)
    LTE             reduce using rule 78 (generateQuadSUM -> .)
    NE              reduce using rule 78 (generateQuadSUM -> .)
    AND             reduce using rule 78 (generateQuadSUM -> .)
    OR              reduce using rule 78 (generateQuadSUM -> .)
    RBRACKET        reduce using rule 78 (generateQuadSUM -> .)
    RPAREN          reduce using rule 78 (generateQuadSUM -> .)
    COMMA           reduce using rule 78 (generateQuadSUM -> .)
    SEMMICOLON      reduce using rule 78 (generateQuadSUM -> .)
    TO              reduce using rule 78 (generateQuadSUM -> .)
    ID              reduce using rule 78 (generateQuadSUM -> .)
    CTEI            reduce using rule 78 (generateQuadSUM -> .)
    CTEF            reduce using rule 78 (generateQuadSUM -> .)
    CTEC            reduce using rule 78 (generateQuadSUM -> .)
    CTESTRING       reduce using rule 78 (generateQuadSUM -> .)
    LPAREN          reduce using rule 78 (generateQuadSUM -> .)
    PLUS            reduce using rule 78 (generateQuadSUM -> .)
    MINUS           reduce using rule 78 (generateQuadSUM -> .)
    MUL             reduce using rule 78 (generateQuadSUM -> .)
    DIV             reduce using rule 78 (generateQuadSUM -> .)

    generateQuadSUM                shift and go to state 220

state 189

    (80) mulexp -> pexp MUL saveOperator pexp . generateQuadMUL
    (82) generateQuadMUL -> .

    PLUS            reduce using rule 82 (generateQuadMUL -> .)
    MINUS           reduce using rule 82 (generateQuadMUL -> .)
    GT              reduce using rule 82 (generateQuadMUL -> .)
    LT              reduce using rule 82 (generateQuadMUL -> .)
    GTE             reduce using rule 82 (generateQuadMUL -> .)
    LTE             reduce using rule 82 (generateQuadMUL -> .)
    NE              reduce using rule 82 (generateQuadMUL -> .)
    AND             reduce using rule 82 (generateQuadMUL -> .)
    OR              reduce using rule 82 (generateQuadMUL -> .)
    RBRACKET        reduce using rule 82 (generateQuadMUL -> .)
    RPAREN          reduce using rule 82 (generateQuadMUL -> .)
    COMMA           reduce using rule 82 (generateQuadMUL -> .)
    SEMMICOLON      reduce using rule 82 (generateQuadMUL -> .)
    TO              reduce using rule 82 (generateQuadMUL -> .)
    ID              reduce using rule 82 (generateQuadMUL -> .)
    CTEI            reduce using rule 82 (generateQuadMUL -> .)
    CTEF            reduce using rule 82 (generateQuadMUL -> .)
    CTEC            reduce using rule 82 (generateQuadMUL -> .)
    CTESTRING       reduce using rule 82 (generateQuadMUL -> .)
    LPAREN          reduce using rule 82 (generateQuadMUL -> .)
    MUL             reduce using rule 82 (generateQuadMUL -> .)
    DIV             reduce using rule 82 (generateQuadMUL -> .)

    generateQuadMUL                shift and go to state 221

state 190

    (81) mulexp -> pexp DIV saveOperator pexp . generateQuadMUL
    (82) generateQuadMUL -> .

    PLUS            reduce using rule 82 (generateQuadMUL -> .)
    MINUS           reduce using rule 82 (generateQuadMUL -> .)
    GT              reduce using rule 82 (generateQuadMUL -> .)
    LT              reduce using rule 82 (generateQuadMUL -> .)
    GTE             reduce using rule 82 (generateQuadMUL -> .)
    LTE             reduce using rule 82 (generateQuadMUL -> .)
    NE              reduce using rule 82 (generateQuadMUL -> .)
    AND             reduce using rule 82 (generateQuadMUL -> .)
    OR              reduce using rule 82 (generateQuadMUL -> .)
    RBRACKET        reduce using rule 82 (generateQuadMUL -> .)
    RPAREN          reduce using rule 82 (generateQuadMUL -> .)
    COMMA           reduce using rule 82 (generateQuadMUL -> .)
    SEMMICOLON      reduce using rule 82 (generateQuadMUL -> .)
    TO              reduce using rule 82 (generateQuadMUL -> .)
    ID              reduce using rule 82 (generateQuadMUL -> .)
    CTEI            reduce using rule 82 (generateQuadMUL -> .)
    CTEF            reduce using rule 82 (generateQuadMUL -> .)
    CTEC            reduce using rule 82 (generateQuadMUL -> .)
    CTESTRING       reduce using rule 82 (generateQuadMUL -> .)
    LPAREN          reduce using rule 82 (generateQuadMUL -> .)
    MUL             reduce using rule 82 (generateQuadMUL -> .)
    DIV             reduce using rule 82 (generateQuadMUL -> .)

    generateQuadMUL                shift and go to state 222

state 191

    (26) functionCall -> ID functionERA LPAREN expAux . generateQuadPARAM RPAREN generateQuadGOSUB
    (27) generateQuadPARAM -> .

    RPAREN          reduce using rule 27 (generateQuadPARAM -> .)

    generateQuadPARAM              shift and go to state 223

state 192

    (28) expAux -> exp .
    (29) expAux -> exp . COMMA expAux

    RPAREN          reduce using rule 28 (expAux -> exp .)
    COMMA           shift and go to state 224


state 193

    (30) expAux -> empty .
    (91) pexp -> empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 30 (expAux -> empty .)
    RPAREN          reduce using rule 30 (expAux -> empty .)
    MUL             reduce using rule 91 (pexp -> empty .)
    DIV             reduce using rule 91 (pexp -> empty .)
    PLUS            reduce using rule 91 (pexp -> empty .)
    MINUS           reduce using rule 91 (pexp -> empty .)
    GT              reduce using rule 91 (pexp -> empty .)
    LT              reduce using rule 91 (pexp -> empty .)
    GTE             reduce using rule 91 (pexp -> empty .)
    LTE             reduce using rule 91 (pexp -> empty .)
    NE              reduce using rule 91 (pexp -> empty .)
    AND             reduce using rule 91 (pexp -> empty .)
    OR              reduce using rule 91 (pexp -> empty .)
    COMMA           reduce using rule 91 (pexp -> empty .)

  ! RPAREN          [ reduce using rule 91 (pexp -> empty .) ]


state 194

    (12) statements -> read statements SEMMICOLON statements .

    RCURLY          reduce using rule 12 (statements -> read statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 12 (statements -> read statements SEMMICOLON statements .)


state 195

    (13) statements -> write statements SEMMICOLON statements .

    RCURLY          reduce using rule 13 (statements -> write statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 13 (statements -> write statements SEMMICOLON statements .)


state 196

    (19) assign -> ID add_id2 EQUALS saveOperator . exp generateAssignQuad
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)

    exp                            shift and go to state 225
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 197

    (20) assign -> ID add_id2 arr EQUALS . saveOperator exp generateAssignQuad
    (93) saveOperator -> .

    ID              reduce using rule 93 (saveOperator -> .)
    CTEI            reduce using rule 93 (saveOperator -> .)
    CTEF            reduce using rule 93 (saveOperator -> .)
    CTEC            reduce using rule 93 (saveOperator -> .)
    CTESTRING       reduce using rule 93 (saveOperator -> .)
    LPAREN          reduce using rule 93 (saveOperator -> .)
    OR              reduce using rule 93 (saveOperator -> .)
    AND             reduce using rule 93 (saveOperator -> .)
    GT              reduce using rule 93 (saveOperator -> .)
    LT              reduce using rule 93 (saveOperator -> .)
    GTE             reduce using rule 93 (saveOperator -> .)
    LTE             reduce using rule 93 (saveOperator -> .)
    NE              reduce using rule 93 (saveOperator -> .)
    PLUS            reduce using rule 93 (saveOperator -> .)
    MINUS           reduce using rule 93 (saveOperator -> .)
    MUL             reduce using rule 93 (saveOperator -> .)
    DIV             reduce using rule 93 (saveOperator -> .)
    SEMMICOLON      reduce using rule 93 (saveOperator -> .)
    TO              reduce using rule 93 (saveOperator -> .)

    saveOperator                   shift and go to state 226

state 198

    (34) read -> READ operatorRead LPAREN paramReadAux . RPAREN

    RPAREN          shift and go to state 227


state 199

    (37) paramReadAux -> exp . generateQuadREAD
    (38) paramReadAux -> exp . generateQuadREAD COMMA operatorRead paramReadAux
    (40) generateQuadREAD -> .

    COMMA           reduce using rule 40 (generateQuadREAD -> .)
    RPAREN          reduce using rule 40 (generateQuadREAD -> .)

    generateQuadREAD               shift and go to state 228

state 200

    (41) write -> WRITE writeOperator LPAREN paramWrite . RPAREN

    RPAREN          shift and go to state 229


state 201

    (42) paramWrite -> paramWriteAux .

    RPAREN          reduce using rule 42 (paramWrite -> paramWriteAux .)


state 202

    (43) paramWrite -> empty .
    (91) pexp -> empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 43 (paramWrite -> empty .)
    RPAREN          reduce using rule 43 (paramWrite -> empty .)
    MUL             reduce using rule 91 (pexp -> empty .)
    DIV             reduce using rule 91 (pexp -> empty .)
    PLUS            reduce using rule 91 (pexp -> empty .)
    MINUS           reduce using rule 91 (pexp -> empty .)
    GT              reduce using rule 91 (pexp -> empty .)
    LT              reduce using rule 91 (pexp -> empty .)
    GTE             reduce using rule 91 (pexp -> empty .)
    LTE             reduce using rule 91 (pexp -> empty .)
    NE              reduce using rule 91 (pexp -> empty .)
    AND             reduce using rule 91 (pexp -> empty .)
    OR              reduce using rule 91 (pexp -> empty .)
    COMMA           reduce using rule 91 (pexp -> empty .)

  ! RPAREN          [ reduce using rule 91 (pexp -> empty .) ]


state 203

    (44) paramWriteAux -> exp . generateQuadPRINT
    (45) paramWriteAux -> exp . generateQuadPRINT COMMA writeOperator paramWriteAux
    (47) generateQuadPRINT -> .

    COMMA           reduce using rule 47 (generateQuadPRINT -> .)
    RPAREN          reduce using rule 47 (generateQuadPRINT -> .)

    generateQuadPRINT              shift and go to state 230

state 204

    (49) for -> FOR forOP assign TO . CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    CTEI            shift and go to state 231


state 205

    (52) while -> WHILE whileOP LPAREN exp . RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    RPAREN          shift and go to state 232


state 206

    (55) if -> IF LPAREN exp RPAREN . generateQuadIF THEN LCURLY statements RCURLY else endIF
    (58) generateQuadIF -> .

    THEN            reduce using rule 58 (generateQuadIF -> .)

    generateQuadIF                 shift and go to state 233

state 207

    (133) return -> RETURN LPAREN exp RPAREN . SEMMICOLON
    (134) return -> RETURN LPAREN exp RPAREN .

  ! shift/reduce conflict for SEMMICOLON resolved as shift
    SEMMICOLON      shift and go to state 234
    ID              reduce using rule 134 (return -> RETURN LPAREN exp RPAREN .)
    READ            reduce using rule 134 (return -> RETURN LPAREN exp RPAREN .)
    WRITE           reduce using rule 134 (return -> RETURN LPAREN exp RPAREN .)
    FOR             reduce using rule 134 (return -> RETURN LPAREN exp RPAREN .)
    WHILE           reduce using rule 134 (return -> RETURN LPAREN exp RPAREN .)
    IF              reduce using rule 134 (return -> RETURN LPAREN exp RPAREN .)
    RETURN          reduce using rule 134 (return -> RETURN LPAREN exp RPAREN .)
    RCURLY          reduce using rule 134 (return -> RETURN LPAREN exp RPAREN .)

  ! SEMMICOLON      [ reduce using rule 134 (return -> RETURN LPAREN exp RPAREN .) ]


state 208

    (116) functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY . statements RCURLY
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)

    statements                     shift and go to state 235
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 209

    (121) paramsAux -> INT saveTypeVar TWOPOINTS ID . addParameter nextParam
    (118) addParameter -> .

    COMMA           reduce using rule 118 (addParameter -> .)
    RPAREN          reduce using rule 118 (addParameter -> .)

    addParameter                   shift and go to state 236

state 210

    (122) paramsAux -> FLOAT saveTypeVar TWOPOINTS ID . addParameter nextParam
    (118) addParameter -> .

    COMMA           reduce using rule 118 (addParameter -> .)
    RPAREN          reduce using rule 118 (addParameter -> .)

    addParameter                   shift and go to state 237

state 211

    (123) paramsAux -> CHAR saveTypeVar TWOPOINTS ID . addParameter nextParam
    (118) addParameter -> .

    COMMA           reduce using rule 118 (addParameter -> .)
    RPAREN          reduce using rule 118 (addParameter -> .)

    addParameter                   shift and go to state 238

state 212

    (62) exp -> nexp generateQuadOR OR saveOperator nexp .

    RBRACKET        reduce using rule 62 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    RPAREN          reduce using rule 62 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    COMMA           reduce using rule 62 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    SEMMICOLON      reduce using rule 62 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    TO              reduce using rule 62 (exp -> nexp generateQuadOR OR saveOperator nexp .)


state 213

    (65) nexp -> compexp generateQuadAND AND saveOperator compexp .

    OR              reduce using rule 65 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    RBRACKET        reduce using rule 65 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    RPAREN          reduce using rule 65 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    COMMA           reduce using rule 65 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    SEMMICOLON      reduce using rule 65 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    TO              reduce using rule 65 (nexp -> compexp generateQuadAND AND saveOperator compexp .)


state 214

    (69) compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .

    ID              reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEI            reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 69 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)


state 215

    (70) compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .

    ID              reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEI            reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 70 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)


state 216

    (71) compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .

    ID              reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEI            reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 71 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)


state 217

    (72) compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .

    ID              reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEI            reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 72 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)


state 218

    (73) compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .

    ID              reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEI            reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 73 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)


state 219

    (76) sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .

    GT              reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LT              reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    GTE             reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LTE             reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    NE              reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    AND             reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    OR              reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    RBRACKET        reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    RPAREN          reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    COMMA           reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    SEMMICOLON      reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    TO              reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    ID              reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEI            reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEF            reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEC            reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTESTRING       reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LPAREN          reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    PLUS            reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    MINUS           reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    MUL             reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    DIV             reduce using rule 76 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)


state 220

    (77) sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .

    GT              reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LT              reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    GTE             reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LTE             reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    NE              reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    AND             reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    OR              reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    RBRACKET        reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    RPAREN          reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    COMMA           reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    SEMMICOLON      reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    TO              reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    ID              reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEI            reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEF            reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEC            reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTESTRING       reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LPAREN          reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    PLUS            reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    MINUS           reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    MUL             reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    DIV             reduce using rule 77 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)


state 221

    (80) mulexp -> pexp MUL saveOperator pexp generateQuadMUL .

    PLUS            reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    MINUS           reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    GT              reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LT              reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    GTE             reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LTE             reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    NE              reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    AND             reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    OR              reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    RBRACKET        reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    RPAREN          reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    COMMA           reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    SEMMICOLON      reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    TO              reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    ID              reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEI            reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEF            reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEC            reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTESTRING       reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LPAREN          reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    MUL             reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    DIV             reduce using rule 80 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)


state 222

    (81) mulexp -> pexp DIV saveOperator pexp generateQuadMUL .

    PLUS            reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    MINUS           reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    GT              reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LT              reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    GTE             reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LTE             reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    NE              reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    AND             reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    OR              reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    RBRACKET        reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    RPAREN          reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    COMMA           reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    SEMMICOLON      reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    TO              reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    ID              reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEI            reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEF            reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEC            reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTESTRING       reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LPAREN          reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    MUL             reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    DIV             reduce using rule 81 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)


state 223

    (26) functionCall -> ID functionERA LPAREN expAux generateQuadPARAM . RPAREN generateQuadGOSUB

    RPAREN          shift and go to state 239


state 224

    (29) expAux -> exp COMMA . expAux
    (28) expAux -> . exp
    (29) expAux -> . exp COMMA expAux
    (30) expAux -> . empty
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (135) empty -> .
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB

    RPAREN          reduce using rule 135 (empty -> .)
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78

    exp                            shift and go to state 192
    expAux                         shift and go to state 240
    empty                          shift and go to state 193
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77

state 225

    (19) assign -> ID add_id2 EQUALS saveOperator exp . generateAssignQuad
    (21) generateAssignQuad -> .

    SEMMICOLON      reduce using rule 21 (generateAssignQuad -> .)
    TO              reduce using rule 21 (generateAssignQuad -> .)

    generateAssignQuad             shift and go to state 241

state 226

    (20) assign -> ID add_id2 arr EQUALS saveOperator . exp generateAssignQuad
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)
    TO              reduce using rule 135 (empty -> .)

    exp                            shift and go to state 242
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 227

    (34) read -> READ operatorRead LPAREN paramReadAux RPAREN .

    ID              reduce using rule 34 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    READ            reduce using rule 34 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    WRITE           reduce using rule 34 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    FOR             reduce using rule 34 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    WHILE           reduce using rule 34 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    IF              reduce using rule 34 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    RETURN          reduce using rule 34 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    SEMMICOLON      reduce using rule 34 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)


state 228

    (37) paramReadAux -> exp generateQuadREAD .
    (38) paramReadAux -> exp generateQuadREAD . COMMA operatorRead paramReadAux

    RPAREN          reduce using rule 37 (paramReadAux -> exp generateQuadREAD .)
    COMMA           shift and go to state 243


state 229

    (41) write -> WRITE writeOperator LPAREN paramWrite RPAREN .

    ID              reduce using rule 41 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    READ            reduce using rule 41 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    WRITE           reduce using rule 41 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    FOR             reduce using rule 41 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    WHILE           reduce using rule 41 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    IF              reduce using rule 41 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    RETURN          reduce using rule 41 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    SEMMICOLON      reduce using rule 41 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)


state 230

    (44) paramWriteAux -> exp generateQuadPRINT .
    (45) paramWriteAux -> exp generateQuadPRINT . COMMA writeOperator paramWriteAux

    RPAREN          reduce using rule 44 (paramWriteAux -> exp generateQuadPRINT .)
    COMMA           shift and go to state 244


state 231

    (49) for -> FOR forOP assign TO CTEI . DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    DO              shift and go to state 245


state 232

    (52) while -> WHILE whileOP LPAREN exp RPAREN . DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    DO              shift and go to state 246


state 233

    (55) if -> IF LPAREN exp RPAREN generateQuadIF . THEN LCURLY statements RCURLY else endIF

    THEN            shift and go to state 247


state 234

    (133) return -> RETURN LPAREN exp RPAREN SEMMICOLON .

    ID              reduce using rule 133 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    READ            reduce using rule 133 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WRITE           reduce using rule 133 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    FOR             reduce using rule 133 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WHILE           reduce using rule 133 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    IF              reduce using rule 133 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RETURN          reduce using rule 133 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RCURLY          reduce using rule 133 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    SEMMICOLON      reduce using rule 133 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)


state 235

    (116) functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY statements . RCURLY

    RCURLY          shift and go to state 248


state 236

    (121) paramsAux -> INT saveTypeVar TWOPOINTS ID addParameter . nextParam
    (124) nextParam -> . COMMA paramsAux
    (125) nextParam -> . empty
    (135) empty -> .

    COMMA           shift and go to state 250
    RPAREN          reduce using rule 135 (empty -> .)

    nextParam                      shift and go to state 249
    empty                          shift and go to state 251

state 237

    (122) paramsAux -> FLOAT saveTypeVar TWOPOINTS ID addParameter . nextParam
    (124) nextParam -> . COMMA paramsAux
    (125) nextParam -> . empty
    (135) empty -> .

    COMMA           shift and go to state 250
    RPAREN          reduce using rule 135 (empty -> .)

    nextParam                      shift and go to state 252
    empty                          shift and go to state 251

state 238

    (123) paramsAux -> CHAR saveTypeVar TWOPOINTS ID addParameter . nextParam
    (124) nextParam -> . COMMA paramsAux
    (125) nextParam -> . empty
    (135) empty -> .

    COMMA           shift and go to state 250
    RPAREN          reduce using rule 135 (empty -> .)

    nextParam                      shift and go to state 253
    empty                          shift and go to state 251

state 239

    (26) functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN . generateQuadGOSUB
    (31) generateQuadGOSUB -> .

    MUL             reduce using rule 31 (generateQuadGOSUB -> .)
    DIV             reduce using rule 31 (generateQuadGOSUB -> .)
    PLUS            reduce using rule 31 (generateQuadGOSUB -> .)
    MINUS           reduce using rule 31 (generateQuadGOSUB -> .)
    GT              reduce using rule 31 (generateQuadGOSUB -> .)
    LT              reduce using rule 31 (generateQuadGOSUB -> .)
    GTE             reduce using rule 31 (generateQuadGOSUB -> .)
    LTE             reduce using rule 31 (generateQuadGOSUB -> .)
    NE              reduce using rule 31 (generateQuadGOSUB -> .)
    AND             reduce using rule 31 (generateQuadGOSUB -> .)
    OR              reduce using rule 31 (generateQuadGOSUB -> .)
    RBRACKET        reduce using rule 31 (generateQuadGOSUB -> .)
    SEMMICOLON      reduce using rule 31 (generateQuadGOSUB -> .)
    RPAREN          reduce using rule 31 (generateQuadGOSUB -> .)
    COMMA           reduce using rule 31 (generateQuadGOSUB -> .)
    TO              reduce using rule 31 (generateQuadGOSUB -> .)
    ID              reduce using rule 31 (generateQuadGOSUB -> .)
    CTEI            reduce using rule 31 (generateQuadGOSUB -> .)
    CTEF            reduce using rule 31 (generateQuadGOSUB -> .)
    CTEC            reduce using rule 31 (generateQuadGOSUB -> .)
    CTESTRING       reduce using rule 31 (generateQuadGOSUB -> .)
    LPAREN          reduce using rule 31 (generateQuadGOSUB -> .)

    generateQuadGOSUB              shift and go to state 254

state 240

    (29) expAux -> exp COMMA expAux .

    RPAREN          reduce using rule 29 (expAux -> exp COMMA expAux .)


state 241

    (19) assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .

    SEMMICOLON      reduce using rule 19 (assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .)
    TO              reduce using rule 19 (assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .)


state 242

    (20) assign -> ID add_id2 arr EQUALS saveOperator exp . generateAssignQuad
    (21) generateAssignQuad -> .

    SEMMICOLON      reduce using rule 21 (generateAssignQuad -> .)
    TO              reduce using rule 21 (generateAssignQuad -> .)

    generateAssignQuad             shift and go to state 255

state 243

    (38) paramReadAux -> exp generateQuadREAD COMMA . operatorRead paramReadAux
    (39) operatorRead -> .

    ID              reduce using rule 39 (operatorRead -> .)
    CTEI            reduce using rule 39 (operatorRead -> .)
    CTEF            reduce using rule 39 (operatorRead -> .)
    CTEC            reduce using rule 39 (operatorRead -> .)
    CTESTRING       reduce using rule 39 (operatorRead -> .)
    LPAREN          reduce using rule 39 (operatorRead -> .)
    COMMA           reduce using rule 39 (operatorRead -> .)
    OR              reduce using rule 39 (operatorRead -> .)
    AND             reduce using rule 39 (operatorRead -> .)
    GT              reduce using rule 39 (operatorRead -> .)
    LT              reduce using rule 39 (operatorRead -> .)
    GTE             reduce using rule 39 (operatorRead -> .)
    LTE             reduce using rule 39 (operatorRead -> .)
    NE              reduce using rule 39 (operatorRead -> .)
    PLUS            reduce using rule 39 (operatorRead -> .)
    MINUS           reduce using rule 39 (operatorRead -> .)
    MUL             reduce using rule 39 (operatorRead -> .)
    DIV             reduce using rule 39 (operatorRead -> .)
    RPAREN          reduce using rule 39 (operatorRead -> .)

    operatorRead                   shift and go to state 256

state 244

    (45) paramWriteAux -> exp generateQuadPRINT COMMA . writeOperator paramWriteAux
    (46) writeOperator -> .

    ID              reduce using rule 46 (writeOperator -> .)
    CTEI            reduce using rule 46 (writeOperator -> .)
    CTEF            reduce using rule 46 (writeOperator -> .)
    CTEC            reduce using rule 46 (writeOperator -> .)
    CTESTRING       reduce using rule 46 (writeOperator -> .)
    LPAREN          reduce using rule 46 (writeOperator -> .)
    COMMA           reduce using rule 46 (writeOperator -> .)
    OR              reduce using rule 46 (writeOperator -> .)
    AND             reduce using rule 46 (writeOperator -> .)
    GT              reduce using rule 46 (writeOperator -> .)
    LT              reduce using rule 46 (writeOperator -> .)
    GTE             reduce using rule 46 (writeOperator -> .)
    LTE             reduce using rule 46 (writeOperator -> .)
    NE              reduce using rule 46 (writeOperator -> .)
    PLUS            reduce using rule 46 (writeOperator -> .)
    MINUS           reduce using rule 46 (writeOperator -> .)
    MUL             reduce using rule 46 (writeOperator -> .)
    DIV             reduce using rule 46 (writeOperator -> .)
    RPAREN          reduce using rule 46 (writeOperator -> .)

    writeOperator                  shift and go to state 257

state 245

    (49) for -> FOR forOP assign TO CTEI DO . generateQuadFOR LCURLY statements RCURLY LoopEnd
    (51) generateQuadFOR -> .

    LCURLY          reduce using rule 51 (generateQuadFOR -> .)

    generateQuadFOR                shift and go to state 258

state 246

    (52) while -> WHILE whileOP LPAREN exp RPAREN DO . generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (54) generateQuadWHILE -> .

    LCURLY          reduce using rule 54 (generateQuadWHILE -> .)

    generateQuadWHILE              shift and go to state 259

state 247

    (55) if -> IF LPAREN exp RPAREN generateQuadIF THEN . LCURLY statements RCURLY else endIF

    LCURLY          shift and go to state 260


state 248

    (116) functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY statements RCURLY .

    FUNCTION        reduce using rule 116 (functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY statements RCURLY .)
    PRINCIPAL       reduce using rule 116 (functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY statements RCURLY .)
    $end            reduce using rule 116 (functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY statements RCURLY .)


state 249

    (121) paramsAux -> INT saveTypeVar TWOPOINTS ID addParameter nextParam .

    RPAREN          reduce using rule 121 (paramsAux -> INT saveTypeVar TWOPOINTS ID addParameter nextParam .)


state 250

    (124) nextParam -> COMMA . paramsAux
    (121) paramsAux -> . INT saveTypeVar TWOPOINTS ID addParameter nextParam
    (122) paramsAux -> . FLOAT saveTypeVar TWOPOINTS ID addParameter nextParam
    (123) paramsAux -> . CHAR saveTypeVar TWOPOINTS ID addParameter nextParam

    INT             shift and go to state 100
    FLOAT           shift and go to state 101
    CHAR            shift and go to state 102

    paramsAux                      shift and go to state 261

state 251

    (125) nextParam -> empty .

    RPAREN          reduce using rule 125 (nextParam -> empty .)


state 252

    (122) paramsAux -> FLOAT saveTypeVar TWOPOINTS ID addParameter nextParam .

    RPAREN          reduce using rule 122 (paramsAux -> FLOAT saveTypeVar TWOPOINTS ID addParameter nextParam .)


state 253

    (123) paramsAux -> CHAR saveTypeVar TWOPOINTS ID addParameter nextParam .

    RPAREN          reduce using rule 123 (paramsAux -> CHAR saveTypeVar TWOPOINTS ID addParameter nextParam .)


state 254

    (26) functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .

    MUL             reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    DIV             reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    PLUS            reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    MINUS           reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    GT              reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    LT              reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    GTE             reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    LTE             reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    NE              reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    AND             reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    OR              reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    RBRACKET        reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    SEMMICOLON      reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    RPAREN          reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    COMMA           reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    TO              reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    ID              reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    CTEI            reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    CTEF            reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    CTEC            reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    CTESTRING       reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)
    LPAREN          reduce using rule 26 (functionCall -> ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB .)


state 255

    (20) assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .

    SEMMICOLON      reduce using rule 20 (assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .)
    TO              reduce using rule 20 (assign -> ID add_id2 arr EQUALS saveOperator exp generateAssignQuad .)


state 256

    (38) paramReadAux -> exp generateQuadREAD COMMA operatorRead . paramReadAux
    (37) paramReadAux -> . exp generateQuadREAD
    (38) paramReadAux -> . exp generateQuadREAD COMMA operatorRead paramReadAux
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)

    exp                            shift and go to state 199
    paramReadAux                   shift and go to state 262
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 257

    (45) paramWriteAux -> exp generateQuadPRINT COMMA writeOperator . paramWriteAux
    (44) paramWriteAux -> . exp generateQuadPRINT
    (45) paramWriteAux -> . exp generateQuadPRINT COMMA writeOperator paramWriteAux
    (61) exp -> . nexp generateQuadOR
    (62) exp -> . nexp generateQuadOR OR saveOperator nexp
    (64) nexp -> . compexp generateQuadAND
    (65) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (67) compexp -> . sumexp
    (68) compexp -> . compexp1 sumexp
    (75) sumexp -> . mulexp
    (76) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (77) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (69) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (70) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (71) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (72) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (79) mulexp -> . pexp
    (80) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (81) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (83) pexp -> . ID add_id2
    (84) pexp -> . CTEI saveCTE
    (85) pexp -> . CTEF saveCTE
    (86) pexp -> . CTEC saveCTE
    (87) pexp -> . CTESTRING saveCTE
    (88) pexp -> . functionCall
    (89) pexp -> . LPAREN exp RPAREN
    (90) pexp -> . ID arr add_id3
    (91) pexp -> . empty
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (135) empty -> .

    ID              shift and go to state 73
    CTEI            shift and go to state 116
    CTEF            shift and go to state 74
    CTEC            shift and go to state 75
    CTESTRING       shift and go to state 76
    LPAREN          shift and go to state 78
    MUL             reduce using rule 135 (empty -> .)
    DIV             reduce using rule 135 (empty -> .)
    PLUS            reduce using rule 135 (empty -> .)
    MINUS           reduce using rule 135 (empty -> .)
    GT              reduce using rule 135 (empty -> .)
    LT              reduce using rule 135 (empty -> .)
    GTE             reduce using rule 135 (empty -> .)
    LTE             reduce using rule 135 (empty -> .)
    NE              reduce using rule 135 (empty -> .)
    AND             reduce using rule 135 (empty -> .)
    OR              reduce using rule 135 (empty -> .)
    COMMA           reduce using rule 135 (empty -> .)
    RPAREN          reduce using rule 135 (empty -> .)

    exp                            shift and go to state 203
    paramWriteAux                  shift and go to state 263
    nexp                           shift and go to state 67
    compexp                        shift and go to state 68
    sumexp                         shift and go to state 69
    compexp1                       shift and go to state 70
    mulexp                         shift and go to state 71
    pexp                           shift and go to state 72
    functionCall                   shift and go to state 77
    empty                          shift and go to state 79

state 258

    (49) for -> FOR forOP assign TO CTEI DO generateQuadFOR . LCURLY statements RCURLY LoopEnd

    LCURLY          shift and go to state 264


state 259

    (52) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE . LCURLY statements RCURLY LoopEnd

    LCURLY          shift and go to state 265


state 260

    (55) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY . statements RCURLY else endIF
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)

    statements                     shift and go to state 266
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 261

    (124) nextParam -> COMMA paramsAux .

    RPAREN          reduce using rule 124 (nextParam -> COMMA paramsAux .)


state 262

    (38) paramReadAux -> exp generateQuadREAD COMMA operatorRead paramReadAux .

    RPAREN          reduce using rule 38 (paramReadAux -> exp generateQuadREAD COMMA operatorRead paramReadAux .)


state 263

    (45) paramWriteAux -> exp generateQuadPRINT COMMA writeOperator paramWriteAux .

    RPAREN          reduce using rule 45 (paramWriteAux -> exp generateQuadPRINT COMMA writeOperator paramWriteAux .)


state 264

    (49) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY . statements RCURLY LoopEnd
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)

    assign                         shift and go to state 81
    statements                     shift and go to state 267
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 265

    (52) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY . statements RCURLY LoopEnd
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)

    statements                     shift and go to state 268
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 266

    (55) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements . RCURLY else endIF

    RCURLY          shift and go to state 269


state 267

    (49) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements . RCURLY LoopEnd

    RCURLY          shift and go to state 270


state 268

    (52) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements . RCURLY LoopEnd

    RCURLY          shift and go to state 271


state 269

    (55) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY . else endIF
    (56) else -> . ELSE generateQuadELSE LCURLY statements RCURLY
    (57) else -> . empty
    (135) empty -> .

    ELSE            shift and go to state 273
    ID              reduce using rule 135 (empty -> .)
    READ            reduce using rule 135 (empty -> .)
    WRITE           reduce using rule 135 (empty -> .)
    FOR             reduce using rule 135 (empty -> .)
    WHILE           reduce using rule 135 (empty -> .)
    IF              reduce using rule 135 (empty -> .)
    RETURN          reduce using rule 135 (empty -> .)
    RCURLY          reduce using rule 135 (empty -> .)
    SEMMICOLON      reduce using rule 135 (empty -> .)

    else                           shift and go to state 272
    empty                          shift and go to state 274

state 270

    (49) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY . LoopEnd
    (48) LoopEnd -> .

    ID              reduce using rule 48 (LoopEnd -> .)
    READ            reduce using rule 48 (LoopEnd -> .)
    WRITE           reduce using rule 48 (LoopEnd -> .)
    FOR             reduce using rule 48 (LoopEnd -> .)
    WHILE           reduce using rule 48 (LoopEnd -> .)
    IF              reduce using rule 48 (LoopEnd -> .)
    RETURN          reduce using rule 48 (LoopEnd -> .)
    RCURLY          reduce using rule 48 (LoopEnd -> .)
    SEMMICOLON      reduce using rule 48 (LoopEnd -> .)

    LoopEnd                        shift and go to state 275

state 271

    (52) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY . LoopEnd
    (48) LoopEnd -> .

    ID              reduce using rule 48 (LoopEnd -> .)
    READ            reduce using rule 48 (LoopEnd -> .)
    WRITE           reduce using rule 48 (LoopEnd -> .)
    FOR             reduce using rule 48 (LoopEnd -> .)
    WHILE           reduce using rule 48 (LoopEnd -> .)
    IF              reduce using rule 48 (LoopEnd -> .)
    RETURN          reduce using rule 48 (LoopEnd -> .)
    RCURLY          reduce using rule 48 (LoopEnd -> .)
    SEMMICOLON      reduce using rule 48 (LoopEnd -> .)

    LoopEnd                        shift and go to state 276

state 272

    (55) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else . endIF
    (59) endIF -> .

    ID              reduce using rule 59 (endIF -> .)
    READ            reduce using rule 59 (endIF -> .)
    WRITE           reduce using rule 59 (endIF -> .)
    FOR             reduce using rule 59 (endIF -> .)
    WHILE           reduce using rule 59 (endIF -> .)
    IF              reduce using rule 59 (endIF -> .)
    RETURN          reduce using rule 59 (endIF -> .)
    RCURLY          reduce using rule 59 (endIF -> .)
    SEMMICOLON      reduce using rule 59 (endIF -> .)

    endIF                          shift and go to state 277

state 273

    (56) else -> ELSE . generateQuadELSE LCURLY statements RCURLY
    (60) generateQuadELSE -> .

    LCURLY          reduce using rule 60 (generateQuadELSE -> .)

    generateQuadELSE               shift and go to state 278

state 274

    (57) else -> empty .

    ID              reduce using rule 57 (else -> empty .)
    READ            reduce using rule 57 (else -> empty .)
    WRITE           reduce using rule 57 (else -> empty .)
    FOR             reduce using rule 57 (else -> empty .)
    WHILE           reduce using rule 57 (else -> empty .)
    IF              reduce using rule 57 (else -> empty .)
    RETURN          reduce using rule 57 (else -> empty .)
    RCURLY          reduce using rule 57 (else -> empty .)
    SEMMICOLON      reduce using rule 57 (else -> empty .)


state 275

    (49) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .

    ID              reduce using rule 49 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    READ            reduce using rule 49 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    WRITE           reduce using rule 49 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    FOR             reduce using rule 49 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    WHILE           reduce using rule 49 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    IF              reduce using rule 49 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    RETURN          reduce using rule 49 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    RCURLY          reduce using rule 49 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    SEMMICOLON      reduce using rule 49 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)


state 276

    (52) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .

    ID              reduce using rule 52 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    READ            reduce using rule 52 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    WRITE           reduce using rule 52 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    FOR             reduce using rule 52 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    WHILE           reduce using rule 52 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    IF              reduce using rule 52 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    RETURN          reduce using rule 52 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    RCURLY          reduce using rule 52 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    SEMMICOLON      reduce using rule 52 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)


state 277

    (55) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .

    ID              reduce using rule 55 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    READ            reduce using rule 55 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    WRITE           reduce using rule 55 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    FOR             reduce using rule 55 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    WHILE           reduce using rule 55 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    IF              reduce using rule 55 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    RETURN          reduce using rule 55 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    RCURLY          reduce using rule 55 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    SEMMICOLON      reduce using rule 55 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)


state 278

    (56) else -> ELSE generateQuadELSE . LCURLY statements RCURLY

    LCURLY          shift and go to state 279


state 279

    (56) else -> ELSE generateQuadELSE LCURLY . statements RCURLY
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . return statements
    (18) statements -> . empty
    (19) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 arr EQUALS saveOperator exp generateAssignQuad
    (26) functionCall -> . ID functionERA LPAREN expAux generateQuadPARAM RPAREN generateQuadGOSUB
    (34) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (41) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (49) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (52) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (55) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (133) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (134) return -> . RETURN LPAREN exp RPAREN
    (135) empty -> .

    ID              shift and go to state 90
    READ            shift and go to state 91
    WRITE           shift and go to state 92
    FOR             shift and go to state 93
    WHILE           shift and go to state 94
    IF              shift and go to state 95
    RETURN          shift and go to state 96
    RCURLY          reduce using rule 135 (empty -> .)

    statements                     shift and go to state 280
    assign                         shift and go to state 81
    functionCall                   shift and go to state 82
    read                           shift and go to state 83
    write                          shift and go to state 84
    for                            shift and go to state 85
    while                          shift and go to state 86
    if                             shift and go to state 87
    return                         shift and go to state 88
    empty                          shift and go to state 89

state 280

    (56) else -> ELSE generateQuadELSE LCURLY statements . RCURLY

    RCURLY          shift and go to state 281


state 281

    (56) else -> ELSE generateQuadELSE LCURLY statements RCURLY .

    ID              reduce using rule 56 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    READ            reduce using rule 56 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    WRITE           reduce using rule 56 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    FOR             reduce using rule 56 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    WHILE           reduce using rule 56 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    IF              reduce using rule 56 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    RETURN          reduce using rule 56 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    RCURLY          reduce using rule 56 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 56 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PRINCIPAL in state 5 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 65 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 71 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 71 resolved as shift
WARNING: shift/reduce conflict for MUL in state 72 resolved as shift
WARNING: shift/reduce conflict for DIV in state 72 resolved as shift
WARNING: shift/reduce conflict for ID in state 151 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 151 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 151 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 151 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 151 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 151 resolved as shift
WARNING: shift/reduce conflict for ID in state 152 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 152 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 152 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 152 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 152 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 152 resolved as shift
WARNING: shift/reduce conflict for ID in state 153 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 153 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 153 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 153 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 153 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 153 resolved as shift
WARNING: shift/reduce conflict for ID in state 154 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 154 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 154 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 154 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 154 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 154 resolved as shift
WARNING: shift/reduce conflict for ID in state 155 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 155 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 155 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 155 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 155 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 155 resolved as shift
WARNING: shift/reduce conflict for ID in state 156 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 156 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 156 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 156 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 156 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 156 resolved as shift
WARNING: shift/reduce conflict for ID in state 157 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 157 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 157 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 157 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 157 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 157 resolved as shift
WARNING: shift/reduce conflict for ID in state 158 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 158 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 158 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 158 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 158 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 158 resolved as shift
WARNING: shift/reduce conflict for ID in state 159 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 159 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 159 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 159 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 159 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 159 resolved as shift
WARNING: shift/reduce conflict for SEMMICOLON in state 207 resolved as shift
WARNING: reduce/reduce conflict in state 73 resolved using rule (add_id2 -> <empty>)
WARNING: rejected rule (functionERA -> <empty>) in state 73
WARNING: reduce/reduce conflict in state 193 resolved using rule (expAux -> empty)
WARNING: rejected rule (pexp -> empty) in state 193
WARNING: reduce/reduce conflict in state 202 resolved using rule (paramWrite -> empty)
WARNING: rejected rule (pexp -> empty) in state 202
