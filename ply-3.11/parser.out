Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CTEC
    END
    FROM
    MODA
    PLOTXY
    SIMPLEREGRESSION
    VARIANZA

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID addProgram SEMMICOLON program1
Rule 2     addProgram -> <empty>
Rule 3     program1 -> vars functions principal
Rule 4     program1 -> vars functions
Rule 5     program1 -> program2
Rule 6     program2 -> principal
Rule 7     principal -> PRINCIPAL LPAREN RPAREN LCURLY statements RCURLY
Rule 8     statements -> assign SEMMICOLON statements
Rule 9     statements -> functionCall SEMMICOLON statements
Rule 10    statements -> read statements SEMMICOLON statements
Rule 11    statements -> write statements SEMMICOLON statements
Rule 12    statements -> for statements
Rule 13    statements -> while statements
Rule 14    statements -> if statements
Rule 15    statements -> return statements
Rule 16    statements -> empty
Rule 17    assign -> ID EQUALS exp
Rule 18    assign -> ID LBRACKET exp RBRACKET EQUALS exp
Rule 19    functionCall -> ID LPAREN exp RPAREN
Rule 20    read -> READ LPAREN read1 RPAREN
Rule 21    read1 -> ID read2
Rule 22    read2 -> COMMA read1
Rule 23    read2 -> empty
Rule 24    media -> MEDIA LPAREN arr RPAREN SEMMICOLON
Rule 25    write -> WRITE LPAREN write1 RPAREN
Rule 26    write1 -> write2 COMMA write2
Rule 27    write1 -> write2
Rule 28    write2 -> CTESTRING
Rule 29    write2 -> CTEI
Rule 30    write2 -> CTEF
Rule 31    write2 -> exp
Rule 32    for -> FOR assign TO CTEI DO LCURLY statements RCURLY
Rule 33    while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
Rule 34    if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
Rule 35    else -> ELSE LCURLY statements RCURLY
Rule 36    else -> empty
Rule 37    exp -> nexp
Rule 38    exp -> nexp OR nexp
Rule 39    nexp -> compexp
Rule 40    nexp -> compexp AND compexp
Rule 41    compexp -> sumexp
Rule 42    compexp -> compexp1 sumexp
Rule 43    compexp1 -> sumexp GT sumexp
Rule 44    compexp1 -> sumexp LT sumexp
Rule 45    compexp1 -> sumexp GTE sumexp
Rule 46    compexp1 -> sumexp LTE sumexp
Rule 47    compexp1 -> sumexp NE sumexp
Rule 48    sumexp -> mulexp
Rule 49    sumexp -> mulexp PLUS mulexp
Rule 50    sumexp -> mulexp MINUS mulexp
Rule 51    mulexp -> pexp
Rule 52    mulexp -> pexp MUL pexp
Rule 53    mulexp -> pexp DIV pexp
Rule 54    pexp -> var1
Rule 55    pexp -> CTEI
Rule 56    pexp -> CTEF
Rule 57    pexp -> functionCall
Rule 58    pexp -> LPAREN exp RPAREN
Rule 59    vars -> var
Rule 60    vars -> empty
Rule 61    var -> VARS var2
Rule 62    var2 -> var2 type TWOPOINTS var1 SEMMICOLON
Rule 63    var2 -> empty
Rule 64    var1 -> ID
Rule 65    var1 -> ID COMMA var1
Rule 66    var1 -> ID arr
Rule 67    var1 -> ID arr COMMA var1
Rule 68    var1 -> empty
Rule 69    type -> INT
Rule 70    type -> CHAR
Rule 71    type -> FLOAT
Rule 72    arr -> LBRACKET CTEI RBRACKET
Rule 73    arr -> LBRACKET exp RBRACKET
Rule 74    functions -> FUNCTION VOID functionVoid functions
Rule 75    functions -> FUNCTION type functionType functions
Rule 76    functions -> empty
Rule 77    functionVoid -> ID LPAREN args RPAREN vars LCURLY statements RCURLY
Rule 78    functionType -> ID saveFunction LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY
Rule 79    saveFunction -> <empty>
Rule 80    args -> type TWOPOINTS ID MultipleArgs
Rule 81    args -> empty
Rule 82    MultipleArgs -> COMMA args
Rule 83    MultipleArgs -> empty
Rule 84    return -> RETURN LPAREN exp RPAREN SEMMICOLON
Rule 85    return -> RETURN LPAREN exp RPAREN
Rule 86    empty -> <empty>

Terminals, with rules where they appear

AND                  : 40
CHAR                 : 70
COMMA                : 22 26 65 67 82
CTEC                 : 
CTEF                 : 30 56
CTEI                 : 29 32 55 72
CTESTRING            : 28
DIV                  : 53
DO                   : 32 33
ELSE                 : 35
END                  : 
EQUALS               : 17 18
FLOAT                : 71
FOR                  : 32
FROM                 : 
FUNCTION             : 74 75
GT                   : 43
GTE                  : 45
ID                   : 1 17 18 19 21 64 65 66 67 77 78 80
IF                   : 34
INT                  : 69
LBRACKET             : 18 72 73
LCURLY               : 7 32 33 34 35 77 78
LPAREN               : 7 19 20 24 25 33 34 58 77 78 84 85
LT                   : 44
LTE                  : 46
MEDIA                : 24
MINUS                : 50
MODA                 : 
MUL                  : 52
NE                   : 47
OR                   : 38
PLOTXY               : 
PLUS                 : 49
PRINCIPAL            : 7
PROGRAM              : 1
RBRACKET             : 18 72 73
RCURLY               : 7 32 33 34 35 77 78
READ                 : 20
RETURN               : 84 85
RPAREN               : 7 19 20 24 25 33 34 58 77 78 84 85
SEMMICOLON           : 1 8 9 10 11 24 62 78 84
SIMPLEREGRESSION     : 
THEN                 : 34
TO                   : 32
TWOPOINTS            : 62 80
VARIANZA             : 
VARS                 : 61
VOID                 : 74
WHILE                : 33
WRITE                : 25
error                : 

Nonterminals, with rules where they appear

MultipleArgs         : 80
addProgram           : 1
args                 : 77 78 82
arr                  : 24 66 67
assign               : 8 32
compexp              : 39 40 40
compexp1             : 42
else                 : 34
empty                : 16 23 36 60 63 68 76 81 83
exp                  : 17 18 18 19 31 33 34 58 73 84 85
for                  : 12
functionCall         : 9 57
functionType         : 75
functionVoid         : 74
functions            : 3 4 74 75
if                   : 14
media                : 
mulexp               : 48 49 49 50 50
nexp                 : 37 38 38
pexp                 : 51 52 52 53 53
principal            : 3 6
program              : 0
program1             : 1
program2             : 5
read                 : 10
read1                : 20 22
read2                : 21
return               : 15 78
saveFunction         : 78
statements           : 7 8 9 10 10 11 11 12 13 14 15 32 33 34 35 77 78
sumexp               : 41 42 43 43 44 44 45 45 46 46 47 47
type                 : 62 75 80
var                  : 59
var1                 : 54 62 65 67
var2                 : 61 62
vars                 : 3 4 77 78
while                : 13
write                : 11
write1               : 25
write2               : 26 26 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID addProgram SEMMICOLON program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID addProgram SEMMICOLON program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . addProgram SEMMICOLON program1
    (2) addProgram -> .

    SEMMICOLON      reduce using rule 2 (addProgram -> .)

    addProgram                     shift and go to state 4

state 4

    (1) program -> PROGRAM ID addProgram . SEMMICOLON program1

    SEMMICOLON      shift and go to state 5


state 5

    (1) program -> PROGRAM ID addProgram SEMMICOLON . program1
    (3) program1 -> . vars functions principal
    (4) program1 -> . vars functions
    (5) program1 -> . program2
    (59) vars -> . var
    (60) vars -> . empty
    (6) program2 -> . principal
    (61) var -> . VARS var2
    (86) empty -> .
    (7) principal -> . PRINCIPAL LPAREN RPAREN LCURLY statements RCURLY

  ! shift/reduce conflict for PRINCIPAL resolved as shift
    VARS            shift and go to state 12
    FUNCTION        reduce using rule 86 (empty -> .)
    $end            reduce using rule 86 (empty -> .)
    PRINCIPAL       shift and go to state 13

  ! PRINCIPAL       [ reduce using rule 86 (empty -> .) ]

    program1                       shift and go to state 6
    vars                           shift and go to state 7
    principal                      shift and go to state 8
    program2                       shift and go to state 9
    var                            shift and go to state 10
    empty                          shift and go to state 11

state 6

    (1) program -> PROGRAM ID addProgram SEMMICOLON program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID addProgram SEMMICOLON program1 .)


state 7

    (3) program1 -> vars . functions principal
    (4) program1 -> vars . functions
    (74) functions -> . FUNCTION VOID functionVoid functions
    (75) functions -> . FUNCTION type functionType functions
    (76) functions -> . empty
    (86) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 86 (empty -> .)
    $end            reduce using rule 86 (empty -> .)

    functions                      shift and go to state 14
    empty                          shift and go to state 16

state 8

    (6) program2 -> principal .

    $end            reduce using rule 6 (program2 -> principal .)


state 9

    (5) program1 -> program2 .

    $end            reduce using rule 5 (program1 -> program2 .)


state 10

    (59) vars -> var .

    FUNCTION        reduce using rule 59 (vars -> var .)
    PRINCIPAL       reduce using rule 59 (vars -> var .)
    $end            reduce using rule 59 (vars -> var .)
    LCURLY          reduce using rule 59 (vars -> var .)


state 11

    (60) vars -> empty .

    FUNCTION        reduce using rule 60 (vars -> empty .)
    PRINCIPAL       reduce using rule 60 (vars -> empty .)
    $end            reduce using rule 60 (vars -> empty .)
    LCURLY          reduce using rule 60 (vars -> empty .)


state 12

    (61) var -> VARS . var2
    (62) var2 -> . var2 type TWOPOINTS var1 SEMMICOLON
    (63) var2 -> . empty
    (86) empty -> .

    INT             reduce using rule 86 (empty -> .)
    CHAR            reduce using rule 86 (empty -> .)
    FLOAT           reduce using rule 86 (empty -> .)
    FUNCTION        reduce using rule 86 (empty -> .)
    PRINCIPAL       reduce using rule 86 (empty -> .)
    $end            reduce using rule 86 (empty -> .)
    LCURLY          reduce using rule 86 (empty -> .)

    var2                           shift and go to state 17
    empty                          shift and go to state 18

state 13

    (7) principal -> PRINCIPAL . LPAREN RPAREN LCURLY statements RCURLY

    LPAREN          shift and go to state 19


state 14

    (3) program1 -> vars functions . principal
    (4) program1 -> vars functions .
    (7) principal -> . PRINCIPAL LPAREN RPAREN LCURLY statements RCURLY

    $end            reduce using rule 4 (program1 -> vars functions .)
    PRINCIPAL       shift and go to state 13

    principal                      shift and go to state 20

state 15

    (74) functions -> FUNCTION . VOID functionVoid functions
    (75) functions -> FUNCTION . type functionType functions
    (69) type -> . INT
    (70) type -> . CHAR
    (71) type -> . FLOAT

    VOID            shift and go to state 21
    INT             shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25

    type                           shift and go to state 22

state 16

    (76) functions -> empty .

    PRINCIPAL       reduce using rule 76 (functions -> empty .)
    $end            reduce using rule 76 (functions -> empty .)


state 17

    (61) var -> VARS var2 .
    (62) var2 -> var2 . type TWOPOINTS var1 SEMMICOLON
    (69) type -> . INT
    (70) type -> . CHAR
    (71) type -> . FLOAT

    FUNCTION        reduce using rule 61 (var -> VARS var2 .)
    PRINCIPAL       reduce using rule 61 (var -> VARS var2 .)
    $end            reduce using rule 61 (var -> VARS var2 .)
    LCURLY          reduce using rule 61 (var -> VARS var2 .)
    INT             shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25

    type                           shift and go to state 26

state 18

    (63) var2 -> empty .

    INT             reduce using rule 63 (var2 -> empty .)
    CHAR            reduce using rule 63 (var2 -> empty .)
    FLOAT           reduce using rule 63 (var2 -> empty .)
    FUNCTION        reduce using rule 63 (var2 -> empty .)
    PRINCIPAL       reduce using rule 63 (var2 -> empty .)
    $end            reduce using rule 63 (var2 -> empty .)
    LCURLY          reduce using rule 63 (var2 -> empty .)


state 19

    (7) principal -> PRINCIPAL LPAREN . RPAREN LCURLY statements RCURLY

    RPAREN          shift and go to state 27


state 20

    (3) program1 -> vars functions principal .

    $end            reduce using rule 3 (program1 -> vars functions principal .)


state 21

    (74) functions -> FUNCTION VOID . functionVoid functions
    (77) functionVoid -> . ID LPAREN args RPAREN vars LCURLY statements RCURLY

    ID              shift and go to state 29

    functionVoid                   shift and go to state 28

state 22

    (75) functions -> FUNCTION type . functionType functions
    (78) functionType -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY

    ID              shift and go to state 31

    functionType                   shift and go to state 30

state 23

    (69) type -> INT .

    ID              reduce using rule 69 (type -> INT .)
    TWOPOINTS       reduce using rule 69 (type -> INT .)


state 24

    (70) type -> CHAR .

    ID              reduce using rule 70 (type -> CHAR .)
    TWOPOINTS       reduce using rule 70 (type -> CHAR .)


state 25

    (71) type -> FLOAT .

    ID              reduce using rule 71 (type -> FLOAT .)
    TWOPOINTS       reduce using rule 71 (type -> FLOAT .)


state 26

    (62) var2 -> var2 type . TWOPOINTS var1 SEMMICOLON

    TWOPOINTS       shift and go to state 32


state 27

    (7) principal -> PRINCIPAL LPAREN RPAREN . LCURLY statements RCURLY

    LCURLY          shift and go to state 33


state 28

    (74) functions -> FUNCTION VOID functionVoid . functions
    (74) functions -> . FUNCTION VOID functionVoid functions
    (75) functions -> . FUNCTION type functionType functions
    (76) functions -> . empty
    (86) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 86 (empty -> .)
    $end            reduce using rule 86 (empty -> .)

    functions                      shift and go to state 34
    empty                          shift and go to state 16

state 29

    (77) functionVoid -> ID . LPAREN args RPAREN vars LCURLY statements RCURLY

    LPAREN          shift and go to state 35


state 30

    (75) functions -> FUNCTION type functionType . functions
    (74) functions -> . FUNCTION VOID functionVoid functions
    (75) functions -> . FUNCTION type functionType functions
    (76) functions -> . empty
    (86) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 86 (empty -> .)
    $end            reduce using rule 86 (empty -> .)

    functions                      shift and go to state 36
    empty                          shift and go to state 16

state 31

    (78) functionType -> ID . saveFunction LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY
    (79) saveFunction -> .

    LPAREN          reduce using rule 79 (saveFunction -> .)

    saveFunction                   shift and go to state 37

state 32

    (62) var2 -> var2 type TWOPOINTS . var1 SEMMICOLON
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (86) empty -> .

    ID              shift and go to state 39
    SEMMICOLON      reduce using rule 86 (empty -> .)

    var1                           shift and go to state 38
    empty                          shift and go to state 40

state 33

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)

    statements                     shift and go to state 41
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 34

    (74) functions -> FUNCTION VOID functionVoid functions .

    PRINCIPAL       reduce using rule 74 (functions -> FUNCTION VOID functionVoid functions .)
    $end            reduce using rule 74 (functions -> FUNCTION VOID functionVoid functions .)


state 35

    (77) functionVoid -> ID LPAREN . args RPAREN vars LCURLY statements RCURLY
    (80) args -> . type TWOPOINTS ID MultipleArgs
    (81) args -> . empty
    (69) type -> . INT
    (70) type -> . CHAR
    (71) type -> . FLOAT
    (86) empty -> .

    INT             shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    RPAREN          reduce using rule 86 (empty -> .)

    args                           shift and go to state 58
    type                           shift and go to state 59
    empty                          shift and go to state 60

state 36

    (75) functions -> FUNCTION type functionType functions .

    PRINCIPAL       reduce using rule 75 (functions -> FUNCTION type functionType functions .)
    $end            reduce using rule 75 (functions -> FUNCTION type functionType functions .)


state 37

    (78) functionType -> ID saveFunction . LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY

    LPAREN          shift and go to state 61


state 38

    (62) var2 -> var2 type TWOPOINTS var1 . SEMMICOLON

    SEMMICOLON      shift and go to state 62


state 39

    (64) var1 -> ID .
    (65) var1 -> ID . COMMA var1
    (66) var1 -> ID . arr
    (67) var1 -> ID . arr COMMA var1
    (72) arr -> . LBRACKET CTEI RBRACKET
    (73) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 64 (var1 -> ID .)
    MUL             reduce using rule 64 (var1 -> ID .)
    DIV             reduce using rule 64 (var1 -> ID .)
    PLUS            reduce using rule 64 (var1 -> ID .)
    MINUS           reduce using rule 64 (var1 -> ID .)
    GT              reduce using rule 64 (var1 -> ID .)
    LT              reduce using rule 64 (var1 -> ID .)
    GTE             reduce using rule 64 (var1 -> ID .)
    LTE             reduce using rule 64 (var1 -> ID .)
    NE              reduce using rule 64 (var1 -> ID .)
    AND             reduce using rule 64 (var1 -> ID .)
    OR              reduce using rule 64 (var1 -> ID .)
    RBRACKET        reduce using rule 64 (var1 -> ID .)
    TO              reduce using rule 64 (var1 -> ID .)
    RPAREN          reduce using rule 64 (var1 -> ID .)
    CTEI            reduce using rule 64 (var1 -> ID .)
    CTEF            reduce using rule 64 (var1 -> ID .)
    LPAREN          reduce using rule 64 (var1 -> ID .)
    ID              reduce using rule 64 (var1 -> ID .)
    COMMA           shift and go to state 63
    LBRACKET        shift and go to state 65

  ! COMMA           [ reduce using rule 64 (var1 -> ID .) ]

    arr                            shift and go to state 64

state 40

    (68) var1 -> empty .

    SEMMICOLON      reduce using rule 68 (var1 -> empty .)
    MUL             reduce using rule 68 (var1 -> empty .)
    DIV             reduce using rule 68 (var1 -> empty .)
    PLUS            reduce using rule 68 (var1 -> empty .)
    MINUS           reduce using rule 68 (var1 -> empty .)
    GT              reduce using rule 68 (var1 -> empty .)
    LT              reduce using rule 68 (var1 -> empty .)
    GTE             reduce using rule 68 (var1 -> empty .)
    LTE             reduce using rule 68 (var1 -> empty .)
    NE              reduce using rule 68 (var1 -> empty .)
    AND             reduce using rule 68 (var1 -> empty .)
    OR              reduce using rule 68 (var1 -> empty .)
    RBRACKET        reduce using rule 68 (var1 -> empty .)
    TO              reduce using rule 68 (var1 -> empty .)
    RPAREN          reduce using rule 68 (var1 -> empty .)
    COMMA           reduce using rule 68 (var1 -> empty .)
    CTEI            reduce using rule 68 (var1 -> empty .)
    CTEF            reduce using rule 68 (var1 -> empty .)
    LPAREN          reduce using rule 68 (var1 -> empty .)
    ID              reduce using rule 68 (var1 -> empty .)


state 41

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY statements . RCURLY

    RCURLY          shift and go to state 66


state 42

    (8) statements -> assign . SEMMICOLON statements

    SEMMICOLON      shift and go to state 67


state 43

    (9) statements -> functionCall . SEMMICOLON statements

    SEMMICOLON      shift and go to state 68


state 44

    (10) statements -> read . statements SEMMICOLON statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    SEMMICOLON      reduce using rule 86 (empty -> .)

    read                           shift and go to state 44
    statements                     shift and go to state 69
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 45

    (11) statements -> write . statements SEMMICOLON statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    SEMMICOLON      reduce using rule 86 (empty -> .)

    write                          shift and go to state 45
    statements                     shift and go to state 70
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 46

    (12) statements -> for . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)

  ! RETURN          [ reduce using rule 86 (empty -> .) ]

    for                            shift and go to state 46
    statements                     shift and go to state 71
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 47

    (13) statements -> while . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)

  ! RETURN          [ reduce using rule 86 (empty -> .) ]

    while                          shift and go to state 47
    statements                     shift and go to state 72
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 48

    (14) statements -> if . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)

  ! RETURN          [ reduce using rule 86 (empty -> .) ]

    if                             shift and go to state 48
    statements                     shift and go to state 73
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 49

    (15) statements -> return . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)

  ! RETURN          [ reduce using rule 86 (empty -> .) ]

    return                         shift and go to state 49
    statements                     shift and go to state 74
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    empty                          shift and go to state 50

state 50

    (16) statements -> empty .

    RCURLY          reduce using rule 16 (statements -> empty .)
    SEMMICOLON      reduce using rule 16 (statements -> empty .)
    RETURN          reduce using rule 16 (statements -> empty .)


state 51

    (17) assign -> ID . EQUALS exp
    (18) assign -> ID . LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> ID . LPAREN exp RPAREN

    EQUALS          shift and go to state 75
    LBRACKET        shift and go to state 76
    LPAREN          shift and go to state 77


state 52

    (20) read -> READ . LPAREN read1 RPAREN

    LPAREN          shift and go to state 78


state 53

    (25) write -> WRITE . LPAREN write1 RPAREN

    LPAREN          shift and go to state 79


state 54

    (32) for -> FOR . assign TO CTEI DO LCURLY statements RCURLY
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp

    ID              shift and go to state 81

    assign                         shift and go to state 80

state 55

    (33) while -> WHILE . LPAREN exp RPAREN DO LCURLY statements RCURLY

    LPAREN          shift and go to state 82


state 56

    (34) if -> IF . LPAREN exp RPAREN THEN LCURLY statements RCURLY else

    LPAREN          shift and go to state 83


state 57

    (84) return -> RETURN . LPAREN exp RPAREN SEMMICOLON
    (85) return -> RETURN . LPAREN exp RPAREN

    LPAREN          shift and go to state 84


state 58

    (77) functionVoid -> ID LPAREN args . RPAREN vars LCURLY statements RCURLY

    RPAREN          shift and go to state 85


state 59

    (80) args -> type . TWOPOINTS ID MultipleArgs

    TWOPOINTS       shift and go to state 86


state 60

    (81) args -> empty .

    RPAREN          reduce using rule 81 (args -> empty .)


state 61

    (78) functionType -> ID saveFunction LPAREN . args RPAREN vars LCURLY statements return SEMMICOLON RCURLY
    (80) args -> . type TWOPOINTS ID MultipleArgs
    (81) args -> . empty
    (69) type -> . INT
    (70) type -> . CHAR
    (71) type -> . FLOAT
    (86) empty -> .

    INT             shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    RPAREN          reduce using rule 86 (empty -> .)

    args                           shift and go to state 87
    type                           shift and go to state 59
    empty                          shift and go to state 60

state 62

    (62) var2 -> var2 type TWOPOINTS var1 SEMMICOLON .

    INT             reduce using rule 62 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    CHAR            reduce using rule 62 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    FLOAT           reduce using rule 62 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    FUNCTION        reduce using rule 62 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    PRINCIPAL       reduce using rule 62 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    $end            reduce using rule 62 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)
    LCURLY          reduce using rule 62 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON .)


state 63

    (65) var1 -> ID COMMA . var1
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (86) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 39
    SEMMICOLON      reduce using rule 86 (empty -> .)
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)
    CTEI            reduce using rule 86 (empty -> .)
    CTEF            reduce using rule 86 (empty -> .)
    LPAREN          reduce using rule 86 (empty -> .)

  ! ID              [ reduce using rule 86 (empty -> .) ]

    var1                           shift and go to state 88
    empty                          shift and go to state 40

state 64

    (66) var1 -> ID arr .
    (67) var1 -> ID arr . COMMA var1

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 66 (var1 -> ID arr .)
    MUL             reduce using rule 66 (var1 -> ID arr .)
    DIV             reduce using rule 66 (var1 -> ID arr .)
    PLUS            reduce using rule 66 (var1 -> ID arr .)
    MINUS           reduce using rule 66 (var1 -> ID arr .)
    GT              reduce using rule 66 (var1 -> ID arr .)
    LT              reduce using rule 66 (var1 -> ID arr .)
    GTE             reduce using rule 66 (var1 -> ID arr .)
    LTE             reduce using rule 66 (var1 -> ID arr .)
    NE              reduce using rule 66 (var1 -> ID arr .)
    AND             reduce using rule 66 (var1 -> ID arr .)
    OR              reduce using rule 66 (var1 -> ID arr .)
    RBRACKET        reduce using rule 66 (var1 -> ID arr .)
    TO              reduce using rule 66 (var1 -> ID arr .)
    RPAREN          reduce using rule 66 (var1 -> ID arr .)
    CTEI            reduce using rule 66 (var1 -> ID arr .)
    CTEF            reduce using rule 66 (var1 -> ID arr .)
    LPAREN          reduce using rule 66 (var1 -> ID arr .)
    ID              reduce using rule 66 (var1 -> ID arr .)
    COMMA           shift and go to state 89

  ! COMMA           [ reduce using rule 66 (var1 -> ID arr .) ]


state 65

    (72) arr -> LBRACKET . CTEI RBRACKET
    (73) arr -> LBRACKET . exp RBRACKET
    (37) exp -> . nexp
    (38) exp -> . nexp OR nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 90
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)

    exp                            shift and go to state 91
    nexp                           shift and go to state 92
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 66

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY statements RCURLY .

    $end            reduce using rule 7 (principal -> PRINCIPAL LPAREN RPAREN LCURLY statements RCURLY .)


state 67

    (8) statements -> assign SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)

  ! RETURN          [ reduce using rule 86 (empty -> .) ]

    assign                         shift and go to state 42
    statements                     shift and go to state 103
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 68

    (9) statements -> functionCall SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)

  ! RETURN          [ reduce using rule 86 (empty -> .) ]

    functionCall                   shift and go to state 43
    statements                     shift and go to state 104
    assign                         shift and go to state 42
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 69

    (10) statements -> read statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 105


state 70

    (11) statements -> write statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 106


state 71

    (12) statements -> for statements .

    RCURLY          reduce using rule 12 (statements -> for statements .)
    SEMMICOLON      reduce using rule 12 (statements -> for statements .)
    RETURN          reduce using rule 12 (statements -> for statements .)


state 72

    (13) statements -> while statements .

    RCURLY          reduce using rule 13 (statements -> while statements .)
    SEMMICOLON      reduce using rule 13 (statements -> while statements .)
    RETURN          reduce using rule 13 (statements -> while statements .)


state 73

    (14) statements -> if statements .

    RCURLY          reduce using rule 14 (statements -> if statements .)
    SEMMICOLON      reduce using rule 14 (statements -> if statements .)
    RETURN          reduce using rule 14 (statements -> if statements .)


state 74

    (15) statements -> return statements .

    RCURLY          reduce using rule 15 (statements -> return statements .)
    SEMMICOLON      reduce using rule 15 (statements -> return statements .)
    RETURN          reduce using rule 15 (statements -> return statements .)


state 75

    (17) assign -> ID EQUALS . exp
    (37) exp -> . nexp
    (38) exp -> . nexp OR nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)

    exp                            shift and go to state 107
    nexp                           shift and go to state 92
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 76

    (18) assign -> ID LBRACKET . exp RBRACKET EQUALS exp
    (37) exp -> . nexp
    (38) exp -> . nexp OR nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)

    exp                            shift and go to state 109
    nexp                           shift and go to state 92
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 77

    (19) functionCall -> ID LPAREN . exp RPAREN
    (37) exp -> . nexp
    (38) exp -> . nexp OR nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)

    exp                            shift and go to state 110
    nexp                           shift and go to state 92
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 78

    (20) read -> READ LPAREN . read1 RPAREN
    (21) read1 -> . ID read2

    ID              shift and go to state 112

    read1                          shift and go to state 111

state 79

    (25) write -> WRITE LPAREN . write1 RPAREN
    (26) write1 -> . write2 COMMA write2
    (27) write1 -> . write2
    (28) write2 -> . CTESTRING
    (29) write2 -> . CTEI
    (30) write2 -> . CTEF
    (31) write2 -> . exp
    (37) exp -> . nexp
    (38) exp -> . nexp OR nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTESTRING       shift and go to state 115
    CTEI            shift and go to state 116
    CTEF            shift and go to state 117
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)

    write1                         shift and go to state 113
    write2                         shift and go to state 114
    exp                            shift and go to state 118
    nexp                           shift and go to state 92
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 80

    (32) for -> FOR assign . TO CTEI DO LCURLY statements RCURLY

    TO              shift and go to state 119


state 81

    (17) assign -> ID . EQUALS exp
    (18) assign -> ID . LBRACKET exp RBRACKET EQUALS exp

    EQUALS          shift and go to state 75
    LBRACKET        shift and go to state 76


state 82

    (33) while -> WHILE LPAREN . exp RPAREN DO LCURLY statements RCURLY
    (37) exp -> . nexp
    (38) exp -> . nexp OR nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)

    exp                            shift and go to state 120
    nexp                           shift and go to state 92
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 83

    (34) if -> IF LPAREN . exp RPAREN THEN LCURLY statements RCURLY else
    (37) exp -> . nexp
    (38) exp -> . nexp OR nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)

    exp                            shift and go to state 121
    nexp                           shift and go to state 92
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 84

    (84) return -> RETURN LPAREN . exp RPAREN SEMMICOLON
    (85) return -> RETURN LPAREN . exp RPAREN
    (37) exp -> . nexp
    (38) exp -> . nexp OR nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)

    exp                            shift and go to state 122
    nexp                           shift and go to state 92
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 85

    (77) functionVoid -> ID LPAREN args RPAREN . vars LCURLY statements RCURLY
    (59) vars -> . var
    (60) vars -> . empty
    (61) var -> . VARS var2
    (86) empty -> .

    VARS            shift and go to state 12
    LCURLY          reduce using rule 86 (empty -> .)

    vars                           shift and go to state 123
    var                            shift and go to state 10
    empty                          shift and go to state 11

state 86

    (80) args -> type TWOPOINTS . ID MultipleArgs

    ID              shift and go to state 124


state 87

    (78) functionType -> ID saveFunction LPAREN args . RPAREN vars LCURLY statements return SEMMICOLON RCURLY

    RPAREN          shift and go to state 125


state 88

    (65) var1 -> ID COMMA var1 .

    SEMMICOLON      reduce using rule 65 (var1 -> ID COMMA var1 .)
    MUL             reduce using rule 65 (var1 -> ID COMMA var1 .)
    DIV             reduce using rule 65 (var1 -> ID COMMA var1 .)
    PLUS            reduce using rule 65 (var1 -> ID COMMA var1 .)
    MINUS           reduce using rule 65 (var1 -> ID COMMA var1 .)
    GT              reduce using rule 65 (var1 -> ID COMMA var1 .)
    LT              reduce using rule 65 (var1 -> ID COMMA var1 .)
    GTE             reduce using rule 65 (var1 -> ID COMMA var1 .)
    LTE             reduce using rule 65 (var1 -> ID COMMA var1 .)
    NE              reduce using rule 65 (var1 -> ID COMMA var1 .)
    AND             reduce using rule 65 (var1 -> ID COMMA var1 .)
    OR              reduce using rule 65 (var1 -> ID COMMA var1 .)
    RBRACKET        reduce using rule 65 (var1 -> ID COMMA var1 .)
    TO              reduce using rule 65 (var1 -> ID COMMA var1 .)
    RPAREN          reduce using rule 65 (var1 -> ID COMMA var1 .)
    COMMA           reduce using rule 65 (var1 -> ID COMMA var1 .)
    CTEI            reduce using rule 65 (var1 -> ID COMMA var1 .)
    CTEF            reduce using rule 65 (var1 -> ID COMMA var1 .)
    LPAREN          reduce using rule 65 (var1 -> ID COMMA var1 .)
    ID              reduce using rule 65 (var1 -> ID COMMA var1 .)


state 89

    (67) var1 -> ID arr COMMA . var1
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (86) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 39
    SEMMICOLON      reduce using rule 86 (empty -> .)
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)
    CTEI            reduce using rule 86 (empty -> .)
    CTEF            reduce using rule 86 (empty -> .)
    LPAREN          reduce using rule 86 (empty -> .)

  ! ID              [ reduce using rule 86 (empty -> .) ]

    var1                           shift and go to state 126
    empty                          shift and go to state 40

state 90

    (72) arr -> LBRACKET CTEI . RBRACKET
    (55) pexp -> CTEI .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 127
    MUL             reduce using rule 55 (pexp -> CTEI .)
    DIV             reduce using rule 55 (pexp -> CTEI .)
    PLUS            reduce using rule 55 (pexp -> CTEI .)
    MINUS           reduce using rule 55 (pexp -> CTEI .)
    GT              reduce using rule 55 (pexp -> CTEI .)
    LT              reduce using rule 55 (pexp -> CTEI .)
    GTE             reduce using rule 55 (pexp -> CTEI .)
    LTE             reduce using rule 55 (pexp -> CTEI .)
    NE              reduce using rule 55 (pexp -> CTEI .)
    AND             reduce using rule 55 (pexp -> CTEI .)
    OR              reduce using rule 55 (pexp -> CTEI .)

  ! RBRACKET        [ reduce using rule 55 (pexp -> CTEI .) ]


state 91

    (73) arr -> LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 128


state 92

    (37) exp -> nexp .
    (38) exp -> nexp . OR nexp

    RBRACKET        reduce using rule 37 (exp -> nexp .)
    SEMMICOLON      reduce using rule 37 (exp -> nexp .)
    TO              reduce using rule 37 (exp -> nexp .)
    RPAREN          reduce using rule 37 (exp -> nexp .)
    COMMA           reduce using rule 37 (exp -> nexp .)
    OR              shift and go to state 129


state 93

    (39) nexp -> compexp .
    (40) nexp -> compexp . AND compexp

    OR              reduce using rule 39 (nexp -> compexp .)
    RBRACKET        reduce using rule 39 (nexp -> compexp .)
    SEMMICOLON      reduce using rule 39 (nexp -> compexp .)
    TO              reduce using rule 39 (nexp -> compexp .)
    RPAREN          reduce using rule 39 (nexp -> compexp .)
    COMMA           reduce using rule 39 (nexp -> compexp .)
    AND             shift and go to state 130


state 94

    (41) compexp -> sumexp .
    (43) compexp1 -> sumexp . GT sumexp
    (44) compexp1 -> sumexp . LT sumexp
    (45) compexp1 -> sumexp . GTE sumexp
    (46) compexp1 -> sumexp . LTE sumexp
    (47) compexp1 -> sumexp . NE sumexp

    AND             reduce using rule 41 (compexp -> sumexp .)
    OR              reduce using rule 41 (compexp -> sumexp .)
    RBRACKET        reduce using rule 41 (compexp -> sumexp .)
    SEMMICOLON      reduce using rule 41 (compexp -> sumexp .)
    TO              reduce using rule 41 (compexp -> sumexp .)
    RPAREN          reduce using rule 41 (compexp -> sumexp .)
    COMMA           reduce using rule 41 (compexp -> sumexp .)
    GT              shift and go to state 131
    LT              shift and go to state 132
    GTE             shift and go to state 133
    LTE             shift and go to state 134
    NE              shift and go to state 135


state 95

    (42) compexp -> compexp1 . sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)

    sumexp                         shift and go to state 136
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 96

    (48) sumexp -> mulexp .
    (49) sumexp -> mulexp . PLUS mulexp
    (50) sumexp -> mulexp . MINUS mulexp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    GT              reduce using rule 48 (sumexp -> mulexp .)
    LT              reduce using rule 48 (sumexp -> mulexp .)
    GTE             reduce using rule 48 (sumexp -> mulexp .)
    LTE             reduce using rule 48 (sumexp -> mulexp .)
    NE              reduce using rule 48 (sumexp -> mulexp .)
    AND             reduce using rule 48 (sumexp -> mulexp .)
    OR              reduce using rule 48 (sumexp -> mulexp .)
    RBRACKET        reduce using rule 48 (sumexp -> mulexp .)
    SEMMICOLON      reduce using rule 48 (sumexp -> mulexp .)
    TO              reduce using rule 48 (sumexp -> mulexp .)
    RPAREN          reduce using rule 48 (sumexp -> mulexp .)
    COMMA           reduce using rule 48 (sumexp -> mulexp .)
    CTEI            reduce using rule 48 (sumexp -> mulexp .)
    CTEF            reduce using rule 48 (sumexp -> mulexp .)
    LPAREN          reduce using rule 48 (sumexp -> mulexp .)
    ID              reduce using rule 48 (sumexp -> mulexp .)
    MUL             reduce using rule 48 (sumexp -> mulexp .)
    DIV             reduce using rule 48 (sumexp -> mulexp .)
    PLUS            shift and go to state 137
    MINUS           shift and go to state 138

  ! PLUS            [ reduce using rule 48 (sumexp -> mulexp .) ]
  ! MINUS           [ reduce using rule 48 (sumexp -> mulexp .) ]


state 97

    (51) mulexp -> pexp .
    (52) mulexp -> pexp . MUL pexp
    (53) mulexp -> pexp . DIV pexp

  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    PLUS            reduce using rule 51 (mulexp -> pexp .)
    MINUS           reduce using rule 51 (mulexp -> pexp .)
    GT              reduce using rule 51 (mulexp -> pexp .)
    LT              reduce using rule 51 (mulexp -> pexp .)
    GTE             reduce using rule 51 (mulexp -> pexp .)
    LTE             reduce using rule 51 (mulexp -> pexp .)
    NE              reduce using rule 51 (mulexp -> pexp .)
    AND             reduce using rule 51 (mulexp -> pexp .)
    OR              reduce using rule 51 (mulexp -> pexp .)
    RBRACKET        reduce using rule 51 (mulexp -> pexp .)
    SEMMICOLON      reduce using rule 51 (mulexp -> pexp .)
    TO              reduce using rule 51 (mulexp -> pexp .)
    RPAREN          reduce using rule 51 (mulexp -> pexp .)
    COMMA           reduce using rule 51 (mulexp -> pexp .)
    CTEI            reduce using rule 51 (mulexp -> pexp .)
    CTEF            reduce using rule 51 (mulexp -> pexp .)
    LPAREN          reduce using rule 51 (mulexp -> pexp .)
    ID              reduce using rule 51 (mulexp -> pexp .)
    MUL             shift and go to state 139
    DIV             shift and go to state 140

  ! MUL             [ reduce using rule 51 (mulexp -> pexp .) ]
  ! DIV             [ reduce using rule 51 (mulexp -> pexp .) ]


state 98

    (54) pexp -> var1 .

    MUL             reduce using rule 54 (pexp -> var1 .)
    DIV             reduce using rule 54 (pexp -> var1 .)
    PLUS            reduce using rule 54 (pexp -> var1 .)
    MINUS           reduce using rule 54 (pexp -> var1 .)
    GT              reduce using rule 54 (pexp -> var1 .)
    LT              reduce using rule 54 (pexp -> var1 .)
    GTE             reduce using rule 54 (pexp -> var1 .)
    LTE             reduce using rule 54 (pexp -> var1 .)
    NE              reduce using rule 54 (pexp -> var1 .)
    AND             reduce using rule 54 (pexp -> var1 .)
    OR              reduce using rule 54 (pexp -> var1 .)
    RBRACKET        reduce using rule 54 (pexp -> var1 .)
    SEMMICOLON      reduce using rule 54 (pexp -> var1 .)
    TO              reduce using rule 54 (pexp -> var1 .)
    RPAREN          reduce using rule 54 (pexp -> var1 .)
    COMMA           reduce using rule 54 (pexp -> var1 .)
    CTEI            reduce using rule 54 (pexp -> var1 .)
    CTEF            reduce using rule 54 (pexp -> var1 .)
    LPAREN          reduce using rule 54 (pexp -> var1 .)
    ID              reduce using rule 54 (pexp -> var1 .)


state 99

    (56) pexp -> CTEF .

    MUL             reduce using rule 56 (pexp -> CTEF .)
    DIV             reduce using rule 56 (pexp -> CTEF .)
    PLUS            reduce using rule 56 (pexp -> CTEF .)
    MINUS           reduce using rule 56 (pexp -> CTEF .)
    GT              reduce using rule 56 (pexp -> CTEF .)
    LT              reduce using rule 56 (pexp -> CTEF .)
    GTE             reduce using rule 56 (pexp -> CTEF .)
    LTE             reduce using rule 56 (pexp -> CTEF .)
    NE              reduce using rule 56 (pexp -> CTEF .)
    AND             reduce using rule 56 (pexp -> CTEF .)
    OR              reduce using rule 56 (pexp -> CTEF .)
    RBRACKET        reduce using rule 56 (pexp -> CTEF .)
    SEMMICOLON      reduce using rule 56 (pexp -> CTEF .)
    TO              reduce using rule 56 (pexp -> CTEF .)
    RPAREN          reduce using rule 56 (pexp -> CTEF .)
    COMMA           reduce using rule 56 (pexp -> CTEF .)
    CTEI            reduce using rule 56 (pexp -> CTEF .)
    CTEF            reduce using rule 56 (pexp -> CTEF .)
    LPAREN          reduce using rule 56 (pexp -> CTEF .)
    ID              reduce using rule 56 (pexp -> CTEF .)


state 100

    (57) pexp -> functionCall .

    MUL             reduce using rule 57 (pexp -> functionCall .)
    DIV             reduce using rule 57 (pexp -> functionCall .)
    PLUS            reduce using rule 57 (pexp -> functionCall .)
    MINUS           reduce using rule 57 (pexp -> functionCall .)
    GT              reduce using rule 57 (pexp -> functionCall .)
    LT              reduce using rule 57 (pexp -> functionCall .)
    GTE             reduce using rule 57 (pexp -> functionCall .)
    LTE             reduce using rule 57 (pexp -> functionCall .)
    NE              reduce using rule 57 (pexp -> functionCall .)
    AND             reduce using rule 57 (pexp -> functionCall .)
    OR              reduce using rule 57 (pexp -> functionCall .)
    RBRACKET        reduce using rule 57 (pexp -> functionCall .)
    SEMMICOLON      reduce using rule 57 (pexp -> functionCall .)
    TO              reduce using rule 57 (pexp -> functionCall .)
    RPAREN          reduce using rule 57 (pexp -> functionCall .)
    COMMA           reduce using rule 57 (pexp -> functionCall .)
    CTEI            reduce using rule 57 (pexp -> functionCall .)
    CTEF            reduce using rule 57 (pexp -> functionCall .)
    LPAREN          reduce using rule 57 (pexp -> functionCall .)
    ID              reduce using rule 57 (pexp -> functionCall .)


state 101

    (58) pexp -> LPAREN . exp RPAREN
    (37) exp -> . nexp
    (38) exp -> . nexp OR nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)

    exp                            shift and go to state 141
    nexp                           shift and go to state 92
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 102

    (64) var1 -> ID .
    (65) var1 -> ID . COMMA var1
    (66) var1 -> ID . arr
    (67) var1 -> ID . arr COMMA var1
    (19) functionCall -> ID . LPAREN exp RPAREN
    (72) arr -> . LBRACKET CTEI RBRACKET
    (73) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    MUL             reduce using rule 64 (var1 -> ID .)
    DIV             reduce using rule 64 (var1 -> ID .)
    PLUS            reduce using rule 64 (var1 -> ID .)
    MINUS           reduce using rule 64 (var1 -> ID .)
    GT              reduce using rule 64 (var1 -> ID .)
    LT              reduce using rule 64 (var1 -> ID .)
    GTE             reduce using rule 64 (var1 -> ID .)
    LTE             reduce using rule 64 (var1 -> ID .)
    NE              reduce using rule 64 (var1 -> ID .)
    AND             reduce using rule 64 (var1 -> ID .)
    OR              reduce using rule 64 (var1 -> ID .)
    RBRACKET        reduce using rule 64 (var1 -> ID .)
    SEMMICOLON      reduce using rule 64 (var1 -> ID .)
    TO              reduce using rule 64 (var1 -> ID .)
    RPAREN          reduce using rule 64 (var1 -> ID .)
    CTEI            reduce using rule 64 (var1 -> ID .)
    CTEF            reduce using rule 64 (var1 -> ID .)
    ID              reduce using rule 64 (var1 -> ID .)
    COMMA           shift and go to state 63
    LPAREN          shift and go to state 77
    LBRACKET        shift and go to state 65

  ! COMMA           [ reduce using rule 64 (var1 -> ID .) ]
  ! LPAREN          [ reduce using rule 64 (var1 -> ID .) ]

    arr                            shift and go to state 64

state 103

    (8) statements -> assign SEMMICOLON statements .

    RCURLY          reduce using rule 8 (statements -> assign SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 8 (statements -> assign SEMMICOLON statements .)
    RETURN          reduce using rule 8 (statements -> assign SEMMICOLON statements .)


state 104

    (9) statements -> functionCall SEMMICOLON statements .

    RCURLY          reduce using rule 9 (statements -> functionCall SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 9 (statements -> functionCall SEMMICOLON statements .)
    RETURN          reduce using rule 9 (statements -> functionCall SEMMICOLON statements .)


state 105

    (10) statements -> read statements SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)

  ! RETURN          [ reduce using rule 86 (empty -> .) ]

    read                           shift and go to state 44
    statements                     shift and go to state 142
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 106

    (11) statements -> write statements SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)

  ! RETURN          [ reduce using rule 86 (empty -> .) ]

    write                          shift and go to state 45
    statements                     shift and go to state 143
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 107

    (17) assign -> ID EQUALS exp .

    SEMMICOLON      reduce using rule 17 (assign -> ID EQUALS exp .)
    TO              reduce using rule 17 (assign -> ID EQUALS exp .)


state 108

    (55) pexp -> CTEI .

    MUL             reduce using rule 55 (pexp -> CTEI .)
    DIV             reduce using rule 55 (pexp -> CTEI .)
    PLUS            reduce using rule 55 (pexp -> CTEI .)
    MINUS           reduce using rule 55 (pexp -> CTEI .)
    GT              reduce using rule 55 (pexp -> CTEI .)
    LT              reduce using rule 55 (pexp -> CTEI .)
    GTE             reduce using rule 55 (pexp -> CTEI .)
    LTE             reduce using rule 55 (pexp -> CTEI .)
    NE              reduce using rule 55 (pexp -> CTEI .)
    AND             reduce using rule 55 (pexp -> CTEI .)
    OR              reduce using rule 55 (pexp -> CTEI .)
    SEMMICOLON      reduce using rule 55 (pexp -> CTEI .)
    TO              reduce using rule 55 (pexp -> CTEI .)
    RBRACKET        reduce using rule 55 (pexp -> CTEI .)
    RPAREN          reduce using rule 55 (pexp -> CTEI .)
    COMMA           reduce using rule 55 (pexp -> CTEI .)
    CTEI            reduce using rule 55 (pexp -> CTEI .)
    CTEF            reduce using rule 55 (pexp -> CTEI .)
    LPAREN          reduce using rule 55 (pexp -> CTEI .)
    ID              reduce using rule 55 (pexp -> CTEI .)


state 109

    (18) assign -> ID LBRACKET exp . RBRACKET EQUALS exp

    RBRACKET        shift and go to state 144


state 110

    (19) functionCall -> ID LPAREN exp . RPAREN

    RPAREN          shift and go to state 145


state 111

    (20) read -> READ LPAREN read1 . RPAREN

    RPAREN          shift and go to state 146


state 112

    (21) read1 -> ID . read2
    (22) read2 -> . COMMA read1
    (23) read2 -> . empty
    (86) empty -> .

    COMMA           shift and go to state 148
    RPAREN          reduce using rule 86 (empty -> .)

    read2                          shift and go to state 147
    empty                          shift and go to state 149

state 113

    (25) write -> WRITE LPAREN write1 . RPAREN

    RPAREN          shift and go to state 150


state 114

    (26) write1 -> write2 . COMMA write2
    (27) write1 -> write2 .

    COMMA           shift and go to state 151
    RPAREN          reduce using rule 27 (write1 -> write2 .)


state 115

    (28) write2 -> CTESTRING .

    COMMA           reduce using rule 28 (write2 -> CTESTRING .)
    RPAREN          reduce using rule 28 (write2 -> CTESTRING .)


state 116

    (29) write2 -> CTEI .
    (55) pexp -> CTEI .

  ! reduce/reduce conflict for COMMA resolved using rule 29 (write2 -> CTEI .)
  ! reduce/reduce conflict for RPAREN resolved using rule 29 (write2 -> CTEI .)
    COMMA           reduce using rule 29 (write2 -> CTEI .)
    RPAREN          reduce using rule 29 (write2 -> CTEI .)
    MUL             reduce using rule 55 (pexp -> CTEI .)
    DIV             reduce using rule 55 (pexp -> CTEI .)
    PLUS            reduce using rule 55 (pexp -> CTEI .)
    MINUS           reduce using rule 55 (pexp -> CTEI .)
    GT              reduce using rule 55 (pexp -> CTEI .)
    LT              reduce using rule 55 (pexp -> CTEI .)
    GTE             reduce using rule 55 (pexp -> CTEI .)
    LTE             reduce using rule 55 (pexp -> CTEI .)
    NE              reduce using rule 55 (pexp -> CTEI .)
    AND             reduce using rule 55 (pexp -> CTEI .)
    OR              reduce using rule 55 (pexp -> CTEI .)

  ! COMMA           [ reduce using rule 55 (pexp -> CTEI .) ]
  ! RPAREN          [ reduce using rule 55 (pexp -> CTEI .) ]


state 117

    (30) write2 -> CTEF .
    (56) pexp -> CTEF .

  ! reduce/reduce conflict for COMMA resolved using rule 30 (write2 -> CTEF .)
  ! reduce/reduce conflict for RPAREN resolved using rule 30 (write2 -> CTEF .)
    COMMA           reduce using rule 30 (write2 -> CTEF .)
    RPAREN          reduce using rule 30 (write2 -> CTEF .)
    MUL             reduce using rule 56 (pexp -> CTEF .)
    DIV             reduce using rule 56 (pexp -> CTEF .)
    PLUS            reduce using rule 56 (pexp -> CTEF .)
    MINUS           reduce using rule 56 (pexp -> CTEF .)
    GT              reduce using rule 56 (pexp -> CTEF .)
    LT              reduce using rule 56 (pexp -> CTEF .)
    GTE             reduce using rule 56 (pexp -> CTEF .)
    LTE             reduce using rule 56 (pexp -> CTEF .)
    NE              reduce using rule 56 (pexp -> CTEF .)
    AND             reduce using rule 56 (pexp -> CTEF .)
    OR              reduce using rule 56 (pexp -> CTEF .)

  ! COMMA           [ reduce using rule 56 (pexp -> CTEF .) ]
  ! RPAREN          [ reduce using rule 56 (pexp -> CTEF .) ]


state 118

    (31) write2 -> exp .

    COMMA           reduce using rule 31 (write2 -> exp .)
    RPAREN          reduce using rule 31 (write2 -> exp .)


state 119

    (32) for -> FOR assign TO . CTEI DO LCURLY statements RCURLY

    CTEI            shift and go to state 152


state 120

    (33) while -> WHILE LPAREN exp . RPAREN DO LCURLY statements RCURLY

    RPAREN          shift and go to state 153


state 121

    (34) if -> IF LPAREN exp . RPAREN THEN LCURLY statements RCURLY else

    RPAREN          shift and go to state 154


state 122

    (84) return -> RETURN LPAREN exp . RPAREN SEMMICOLON
    (85) return -> RETURN LPAREN exp . RPAREN

    RPAREN          shift and go to state 155


state 123

    (77) functionVoid -> ID LPAREN args RPAREN vars . LCURLY statements RCURLY

    LCURLY          shift and go to state 156


state 124

    (80) args -> type TWOPOINTS ID . MultipleArgs
    (82) MultipleArgs -> . COMMA args
    (83) MultipleArgs -> . empty
    (86) empty -> .

    COMMA           shift and go to state 158
    RPAREN          reduce using rule 86 (empty -> .)

    MultipleArgs                   shift and go to state 157
    empty                          shift and go to state 159

state 125

    (78) functionType -> ID saveFunction LPAREN args RPAREN . vars LCURLY statements return SEMMICOLON RCURLY
    (59) vars -> . var
    (60) vars -> . empty
    (61) var -> . VARS var2
    (86) empty -> .

    VARS            shift and go to state 12
    LCURLY          reduce using rule 86 (empty -> .)

    vars                           shift and go to state 160
    var                            shift and go to state 10
    empty                          shift and go to state 11

state 126

    (67) var1 -> ID arr COMMA var1 .

    SEMMICOLON      reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    MUL             reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    DIV             reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    PLUS            reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    MINUS           reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    GT              reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    LT              reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    GTE             reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    LTE             reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    NE              reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    AND             reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    OR              reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    RBRACKET        reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    TO              reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    RPAREN          reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    COMMA           reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    CTEI            reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    CTEF            reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    LPAREN          reduce using rule 67 (var1 -> ID arr COMMA var1 .)
    ID              reduce using rule 67 (var1 -> ID arr COMMA var1 .)


state 127

    (72) arr -> LBRACKET CTEI RBRACKET .

    COMMA           reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    SEMMICOLON      reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    MUL             reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    DIV             reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    PLUS            reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    MINUS           reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    GT              reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    LT              reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    GTE             reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    LTE             reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    NE              reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    AND             reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    OR              reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    RBRACKET        reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    TO              reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    RPAREN          reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    CTEI            reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    CTEF            reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    LPAREN          reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)
    ID              reduce using rule 72 (arr -> LBRACKET CTEI RBRACKET .)


state 128

    (73) arr -> LBRACKET exp RBRACKET .

    COMMA           reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    SEMMICOLON      reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    MUL             reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    DIV             reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    GT              reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    LT              reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    GTE             reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    LTE             reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    NE              reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    AND             reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    OR              reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    TO              reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    CTEI            reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    CTEF            reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)
    ID              reduce using rule 73 (arr -> LBRACKET exp RBRACKET .)


state 129

    (38) exp -> nexp OR . nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)

    nexp                           shift and go to state 161
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 130

    (40) nexp -> compexp AND . compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)

    compexp                        shift and go to state 162
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 131

    (43) compexp1 -> sumexp GT . sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)

  ! CTEI            [ reduce using rule 86 (empty -> .) ]
  ! CTEF            [ reduce using rule 86 (empty -> .) ]
  ! LPAREN          [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    sumexp                         shift and go to state 163
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 132

    (44) compexp1 -> sumexp LT . sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)

  ! CTEI            [ reduce using rule 86 (empty -> .) ]
  ! CTEF            [ reduce using rule 86 (empty -> .) ]
  ! LPAREN          [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    sumexp                         shift and go to state 164
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 133

    (45) compexp1 -> sumexp GTE . sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)

  ! CTEI            [ reduce using rule 86 (empty -> .) ]
  ! CTEF            [ reduce using rule 86 (empty -> .) ]
  ! LPAREN          [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    sumexp                         shift and go to state 165
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 134

    (46) compexp1 -> sumexp LTE . sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)

  ! CTEI            [ reduce using rule 86 (empty -> .) ]
  ! CTEF            [ reduce using rule 86 (empty -> .) ]
  ! LPAREN          [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    sumexp                         shift and go to state 166
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 135

    (47) compexp1 -> sumexp NE . sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)

  ! CTEI            [ reduce using rule 86 (empty -> .) ]
  ! CTEF            [ reduce using rule 86 (empty -> .) ]
  ! LPAREN          [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    sumexp                         shift and go to state 167
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 136

    (42) compexp -> compexp1 sumexp .

    AND             reduce using rule 42 (compexp -> compexp1 sumexp .)
    OR              reduce using rule 42 (compexp -> compexp1 sumexp .)
    RBRACKET        reduce using rule 42 (compexp -> compexp1 sumexp .)
    SEMMICOLON      reduce using rule 42 (compexp -> compexp1 sumexp .)
    TO              reduce using rule 42 (compexp -> compexp1 sumexp .)
    RPAREN          reduce using rule 42 (compexp -> compexp1 sumexp .)
    COMMA           reduce using rule 42 (compexp -> compexp1 sumexp .)


state 137

    (49) sumexp -> mulexp PLUS . mulexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)

  ! CTEI            [ reduce using rule 86 (empty -> .) ]
  ! CTEF            [ reduce using rule 86 (empty -> .) ]
  ! LPAREN          [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    mulexp                         shift and go to state 168
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 138

    (50) sumexp -> mulexp MINUS . mulexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)

  ! CTEI            [ reduce using rule 86 (empty -> .) ]
  ! CTEF            [ reduce using rule 86 (empty -> .) ]
  ! LPAREN          [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    mulexp                         shift and go to state 169
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 139

    (52) mulexp -> pexp MUL . pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)

  ! CTEI            [ reduce using rule 86 (empty -> .) ]
  ! CTEF            [ reduce using rule 86 (empty -> .) ]
  ! LPAREN          [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    pexp                           shift and go to state 170
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 140

    (53) mulexp -> pexp DIV . pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RBRACKET        reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)
    COMMA           reduce using rule 86 (empty -> .)
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)

  ! CTEI            [ reduce using rule 86 (empty -> .) ]
  ! CTEF            [ reduce using rule 86 (empty -> .) ]
  ! LPAREN          [ reduce using rule 86 (empty -> .) ]
  ! ID              [ reduce using rule 86 (empty -> .) ]

    pexp                           shift and go to state 171
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 141

    (58) pexp -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 172


state 142

    (10) statements -> read statements SEMMICOLON statements .

    RCURLY          reduce using rule 10 (statements -> read statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 10 (statements -> read statements SEMMICOLON statements .)
    RETURN          reduce using rule 10 (statements -> read statements SEMMICOLON statements .)


state 143

    (11) statements -> write statements SEMMICOLON statements .

    RCURLY          reduce using rule 11 (statements -> write statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 11 (statements -> write statements SEMMICOLON statements .)
    RETURN          reduce using rule 11 (statements -> write statements SEMMICOLON statements .)


state 144

    (18) assign -> ID LBRACKET exp RBRACKET . EQUALS exp

    EQUALS          shift and go to state 173


state 145

    (19) functionCall -> ID LPAREN exp RPAREN .

    SEMMICOLON      reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    MUL             reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    DIV             reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    PLUS            reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    MINUS           reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    GT              reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    LT              reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    GTE             reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    LTE             reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    NE              reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    AND             reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    OR              reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    TO              reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    RPAREN          reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    COMMA           reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    CTEI            reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    CTEF            reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    LPAREN          reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)
    ID              reduce using rule 19 (functionCall -> ID LPAREN exp RPAREN .)


state 146

    (20) read -> READ LPAREN read1 RPAREN .

    ID              reduce using rule 20 (read -> READ LPAREN read1 RPAREN .)
    READ            reduce using rule 20 (read -> READ LPAREN read1 RPAREN .)
    WRITE           reduce using rule 20 (read -> READ LPAREN read1 RPAREN .)
    FOR             reduce using rule 20 (read -> READ LPAREN read1 RPAREN .)
    WHILE           reduce using rule 20 (read -> READ LPAREN read1 RPAREN .)
    IF              reduce using rule 20 (read -> READ LPAREN read1 RPAREN .)
    RETURN          reduce using rule 20 (read -> READ LPAREN read1 RPAREN .)
    SEMMICOLON      reduce using rule 20 (read -> READ LPAREN read1 RPAREN .)


state 147

    (21) read1 -> ID read2 .

    RPAREN          reduce using rule 21 (read1 -> ID read2 .)


state 148

    (22) read2 -> COMMA . read1
    (21) read1 -> . ID read2

    ID              shift and go to state 112

    read1                          shift and go to state 174

state 149

    (23) read2 -> empty .

    RPAREN          reduce using rule 23 (read2 -> empty .)


state 150

    (25) write -> WRITE LPAREN write1 RPAREN .

    ID              reduce using rule 25 (write -> WRITE LPAREN write1 RPAREN .)
    READ            reduce using rule 25 (write -> WRITE LPAREN write1 RPAREN .)
    WRITE           reduce using rule 25 (write -> WRITE LPAREN write1 RPAREN .)
    FOR             reduce using rule 25 (write -> WRITE LPAREN write1 RPAREN .)
    WHILE           reduce using rule 25 (write -> WRITE LPAREN write1 RPAREN .)
    IF              reduce using rule 25 (write -> WRITE LPAREN write1 RPAREN .)
    RETURN          reduce using rule 25 (write -> WRITE LPAREN write1 RPAREN .)
    SEMMICOLON      reduce using rule 25 (write -> WRITE LPAREN write1 RPAREN .)


state 151

    (26) write1 -> write2 COMMA . write2
    (28) write2 -> . CTESTRING
    (29) write2 -> . CTEI
    (30) write2 -> . CTEF
    (31) write2 -> . exp
    (37) exp -> . nexp
    (38) exp -> . nexp OR nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTESTRING       shift and go to state 115
    CTEI            shift and go to state 116
    CTEF            shift and go to state 117
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    RPAREN          reduce using rule 86 (empty -> .)

    write2                         shift and go to state 175
    exp                            shift and go to state 118
    nexp                           shift and go to state 92
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 152

    (32) for -> FOR assign TO CTEI . DO LCURLY statements RCURLY

    DO              shift and go to state 176


state 153

    (33) while -> WHILE LPAREN exp RPAREN . DO LCURLY statements RCURLY

    DO              shift and go to state 177


state 154

    (34) if -> IF LPAREN exp RPAREN . THEN LCURLY statements RCURLY else

    THEN            shift and go to state 178


state 155

    (84) return -> RETURN LPAREN exp RPAREN . SEMMICOLON
    (85) return -> RETURN LPAREN exp RPAREN .

  ! shift/reduce conflict for SEMMICOLON resolved as shift
    SEMMICOLON      shift and go to state 179
    ID              reduce using rule 85 (return -> RETURN LPAREN exp RPAREN .)
    READ            reduce using rule 85 (return -> RETURN LPAREN exp RPAREN .)
    WRITE           reduce using rule 85 (return -> RETURN LPAREN exp RPAREN .)
    FOR             reduce using rule 85 (return -> RETURN LPAREN exp RPAREN .)
    WHILE           reduce using rule 85 (return -> RETURN LPAREN exp RPAREN .)
    IF              reduce using rule 85 (return -> RETURN LPAREN exp RPAREN .)
    RETURN          reduce using rule 85 (return -> RETURN LPAREN exp RPAREN .)
    RCURLY          reduce using rule 85 (return -> RETURN LPAREN exp RPAREN .)

  ! SEMMICOLON      [ reduce using rule 85 (return -> RETURN LPAREN exp RPAREN .) ]


state 156

    (77) functionVoid -> ID LPAREN args RPAREN vars LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)

    statements                     shift and go to state 180
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 157

    (80) args -> type TWOPOINTS ID MultipleArgs .

    RPAREN          reduce using rule 80 (args -> type TWOPOINTS ID MultipleArgs .)


state 158

    (82) MultipleArgs -> COMMA . args
    (80) args -> . type TWOPOINTS ID MultipleArgs
    (81) args -> . empty
    (69) type -> . INT
    (70) type -> . CHAR
    (71) type -> . FLOAT
    (86) empty -> .

    INT             shift and go to state 23
    CHAR            shift and go to state 24
    FLOAT           shift and go to state 25
    RPAREN          reduce using rule 86 (empty -> .)

    args                           shift and go to state 181
    type                           shift and go to state 59
    empty                          shift and go to state 60

state 159

    (83) MultipleArgs -> empty .

    RPAREN          reduce using rule 83 (MultipleArgs -> empty .)


state 160

    (78) functionType -> ID saveFunction LPAREN args RPAREN vars . LCURLY statements return SEMMICOLON RCURLY

    LCURLY          shift and go to state 182


state 161

    (38) exp -> nexp OR nexp .

    RBRACKET        reduce using rule 38 (exp -> nexp OR nexp .)
    SEMMICOLON      reduce using rule 38 (exp -> nexp OR nexp .)
    TO              reduce using rule 38 (exp -> nexp OR nexp .)
    RPAREN          reduce using rule 38 (exp -> nexp OR nexp .)
    COMMA           reduce using rule 38 (exp -> nexp OR nexp .)


state 162

    (40) nexp -> compexp AND compexp .

    OR              reduce using rule 40 (nexp -> compexp AND compexp .)
    RBRACKET        reduce using rule 40 (nexp -> compexp AND compexp .)
    SEMMICOLON      reduce using rule 40 (nexp -> compexp AND compexp .)
    TO              reduce using rule 40 (nexp -> compexp AND compexp .)
    RPAREN          reduce using rule 40 (nexp -> compexp AND compexp .)
    COMMA           reduce using rule 40 (nexp -> compexp AND compexp .)


state 163

    (43) compexp1 -> sumexp GT sumexp .

    CTEI            reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    CTEF            reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    LPAREN          reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    ID              reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    PLUS            reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    MINUS           reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    MUL             reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    DIV             reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    AND             reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    OR              reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    RBRACKET        reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    SEMMICOLON      reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    TO              reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    RPAREN          reduce using rule 43 (compexp1 -> sumexp GT sumexp .)
    COMMA           reduce using rule 43 (compexp1 -> sumexp GT sumexp .)


state 164

    (44) compexp1 -> sumexp LT sumexp .

    CTEI            reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    CTEF            reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    LPAREN          reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    ID              reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    PLUS            reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    MINUS           reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    MUL             reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    DIV             reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    AND             reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    OR              reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    RBRACKET        reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    SEMMICOLON      reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    TO              reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    RPAREN          reduce using rule 44 (compexp1 -> sumexp LT sumexp .)
    COMMA           reduce using rule 44 (compexp1 -> sumexp LT sumexp .)


state 165

    (45) compexp1 -> sumexp GTE sumexp .

    CTEI            reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    CTEF            reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    LPAREN          reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    ID              reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    PLUS            reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    MINUS           reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    MUL             reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    DIV             reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    AND             reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    OR              reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    RBRACKET        reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    SEMMICOLON      reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    TO              reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    RPAREN          reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)
    COMMA           reduce using rule 45 (compexp1 -> sumexp GTE sumexp .)


state 166

    (46) compexp1 -> sumexp LTE sumexp .

    CTEI            reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    CTEF            reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    LPAREN          reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    ID              reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    PLUS            reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    MINUS           reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    MUL             reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    DIV             reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    AND             reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    OR              reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    RBRACKET        reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    SEMMICOLON      reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    TO              reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    RPAREN          reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)
    COMMA           reduce using rule 46 (compexp1 -> sumexp LTE sumexp .)


state 167

    (47) compexp1 -> sumexp NE sumexp .

    CTEI            reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    CTEF            reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    LPAREN          reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    ID              reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    PLUS            reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    MINUS           reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    MUL             reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    DIV             reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    AND             reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    OR              reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    RBRACKET        reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    SEMMICOLON      reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    TO              reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    RPAREN          reduce using rule 47 (compexp1 -> sumexp NE sumexp .)
    COMMA           reduce using rule 47 (compexp1 -> sumexp NE sumexp .)


state 168

    (49) sumexp -> mulexp PLUS mulexp .

    GT              reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    LT              reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    GTE             reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    LTE             reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    NE              reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    AND             reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    OR              reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    RBRACKET        reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    SEMMICOLON      reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    TO              reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    RPAREN          reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    COMMA           reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    CTEI            reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    CTEF            reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    LPAREN          reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    ID              reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    PLUS            reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    MINUS           reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    MUL             reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)
    DIV             reduce using rule 49 (sumexp -> mulexp PLUS mulexp .)


state 169

    (50) sumexp -> mulexp MINUS mulexp .

    GT              reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    LT              reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    GTE             reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    LTE             reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    NE              reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    AND             reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    OR              reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    RBRACKET        reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    SEMMICOLON      reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    TO              reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    RPAREN          reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    COMMA           reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    CTEI            reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    CTEF            reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    LPAREN          reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    ID              reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    PLUS            reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    MINUS           reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    MUL             reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)
    DIV             reduce using rule 50 (sumexp -> mulexp MINUS mulexp .)


state 170

    (52) mulexp -> pexp MUL pexp .

    PLUS            reduce using rule 52 (mulexp -> pexp MUL pexp .)
    MINUS           reduce using rule 52 (mulexp -> pexp MUL pexp .)
    GT              reduce using rule 52 (mulexp -> pexp MUL pexp .)
    LT              reduce using rule 52 (mulexp -> pexp MUL pexp .)
    GTE             reduce using rule 52 (mulexp -> pexp MUL pexp .)
    LTE             reduce using rule 52 (mulexp -> pexp MUL pexp .)
    NE              reduce using rule 52 (mulexp -> pexp MUL pexp .)
    AND             reduce using rule 52 (mulexp -> pexp MUL pexp .)
    OR              reduce using rule 52 (mulexp -> pexp MUL pexp .)
    RBRACKET        reduce using rule 52 (mulexp -> pexp MUL pexp .)
    SEMMICOLON      reduce using rule 52 (mulexp -> pexp MUL pexp .)
    TO              reduce using rule 52 (mulexp -> pexp MUL pexp .)
    RPAREN          reduce using rule 52 (mulexp -> pexp MUL pexp .)
    COMMA           reduce using rule 52 (mulexp -> pexp MUL pexp .)
    CTEI            reduce using rule 52 (mulexp -> pexp MUL pexp .)
    CTEF            reduce using rule 52 (mulexp -> pexp MUL pexp .)
    LPAREN          reduce using rule 52 (mulexp -> pexp MUL pexp .)
    ID              reduce using rule 52 (mulexp -> pexp MUL pexp .)
    MUL             reduce using rule 52 (mulexp -> pexp MUL pexp .)
    DIV             reduce using rule 52 (mulexp -> pexp MUL pexp .)


state 171

    (53) mulexp -> pexp DIV pexp .

    PLUS            reduce using rule 53 (mulexp -> pexp DIV pexp .)
    MINUS           reduce using rule 53 (mulexp -> pexp DIV pexp .)
    GT              reduce using rule 53 (mulexp -> pexp DIV pexp .)
    LT              reduce using rule 53 (mulexp -> pexp DIV pexp .)
    GTE             reduce using rule 53 (mulexp -> pexp DIV pexp .)
    LTE             reduce using rule 53 (mulexp -> pexp DIV pexp .)
    NE              reduce using rule 53 (mulexp -> pexp DIV pexp .)
    AND             reduce using rule 53 (mulexp -> pexp DIV pexp .)
    OR              reduce using rule 53 (mulexp -> pexp DIV pexp .)
    RBRACKET        reduce using rule 53 (mulexp -> pexp DIV pexp .)
    SEMMICOLON      reduce using rule 53 (mulexp -> pexp DIV pexp .)
    TO              reduce using rule 53 (mulexp -> pexp DIV pexp .)
    RPAREN          reduce using rule 53 (mulexp -> pexp DIV pexp .)
    COMMA           reduce using rule 53 (mulexp -> pexp DIV pexp .)
    CTEI            reduce using rule 53 (mulexp -> pexp DIV pexp .)
    CTEF            reduce using rule 53 (mulexp -> pexp DIV pexp .)
    LPAREN          reduce using rule 53 (mulexp -> pexp DIV pexp .)
    ID              reduce using rule 53 (mulexp -> pexp DIV pexp .)
    MUL             reduce using rule 53 (mulexp -> pexp DIV pexp .)
    DIV             reduce using rule 53 (mulexp -> pexp DIV pexp .)


state 172

    (58) pexp -> LPAREN exp RPAREN .

    MUL             reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    DIV             reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    AND             reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    OR              reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    SEMMICOLON      reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    TO              reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    CTEI            reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    CTEF            reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 58 (pexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 58 (pexp -> LPAREN exp RPAREN .)


state 173

    (18) assign -> ID LBRACKET exp RBRACKET EQUALS . exp
    (37) exp -> . nexp
    (38) exp -> . nexp OR nexp
    (39) nexp -> . compexp
    (40) nexp -> . compexp AND compexp
    (41) compexp -> . sumexp
    (42) compexp -> . compexp1 sumexp
    (48) sumexp -> . mulexp
    (49) sumexp -> . mulexp PLUS mulexp
    (50) sumexp -> . mulexp MINUS mulexp
    (43) compexp1 -> . sumexp GT sumexp
    (44) compexp1 -> . sumexp LT sumexp
    (45) compexp1 -> . sumexp GTE sumexp
    (46) compexp1 -> . sumexp LTE sumexp
    (47) compexp1 -> . sumexp NE sumexp
    (51) mulexp -> . pexp
    (52) mulexp -> . pexp MUL pexp
    (53) mulexp -> . pexp DIV pexp
    (54) pexp -> . var1
    (55) pexp -> . CTEI
    (56) pexp -> . CTEF
    (57) pexp -> . functionCall
    (58) pexp -> . LPAREN exp RPAREN
    (64) var1 -> . ID
    (65) var1 -> . ID COMMA var1
    (66) var1 -> . ID arr
    (67) var1 -> . ID arr COMMA var1
    (68) var1 -> . empty
    (19) functionCall -> . ID LPAREN exp RPAREN
    (86) empty -> .

    CTEI            shift and go to state 108
    CTEF            shift and go to state 99
    LPAREN          shift and go to state 101
    ID              shift and go to state 102
    MUL             reduce using rule 86 (empty -> .)
    DIV             reduce using rule 86 (empty -> .)
    PLUS            reduce using rule 86 (empty -> .)
    MINUS           reduce using rule 86 (empty -> .)
    GT              reduce using rule 86 (empty -> .)
    LT              reduce using rule 86 (empty -> .)
    GTE             reduce using rule 86 (empty -> .)
    LTE             reduce using rule 86 (empty -> .)
    NE              reduce using rule 86 (empty -> .)
    AND             reduce using rule 86 (empty -> .)
    OR              reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)
    TO              reduce using rule 86 (empty -> .)

    exp                            shift and go to state 183
    nexp                           shift and go to state 92
    compexp                        shift and go to state 93
    sumexp                         shift and go to state 94
    compexp1                       shift and go to state 95
    mulexp                         shift and go to state 96
    pexp                           shift and go to state 97
    var1                           shift and go to state 98
    functionCall                   shift and go to state 100
    empty                          shift and go to state 40

state 174

    (22) read2 -> COMMA read1 .

    RPAREN          reduce using rule 22 (read2 -> COMMA read1 .)


state 175

    (26) write1 -> write2 COMMA write2 .

    RPAREN          reduce using rule 26 (write1 -> write2 COMMA write2 .)


state 176

    (32) for -> FOR assign TO CTEI DO . LCURLY statements RCURLY

    LCURLY          shift and go to state 184


state 177

    (33) while -> WHILE LPAREN exp RPAREN DO . LCURLY statements RCURLY

    LCURLY          shift and go to state 185


state 178

    (34) if -> IF LPAREN exp RPAREN THEN . LCURLY statements RCURLY else

    LCURLY          shift and go to state 186


state 179

    (84) return -> RETURN LPAREN exp RPAREN SEMMICOLON .

    ID              reduce using rule 84 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    READ            reduce using rule 84 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WRITE           reduce using rule 84 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    FOR             reduce using rule 84 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WHILE           reduce using rule 84 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    IF              reduce using rule 84 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RETURN          reduce using rule 84 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RCURLY          reduce using rule 84 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    SEMMICOLON      reduce using rule 84 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)


state 180

    (77) functionVoid -> ID LPAREN args RPAREN vars LCURLY statements . RCURLY

    RCURLY          shift and go to state 187


state 181

    (82) MultipleArgs -> COMMA args .

    RPAREN          reduce using rule 82 (MultipleArgs -> COMMA args .)


state 182

    (78) functionType -> ID saveFunction LPAREN args RPAREN vars LCURLY . statements return SEMMICOLON RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

  ! shift/reduce conflict for RETURN resolved as shift
    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57

  ! RETURN          [ reduce using rule 86 (empty -> .) ]

    statements                     shift and go to state 188
    return                         shift and go to state 49
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    empty                          shift and go to state 50

state 183

    (18) assign -> ID LBRACKET exp RBRACKET EQUALS exp .

    SEMMICOLON      reduce using rule 18 (assign -> ID LBRACKET exp RBRACKET EQUALS exp .)
    TO              reduce using rule 18 (assign -> ID LBRACKET exp RBRACKET EQUALS exp .)


state 184

    (32) for -> FOR assign TO CTEI DO LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)

    assign                         shift and go to state 42
    statements                     shift and go to state 189
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 185

    (33) while -> WHILE LPAREN exp RPAREN DO LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)

    statements                     shift and go to state 190
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 186

    (34) if -> IF LPAREN exp RPAREN THEN LCURLY . statements RCURLY else
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)

    statements                     shift and go to state 191
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 187

    (77) functionVoid -> ID LPAREN args RPAREN vars LCURLY statements RCURLY .

    FUNCTION        reduce using rule 77 (functionVoid -> ID LPAREN args RPAREN vars LCURLY statements RCURLY .)
    PRINCIPAL       reduce using rule 77 (functionVoid -> ID LPAREN args RPAREN vars LCURLY statements RCURLY .)
    $end            reduce using rule 77 (functionVoid -> ID LPAREN args RPAREN vars LCURLY statements RCURLY .)


state 188

    (78) functionType -> ID saveFunction LPAREN args RPAREN vars LCURLY statements . return SEMMICOLON RCURLY
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN

    RETURN          shift and go to state 57

    return                         shift and go to state 192

state 189

    (32) for -> FOR assign TO CTEI DO LCURLY statements . RCURLY

    RCURLY          shift and go to state 193


state 190

    (33) while -> WHILE LPAREN exp RPAREN DO LCURLY statements . RCURLY

    RCURLY          shift and go to state 194


state 191

    (34) if -> IF LPAREN exp RPAREN THEN LCURLY statements . RCURLY else

    RCURLY          shift and go to state 195


state 192

    (78) functionType -> ID saveFunction LPAREN args RPAREN vars LCURLY statements return . SEMMICOLON RCURLY

    SEMMICOLON      shift and go to state 196


state 193

    (32) for -> FOR assign TO CTEI DO LCURLY statements RCURLY .

    ID              reduce using rule 32 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    READ            reduce using rule 32 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    WRITE           reduce using rule 32 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    FOR             reduce using rule 32 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    WHILE           reduce using rule 32 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    IF              reduce using rule 32 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    RETURN          reduce using rule 32 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    RCURLY          reduce using rule 32 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 32 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)


state 194

    (33) while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .

    ID              reduce using rule 33 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    READ            reduce using rule 33 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    WRITE           reduce using rule 33 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    FOR             reduce using rule 33 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    WHILE           reduce using rule 33 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    IF              reduce using rule 33 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    RETURN          reduce using rule 33 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    RCURLY          reduce using rule 33 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 33 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)


state 195

    (34) if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY . else
    (35) else -> . ELSE LCURLY statements RCURLY
    (36) else -> . empty
    (86) empty -> .

    ELSE            shift and go to state 198
    ID              reduce using rule 86 (empty -> .)
    READ            reduce using rule 86 (empty -> .)
    WRITE           reduce using rule 86 (empty -> .)
    FOR             reduce using rule 86 (empty -> .)
    WHILE           reduce using rule 86 (empty -> .)
    IF              reduce using rule 86 (empty -> .)
    RETURN          reduce using rule 86 (empty -> .)
    RCURLY          reduce using rule 86 (empty -> .)
    SEMMICOLON      reduce using rule 86 (empty -> .)

    else                           shift and go to state 197
    empty                          shift and go to state 199

state 196

    (78) functionType -> ID saveFunction LPAREN args RPAREN vars LCURLY statements return SEMMICOLON . RCURLY

    RCURLY          shift and go to state 200


state 197

    (34) if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .

    ID              reduce using rule 34 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    READ            reduce using rule 34 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    WRITE           reduce using rule 34 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    FOR             reduce using rule 34 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    WHILE           reduce using rule 34 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    IF              reduce using rule 34 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    RETURN          reduce using rule 34 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    RCURLY          reduce using rule 34 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    SEMMICOLON      reduce using rule 34 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)


state 198

    (35) else -> ELSE . LCURLY statements RCURLY

    LCURLY          shift and go to state 201


state 199

    (36) else -> empty .

    ID              reduce using rule 36 (else -> empty .)
    READ            reduce using rule 36 (else -> empty .)
    WRITE           reduce using rule 36 (else -> empty .)
    FOR             reduce using rule 36 (else -> empty .)
    WHILE           reduce using rule 36 (else -> empty .)
    IF              reduce using rule 36 (else -> empty .)
    RETURN          reduce using rule 36 (else -> empty .)
    RCURLY          reduce using rule 36 (else -> empty .)
    SEMMICOLON      reduce using rule 36 (else -> empty .)


state 200

    (78) functionType -> ID saveFunction LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY .

    FUNCTION        reduce using rule 78 (functionType -> ID saveFunction LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY .)
    PRINCIPAL       reduce using rule 78 (functionType -> ID saveFunction LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY .)
    $end            reduce using rule 78 (functionType -> ID saveFunction LPAREN args RPAREN vars LCURLY statements return SEMMICOLON RCURLY .)


state 201

    (35) else -> ELSE LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID EQUALS exp
    (18) assign -> . ID LBRACKET exp RBRACKET EQUALS exp
    (19) functionCall -> . ID LPAREN exp RPAREN
    (20) read -> . READ LPAREN read1 RPAREN
    (25) write -> . WRITE LPAREN write1 RPAREN
    (32) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (33) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (34) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (84) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (85) return -> . RETURN LPAREN exp RPAREN
    (86) empty -> .

    ID              shift and go to state 51
    READ            shift and go to state 52
    WRITE           shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55
    IF              shift and go to state 56
    RETURN          shift and go to state 57
    RCURLY          reduce using rule 86 (empty -> .)

    statements                     shift and go to state 202
    assign                         shift and go to state 42
    functionCall                   shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    for                            shift and go to state 46
    while                          shift and go to state 47
    if                             shift and go to state 48
    return                         shift and go to state 49
    empty                          shift and go to state 50

state 202

    (35) else -> ELSE LCURLY statements . RCURLY

    RCURLY          shift and go to state 203


state 203

    (35) else -> ELSE LCURLY statements RCURLY .

    ID              reduce using rule 35 (else -> ELSE LCURLY statements RCURLY .)
    READ            reduce using rule 35 (else -> ELSE LCURLY statements RCURLY .)
    WRITE           reduce using rule 35 (else -> ELSE LCURLY statements RCURLY .)
    FOR             reduce using rule 35 (else -> ELSE LCURLY statements RCURLY .)
    WHILE           reduce using rule 35 (else -> ELSE LCURLY statements RCURLY .)
    IF              reduce using rule 35 (else -> ELSE LCURLY statements RCURLY .)
    RETURN          reduce using rule 35 (else -> ELSE LCURLY statements RCURLY .)
    RCURLY          reduce using rule 35 (else -> ELSE LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 35 (else -> ELSE LCURLY statements RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PRINCIPAL in state 5 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 39 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 46 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 47 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 48 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 49 resolved as shift
WARNING: shift/reduce conflict for ID in state 63 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 64 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 67 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 68 resolved as shift
WARNING: shift/reduce conflict for ID in state 89 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 90 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 96 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 96 resolved as shift
WARNING: shift/reduce conflict for MUL in state 97 resolved as shift
WARNING: shift/reduce conflict for DIV in state 97 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 102 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 102 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 105 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 106 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 131 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 131 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 131 resolved as shift
WARNING: shift/reduce conflict for ID in state 131 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 132 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 132 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 132 resolved as shift
WARNING: shift/reduce conflict for ID in state 132 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 133 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 133 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 133 resolved as shift
WARNING: shift/reduce conflict for ID in state 133 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 134 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 134 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 134 resolved as shift
WARNING: shift/reduce conflict for ID in state 134 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 135 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 135 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 135 resolved as shift
WARNING: shift/reduce conflict for ID in state 135 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 137 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 137 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 137 resolved as shift
WARNING: shift/reduce conflict for ID in state 137 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 138 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 138 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 138 resolved as shift
WARNING: shift/reduce conflict for ID in state 138 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 139 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 139 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 139 resolved as shift
WARNING: shift/reduce conflict for ID in state 139 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 140 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 140 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 140 resolved as shift
WARNING: shift/reduce conflict for ID in state 140 resolved as shift
WARNING: shift/reduce conflict for SEMMICOLON in state 155 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 182 resolved as shift
WARNING: reduce/reduce conflict in state 116 resolved using rule (write2 -> CTEI)
WARNING: rejected rule (pexp -> CTEI) in state 116
WARNING: reduce/reduce conflict in state 117 resolved using rule (write2 -> CTEF)
WARNING: rejected rule (pexp -> CTEF) in state 117
