Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMILLA
    COMPARE
    END
    FROM
    MODA
    PLOTXY
    SIMPLEREGRESSION
    VARIANZA

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMMICOLON addProgram program1
Rule 2     addProgram -> <empty>
Rule 3     program1 -> vars mainQuad functions mainEnd program2
Rule 4     program1 -> vars mainQuad functions
Rule 5     program1 -> program2
Rule 6     program2 -> principal
Rule 7     principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY
Rule 8     mainQuad -> <empty>
Rule 9     mainEnd -> <empty>
Rule 10    statements -> assign SEMMICOLON statements
Rule 11    statements -> functionCall SEMMICOLON statements
Rule 12    statements -> read statements SEMMICOLON statements
Rule 13    statements -> write statements SEMMICOLON statements
Rule 14    statements -> for statements
Rule 15    statements -> while statements
Rule 16    statements -> if statements
Rule 17    statements -> empty
Rule 18    assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad
Rule 19    assign -> ID arrStatement EQUALS saveOperator exp generateAssignQuad
Rule 20    assign -> ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
Rule 21    generateAssignQuad -> <empty>
Rule 22    add_id -> <empty>
Rule 23    add_id2 -> <empty>
Rule 24    add_id3 -> <empty>
Rule 25    media -> MEDIA LPAREN arr RPAREN SEMMICOLON
Rule 26    functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
Rule 27    validateFunctionID -> <empty>
Rule 28    verifyParams -> <empty>
Rule 29    paramsCount -> <empty>
Rule 30    generateQuadPARAM -> <empty>
Rule 31    expAux -> exp generateQuadPARAM paramsCount
Rule 32    expAux -> exp generateQuadPARAM COMMA paramsCount expAux
Rule 33    expAux -> empty
Rule 34    generateQuadGOSUB -> <empty>
Rule 35    fillEndProc -> <empty>
Rule 36    functionERA -> <empty>
Rule 37    read -> READ operatorRead LPAREN paramReadAux RPAREN
Rule 38    paramRead -> paramReadAux
Rule 39    paramRead -> empty
Rule 40    paramReadAux -> exp generateQuadREAD
Rule 41    paramReadAux -> exp generateQuadREAD COMMA operatorRead paramReadAux
Rule 42    operatorRead -> <empty>
Rule 43    generateQuadREAD -> <empty>
Rule 44    write -> WRITE writeOperator LPAREN paramWrite RPAREN
Rule 45    paramWrite -> paramWriteAux
Rule 46    paramWrite -> empty
Rule 47    paramWriteAux -> exp generateQuadPRINT
Rule 48    paramWriteAux -> exp generateQuadPRINT COMMA writeOperator paramWriteAux
Rule 49    writeOperator -> <empty>
Rule 50    generateQuadPRINT -> <empty>
Rule 51    LoopEnd -> <empty>
Rule 52    for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
Rule 53    forOP -> <empty>
Rule 54    generateQuadFOR -> <empty>
Rule 55    while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
Rule 56    whileOP -> <empty>
Rule 57    generateQuadWHILE -> <empty>
Rule 58    if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
Rule 59    else -> ELSE generateQuadELSE LCURLY statements RCURLY
Rule 60    else -> empty
Rule 61    generateQuadIF -> <empty>
Rule 62    endIF -> <empty>
Rule 63    generateQuadELSE -> <empty>
Rule 64    exp -> nexp generateQuadOR
Rule 65    exp -> nexp generateQuadOR OR saveOperator nexp
Rule 66    generateQuadOR -> <empty>
Rule 67    nexp -> compexp generateQuadAND
Rule 68    nexp -> compexp generateQuadAND AND saveOperator compexp
Rule 69    generateQuadAND -> <empty>
Rule 70    compexp -> sumexp
Rule 71    compexp -> compexp1 sumexp
Rule 72    compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE
Rule 73    compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE
Rule 74    compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE
Rule 75    compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE
Rule 76    compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE
Rule 77    generateQuadCOMPARE -> <empty>
Rule 78    sumexp -> mulexp
Rule 79    sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM
Rule 80    sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM
Rule 81    generateQuadSUM -> <empty>
Rule 82    mulexp -> pexp
Rule 83    mulexp -> pexp MUL saveOperator pexp generateQuadMUL
Rule 84    mulexp -> pexp DIV saveOperator pexp generateQuadMUL
Rule 85    generateQuadMUL -> <empty>
Rule 86    pexp -> ID add_id2
Rule 87    pexp -> CTEI saveCTE
Rule 88    pexp -> CTEF saveCTE
Rule 89    pexp -> CTEC saveCTE
Rule 90    pexp -> CTESTRING saveCTE
Rule 91    pexp -> functionCall
Rule 92    pexp -> LPAREN exp RPAREN
Rule 93    pexp -> ID arrStatement
Rule 94    pexp -> empty
Rule 95    arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress
Rule 96    arrStatement -> empty
Rule 97    getArrFinalAddress -> <empty>
Rule 98    checkArray -> <empty>
Rule 99    generateQuadVER -> <empty>
Rule 100   saveCTE -> <empty>
Rule 101   saveOperator -> <empty>
Rule 102   vars -> var
Rule 103   vars -> empty
Rule 104   var -> VARS var2
Rule 105   var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar
Rule 106   var2 -> empty
Rule 107   var1 -> ID
Rule 108   var1 -> ID COMMA var1 addVar
Rule 109   var1 -> ID createArr arr
Rule 110   var1 -> ID createArr arr COMMA var1 addVar
Rule 111   var1 -> empty
Rule 112   createArr -> <empty>
Rule 113   addVar -> <empty>
Rule 114   saveTypeVar -> <empty>
Rule 115   type -> INT saveTypeVar
Rule 116   type -> CHAR saveTypeVar
Rule 117   type -> FLOAT saveTypeVar
Rule 118   arr -> LBRACKET CTEI setArraySize RBRACKET
Rule 119   setArraySize -> <empty>
Rule 120   functions -> FUNCTION INT saveFunType functions2 endFunc functions
Rule 121   functions -> FUNCTION CHAR saveFunType functions2 endFunc functions
Rule 122   functions -> FUNCTION FLOAT saveFunType functions2 endFunc functions
Rule 123   functions -> FUNCTION VOID saveFunType functions1 endFunc functions
Rule 124   functions -> empty
Rule 125   saveFunType -> <empty>
Rule 126   functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements RCURLY
Rule 127   functions1 -> empty
Rule 128   functions2 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements return RCURLY
Rule 129   functions2 -> empty
Rule 130   setStartDirection -> <empty>
Rule 131   addParameter -> <empty>
Rule 132   parameters -> paramsAux
Rule 133   parameters -> empty
Rule 134   paramsAux -> INT saveTypeVar TWOPOINTS ID addParameter nextParam
Rule 135   paramsAux -> FLOAT saveTypeVar TWOPOINTS ID addParameter nextParam
Rule 136   paramsAux -> CHAR saveTypeVar TWOPOINTS ID addParameter nextParam
Rule 137   nextParam -> COMMA paramsAux
Rule 138   nextParam -> empty
Rule 139   endFunc -> <empty>
Rule 140   saveFunction -> <empty>
Rule 141   args -> args type TWOPOINTS var1 addVar
Rule 142   args -> empty
Rule 143   args1 -> ID addVar
Rule 144   args1 -> ID COMMA args1
Rule 145   args1 -> empty
Rule 146   return -> RETURN LPAREN exp generateQuadRETURN RPAREN SEMMICOLON
Rule 147   return -> RETURN LPAREN exp generateQuadRETURN RPAREN
Rule 148   generateQuadRETURN -> <empty>
Rule 149   empty -> <empty>

Terminals, with rules where they appear

AND                  : 68
CHAR                 : 116 121 136
COMILLA              : 
COMMA                : 32 41 48 108 110 137 144
COMPARE              : 
CTEC                 : 89
CTEF                 : 88
CTEI                 : 52 87 118
CTESTRING            : 90
DIV                  : 84
DO                   : 52 55
ELSE                 : 59
END                  : 
EQUALS               : 18 19 20
FLOAT                : 117 122 135
FOR                  : 52
FROM                 : 
FUNCTION             : 120 121 122 123
GT                   : 72
GTE                  : 74
ID                   : 1 18 19 20 26 86 93 107 108 109 110 126 128 134 135 136 143 144
IF                   : 58
INT                  : 115 120 134
LBRACKET             : 95 118
LCURLY               : 7 52 55 58 59 126 128
LPAREN               : 7 25 26 37 44 55 58 92 126 128 146 147
LT                   : 73
LTE                  : 75
MEDIA                : 25
MINUS                : 80
MODA                 : 
MUL                  : 83
NE                   : 76
OR                   : 65
PLOTXY               : 
PLUS                 : 79
PRINCIPAL            : 7
PROGRAM              : 1
RBRACKET             : 95 118
RCURLY               : 7 52 55 58 59 126 128
READ                 : 37
RETURN               : 146 147
RPAREN               : 7 25 26 37 44 55 58 92 126 128 146 147
SEMMICOLON           : 1 10 11 12 13 25 105 146
SIMPLEREGRESSION     : 
THEN                 : 58
TO                   : 52
TWOPOINTS            : 105 134 135 136 141
VARIANZA             : 
VARS                 : 104
VOID                 : 123
WHILE                : 55
WRITE                : 44
error                : 

Nonterminals, with rules where they appear

LoopEnd              : 52 55
addParameter         : 134 135 136
addProgram           : 1
addVar               : 105 108 110 141 143
add_id               : 
add_id2              : 18 20 86
add_id3              : 
args                 : 141
args1                : 144
arr                  : 25 109 110
arrStatement         : 19 93
assign               : 10 52
checkArray           : 95
compexp              : 67 68 68
compexp1             : 71
createArr            : 109 110
else                 : 58
empty                : 17 33 39 46 60 94 96 103 106 111 124 127 129 133 138 142 145
endFunc              : 120 121 122 123
endIF                : 58
exp                  : 18 19 31 32 40 41 47 48 55 58 92 95 146 147
expAux               : 26 32
fillEndProc          : 
for                  : 14
forOP                : 52
functionCall         : 11 20 91
functionERA          : 26
functions            : 3 4 120 121 122 123
functions1           : 123
functions2           : 120 121 122
generateAssignQuad   : 18 19 20
generateQuadAND      : 67 68
generateQuadCOMPARE  : 72 73 74 75 76
generateQuadELSE     : 59
generateQuadFOR      : 52
generateQuadGOSUB    : 26
generateQuadIF       : 58
generateQuadMUL      : 83 84
generateQuadOR       : 64 65
generateQuadPARAM    : 31 32
generateQuadPRINT    : 47 48
generateQuadREAD     : 40 41
generateQuadRETURN   : 146 147
generateQuadSUM      : 79 80
generateQuadVER      : 95
generateQuadWHILE    : 55
getArrFinalAddress   : 95
if                   : 16
mainEnd              : 3
mainQuad             : 3 4
media                : 
mulexp               : 78 79 79 80 80
nexp                 : 64 65 65
nextParam            : 134 135 136
operatorRead         : 37 41
paramRead            : 
paramReadAux         : 37 38 41
paramWrite           : 44
paramWriteAux        : 45 48
parameters           : 126 128
paramsAux            : 132 137
paramsCount          : 31 32
pexp                 : 82 83 83 84 84
principal            : 6
program              : 0
program1             : 1
program2             : 3 5
read                 : 12
return               : 128
saveCTE              : 87 88 89 90
saveFunType          : 120 121 122 123
saveFunction         : 7 126 128
saveOperator         : 18 19 20 65 68 72 73 74 75 76 79 80 83 84
saveTypeVar          : 115 116 117 134 135 136
setArraySize         : 118
setStartDirection    : 126 128
statements           : 7 10 11 12 12 13 13 14 15 16 52 55 58 59 126 128
sumexp               : 70 71 72 72 73 73 74 74 75 75 76 76
type                 : 105 141
validateFunctionID   : 26
var                  : 102
var1                 : 105 108 110 141
var2                 : 104 105
vars                 : 3 4 7 126 128
verifyParams         : 26
while                : 15
whileOP              : 55
write                : 13
writeOperator        : 44 48

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMMICOLON addProgram program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMMICOLON addProgram program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMMICOLON addProgram program1

    SEMMICOLON      shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMMICOLON . addProgram program1
    (2) addProgram -> .

    VARS            reduce using rule 2 (addProgram -> .)
    PRINCIPAL       reduce using rule 2 (addProgram -> .)
    FUNCTION        reduce using rule 2 (addProgram -> .)
    $end            reduce using rule 2 (addProgram -> .)

    addProgram                     shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMMICOLON addProgram . program1
    (3) program1 -> . vars mainQuad functions mainEnd program2
    (4) program1 -> . vars mainQuad functions
    (5) program1 -> . program2
    (102) vars -> . var
    (103) vars -> . empty
    (6) program2 -> . principal
    (104) var -> . VARS var2
    (149) empty -> .
    (7) principal -> . PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY

  ! shift/reduce conflict for PRINCIPAL resolved as shift
    VARS            shift and go to state 12
    FUNCTION        reduce using rule 149 (empty -> .)
    $end            reduce using rule 149 (empty -> .)
    PRINCIPAL       shift and go to state 13

  ! PRINCIPAL       [ reduce using rule 149 (empty -> .) ]

    program1                       shift and go to state 6
    vars                           shift and go to state 7
    program2                       shift and go to state 8
    var                            shift and go to state 9
    empty                          shift and go to state 10
    principal                      shift and go to state 11

state 6

    (1) program -> PROGRAM ID SEMMICOLON addProgram program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMMICOLON addProgram program1 .)


state 7

    (3) program1 -> vars . mainQuad functions mainEnd program2
    (4) program1 -> vars . mainQuad functions
    (8) mainQuad -> .

    FUNCTION        reduce using rule 8 (mainQuad -> .)
    PRINCIPAL       reduce using rule 8 (mainQuad -> .)
    $end            reduce using rule 8 (mainQuad -> .)

    mainQuad                       shift and go to state 14

state 8

    (5) program1 -> program2 .

    $end            reduce using rule 5 (program1 -> program2 .)


state 9

    (102) vars -> var .

    FUNCTION        reduce using rule 102 (vars -> var .)
    PRINCIPAL       reduce using rule 102 (vars -> var .)
    $end            reduce using rule 102 (vars -> var .)
    ID              reduce using rule 102 (vars -> var .)
    READ            reduce using rule 102 (vars -> var .)
    WRITE           reduce using rule 102 (vars -> var .)
    FOR             reduce using rule 102 (vars -> var .)
    WHILE           reduce using rule 102 (vars -> var .)
    IF              reduce using rule 102 (vars -> var .)
    RCURLY          reduce using rule 102 (vars -> var .)
    LCURLY          reduce using rule 102 (vars -> var .)


state 10

    (103) vars -> empty .

    FUNCTION        reduce using rule 103 (vars -> empty .)
    PRINCIPAL       reduce using rule 103 (vars -> empty .)
    $end            reduce using rule 103 (vars -> empty .)
    ID              reduce using rule 103 (vars -> empty .)
    READ            reduce using rule 103 (vars -> empty .)
    WRITE           reduce using rule 103 (vars -> empty .)
    FOR             reduce using rule 103 (vars -> empty .)
    WHILE           reduce using rule 103 (vars -> empty .)
    IF              reduce using rule 103 (vars -> empty .)
    RCURLY          reduce using rule 103 (vars -> empty .)
    LCURLY          reduce using rule 103 (vars -> empty .)


state 11

    (6) program2 -> principal .

    $end            reduce using rule 6 (program2 -> principal .)


state 12

    (104) var -> VARS . var2
    (105) var2 -> . var2 type TWOPOINTS var1 SEMMICOLON addVar
    (106) var2 -> . empty
    (149) empty -> .

    INT             reduce using rule 149 (empty -> .)
    CHAR            reduce using rule 149 (empty -> .)
    FLOAT           reduce using rule 149 (empty -> .)
    FUNCTION        reduce using rule 149 (empty -> .)
    PRINCIPAL       reduce using rule 149 (empty -> .)
    $end            reduce using rule 149 (empty -> .)
    ID              reduce using rule 149 (empty -> .)
    READ            reduce using rule 149 (empty -> .)
    WRITE           reduce using rule 149 (empty -> .)
    FOR             reduce using rule 149 (empty -> .)
    WHILE           reduce using rule 149 (empty -> .)
    IF              reduce using rule 149 (empty -> .)
    RCURLY          reduce using rule 149 (empty -> .)
    LCURLY          reduce using rule 149 (empty -> .)

    var2                           shift and go to state 15
    empty                          shift and go to state 16

state 13

    (7) principal -> PRINCIPAL . saveFunction LPAREN RPAREN LCURLY vars statements RCURLY
    (140) saveFunction -> .

    LPAREN          reduce using rule 140 (saveFunction -> .)

    saveFunction                   shift and go to state 17

state 14

    (3) program1 -> vars mainQuad . functions mainEnd program2
    (4) program1 -> vars mainQuad . functions
    (120) functions -> . FUNCTION INT saveFunType functions2 endFunc functions
    (121) functions -> . FUNCTION CHAR saveFunType functions2 endFunc functions
    (122) functions -> . FUNCTION FLOAT saveFunType functions2 endFunc functions
    (123) functions -> . FUNCTION VOID saveFunType functions1 endFunc functions
    (124) functions -> . empty
    (149) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 149 (empty -> .)
    $end            reduce using rule 149 (empty -> .)

    functions                      shift and go to state 18
    empty                          shift and go to state 20

state 15

    (104) var -> VARS var2 .
    (105) var2 -> var2 . type TWOPOINTS var1 SEMMICOLON addVar
    (115) type -> . INT saveTypeVar
    (116) type -> . CHAR saveTypeVar
    (117) type -> . FLOAT saveTypeVar

    FUNCTION        reduce using rule 104 (var -> VARS var2 .)
    PRINCIPAL       reduce using rule 104 (var -> VARS var2 .)
    $end            reduce using rule 104 (var -> VARS var2 .)
    ID              reduce using rule 104 (var -> VARS var2 .)
    READ            reduce using rule 104 (var -> VARS var2 .)
    WRITE           reduce using rule 104 (var -> VARS var2 .)
    FOR             reduce using rule 104 (var -> VARS var2 .)
    WHILE           reduce using rule 104 (var -> VARS var2 .)
    IF              reduce using rule 104 (var -> VARS var2 .)
    RCURLY          reduce using rule 104 (var -> VARS var2 .)
    LCURLY          reduce using rule 104 (var -> VARS var2 .)
    INT             shift and go to state 22
    CHAR            shift and go to state 23
    FLOAT           shift and go to state 24

    type                           shift and go to state 21

state 16

    (106) var2 -> empty .

    INT             reduce using rule 106 (var2 -> empty .)
    CHAR            reduce using rule 106 (var2 -> empty .)
    FLOAT           reduce using rule 106 (var2 -> empty .)
    FUNCTION        reduce using rule 106 (var2 -> empty .)
    PRINCIPAL       reduce using rule 106 (var2 -> empty .)
    $end            reduce using rule 106 (var2 -> empty .)
    ID              reduce using rule 106 (var2 -> empty .)
    READ            reduce using rule 106 (var2 -> empty .)
    WRITE           reduce using rule 106 (var2 -> empty .)
    FOR             reduce using rule 106 (var2 -> empty .)
    WHILE           reduce using rule 106 (var2 -> empty .)
    IF              reduce using rule 106 (var2 -> empty .)
    RCURLY          reduce using rule 106 (var2 -> empty .)
    LCURLY          reduce using rule 106 (var2 -> empty .)


state 17

    (7) principal -> PRINCIPAL saveFunction . LPAREN RPAREN LCURLY vars statements RCURLY

    LPAREN          shift and go to state 25


state 18

    (3) program1 -> vars mainQuad functions . mainEnd program2
    (4) program1 -> vars mainQuad functions .
    (9) mainEnd -> .

    $end            reduce using rule 4 (program1 -> vars mainQuad functions .)
    PRINCIPAL       reduce using rule 9 (mainEnd -> .)

    mainEnd                        shift and go to state 26

state 19

    (120) functions -> FUNCTION . INT saveFunType functions2 endFunc functions
    (121) functions -> FUNCTION . CHAR saveFunType functions2 endFunc functions
    (122) functions -> FUNCTION . FLOAT saveFunType functions2 endFunc functions
    (123) functions -> FUNCTION . VOID saveFunType functions1 endFunc functions

    INT             shift and go to state 27
    CHAR            shift and go to state 28
    FLOAT           shift and go to state 29
    VOID            shift and go to state 30


state 20

    (124) functions -> empty .

    PRINCIPAL       reduce using rule 124 (functions -> empty .)
    $end            reduce using rule 124 (functions -> empty .)


state 21

    (105) var2 -> var2 type . TWOPOINTS var1 SEMMICOLON addVar

    TWOPOINTS       shift and go to state 31


state 22

    (115) type -> INT . saveTypeVar
    (114) saveTypeVar -> .

    TWOPOINTS       reduce using rule 114 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 32

state 23

    (116) type -> CHAR . saveTypeVar
    (114) saveTypeVar -> .

    TWOPOINTS       reduce using rule 114 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 33

state 24

    (117) type -> FLOAT . saveTypeVar
    (114) saveTypeVar -> .

    TWOPOINTS       reduce using rule 114 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 34

state 25

    (7) principal -> PRINCIPAL saveFunction LPAREN . RPAREN LCURLY vars statements RCURLY

    RPAREN          shift and go to state 35


state 26

    (3) program1 -> vars mainQuad functions mainEnd . program2
    (6) program2 -> . principal
    (7) principal -> . PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY

    PRINCIPAL       shift and go to state 13

    program2                       shift and go to state 36
    principal                      shift and go to state 11

state 27

    (120) functions -> FUNCTION INT . saveFunType functions2 endFunc functions
    (125) saveFunType -> .

    ID              reduce using rule 125 (saveFunType -> .)
    FUNCTION        reduce using rule 125 (saveFunType -> .)
    PRINCIPAL       reduce using rule 125 (saveFunType -> .)
    $end            reduce using rule 125 (saveFunType -> .)

    saveFunType                    shift and go to state 37

state 28

    (121) functions -> FUNCTION CHAR . saveFunType functions2 endFunc functions
    (125) saveFunType -> .

    ID              reduce using rule 125 (saveFunType -> .)
    FUNCTION        reduce using rule 125 (saveFunType -> .)
    PRINCIPAL       reduce using rule 125 (saveFunType -> .)
    $end            reduce using rule 125 (saveFunType -> .)

    saveFunType                    shift and go to state 38

state 29

    (122) functions -> FUNCTION FLOAT . saveFunType functions2 endFunc functions
    (125) saveFunType -> .

    ID              reduce using rule 125 (saveFunType -> .)
    FUNCTION        reduce using rule 125 (saveFunType -> .)
    PRINCIPAL       reduce using rule 125 (saveFunType -> .)
    $end            reduce using rule 125 (saveFunType -> .)

    saveFunType                    shift and go to state 39

state 30

    (123) functions -> FUNCTION VOID . saveFunType functions1 endFunc functions
    (125) saveFunType -> .

    ID              reduce using rule 125 (saveFunType -> .)
    FUNCTION        reduce using rule 125 (saveFunType -> .)
    PRINCIPAL       reduce using rule 125 (saveFunType -> .)
    $end            reduce using rule 125 (saveFunType -> .)

    saveFunType                    shift and go to state 40

state 31

    (105) var2 -> var2 type TWOPOINTS . var1 SEMMICOLON addVar
    (107) var1 -> . ID
    (108) var1 -> . ID COMMA var1 addVar
    (109) var1 -> . ID createArr arr
    (110) var1 -> . ID createArr arr COMMA var1 addVar
    (111) var1 -> . empty
    (149) empty -> .

    ID              shift and go to state 42
    SEMMICOLON      reduce using rule 149 (empty -> .)

    var1                           shift and go to state 41
    empty                          shift and go to state 43

state 32

    (115) type -> INT saveTypeVar .

    TWOPOINTS       reduce using rule 115 (type -> INT saveTypeVar .)


state 33

    (116) type -> CHAR saveTypeVar .

    TWOPOINTS       reduce using rule 116 (type -> CHAR saveTypeVar .)


state 34

    (117) type -> FLOAT saveTypeVar .

    TWOPOINTS       reduce using rule 117 (type -> FLOAT saveTypeVar .)


state 35

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN . LCURLY vars statements RCURLY

    LCURLY          shift and go to state 44


state 36

    (3) program1 -> vars mainQuad functions mainEnd program2 .

    $end            reduce using rule 3 (program1 -> vars mainQuad functions mainEnd program2 .)


state 37

    (120) functions -> FUNCTION INT saveFunType . functions2 endFunc functions
    (128) functions2 -> . ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements return RCURLY
    (129) functions2 -> . empty
    (149) empty -> .

    ID              shift and go to state 46
    FUNCTION        reduce using rule 149 (empty -> .)
    PRINCIPAL       reduce using rule 149 (empty -> .)
    $end            reduce using rule 149 (empty -> .)

    functions2                     shift and go to state 45
    empty                          shift and go to state 47

state 38

    (121) functions -> FUNCTION CHAR saveFunType . functions2 endFunc functions
    (128) functions2 -> . ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements return RCURLY
    (129) functions2 -> . empty
    (149) empty -> .

    ID              shift and go to state 46
    FUNCTION        reduce using rule 149 (empty -> .)
    PRINCIPAL       reduce using rule 149 (empty -> .)
    $end            reduce using rule 149 (empty -> .)

    functions2                     shift and go to state 48
    empty                          shift and go to state 47

state 39

    (122) functions -> FUNCTION FLOAT saveFunType . functions2 endFunc functions
    (128) functions2 -> . ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements return RCURLY
    (129) functions2 -> . empty
    (149) empty -> .

    ID              shift and go to state 46
    FUNCTION        reduce using rule 149 (empty -> .)
    PRINCIPAL       reduce using rule 149 (empty -> .)
    $end            reduce using rule 149 (empty -> .)

    functions2                     shift and go to state 49
    empty                          shift and go to state 47

state 40

    (123) functions -> FUNCTION VOID saveFunType . functions1 endFunc functions
    (126) functions1 -> . ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements RCURLY
    (127) functions1 -> . empty
    (149) empty -> .

    ID              shift and go to state 51
    FUNCTION        reduce using rule 149 (empty -> .)
    PRINCIPAL       reduce using rule 149 (empty -> .)
    $end            reduce using rule 149 (empty -> .)

    functions1                     shift and go to state 50
    empty                          shift and go to state 52

state 41

    (105) var2 -> var2 type TWOPOINTS var1 . SEMMICOLON addVar

    SEMMICOLON      shift and go to state 53


state 42

    (107) var1 -> ID .
    (108) var1 -> ID . COMMA var1 addVar
    (109) var1 -> ID . createArr arr
    (110) var1 -> ID . createArr arr COMMA var1 addVar
    (112) createArr -> .

    SEMMICOLON      reduce using rule 107 (var1 -> ID .)
    COMMA           shift and go to state 54
    LBRACKET        reduce using rule 112 (createArr -> .)

    createArr                      shift and go to state 55

state 43

    (111) var1 -> empty .

    SEMMICOLON      reduce using rule 111 (var1 -> empty .)


state 44

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY . vars statements RCURLY
    (102) vars -> . var
    (103) vars -> . empty
    (104) var -> . VARS var2
    (149) empty -> .

    VARS            shift and go to state 12
    ID              reduce using rule 149 (empty -> .)
    READ            reduce using rule 149 (empty -> .)
    WRITE           reduce using rule 149 (empty -> .)
    FOR             reduce using rule 149 (empty -> .)
    WHILE           reduce using rule 149 (empty -> .)
    IF              reduce using rule 149 (empty -> .)
    RCURLY          reduce using rule 149 (empty -> .)

    vars                           shift and go to state 56
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 45

    (120) functions -> FUNCTION INT saveFunType functions2 . endFunc functions
    (139) endFunc -> .

    FUNCTION        reduce using rule 139 (endFunc -> .)
    PRINCIPAL       reduce using rule 139 (endFunc -> .)
    $end            reduce using rule 139 (endFunc -> .)

    endFunc                        shift and go to state 57

state 46

    (128) functions2 -> ID . saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements return RCURLY
    (140) saveFunction -> .

    LPAREN          reduce using rule 140 (saveFunction -> .)

    saveFunction                   shift and go to state 58

state 47

    (129) functions2 -> empty .

    FUNCTION        reduce using rule 129 (functions2 -> empty .)
    PRINCIPAL       reduce using rule 129 (functions2 -> empty .)
    $end            reduce using rule 129 (functions2 -> empty .)


state 48

    (121) functions -> FUNCTION CHAR saveFunType functions2 . endFunc functions
    (139) endFunc -> .

    FUNCTION        reduce using rule 139 (endFunc -> .)
    PRINCIPAL       reduce using rule 139 (endFunc -> .)
    $end            reduce using rule 139 (endFunc -> .)

    endFunc                        shift and go to state 59

state 49

    (122) functions -> FUNCTION FLOAT saveFunType functions2 . endFunc functions
    (139) endFunc -> .

    FUNCTION        reduce using rule 139 (endFunc -> .)
    PRINCIPAL       reduce using rule 139 (endFunc -> .)
    $end            reduce using rule 139 (endFunc -> .)

    endFunc                        shift and go to state 60

state 50

    (123) functions -> FUNCTION VOID saveFunType functions1 . endFunc functions
    (139) endFunc -> .

    FUNCTION        reduce using rule 139 (endFunc -> .)
    PRINCIPAL       reduce using rule 139 (endFunc -> .)
    $end            reduce using rule 139 (endFunc -> .)

    endFunc                        shift and go to state 61

state 51

    (126) functions1 -> ID . saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements RCURLY
    (140) saveFunction -> .

    LPAREN          reduce using rule 140 (saveFunction -> .)

    saveFunction                   shift and go to state 62

state 52

    (127) functions1 -> empty .

    FUNCTION        reduce using rule 127 (functions1 -> empty .)
    PRINCIPAL       reduce using rule 127 (functions1 -> empty .)
    $end            reduce using rule 127 (functions1 -> empty .)


state 53

    (105) var2 -> var2 type TWOPOINTS var1 SEMMICOLON . addVar
    (113) addVar -> .

    INT             reduce using rule 113 (addVar -> .)
    CHAR            reduce using rule 113 (addVar -> .)
    FLOAT           reduce using rule 113 (addVar -> .)
    FUNCTION        reduce using rule 113 (addVar -> .)
    PRINCIPAL       reduce using rule 113 (addVar -> .)
    $end            reduce using rule 113 (addVar -> .)
    ID              reduce using rule 113 (addVar -> .)
    READ            reduce using rule 113 (addVar -> .)
    WRITE           reduce using rule 113 (addVar -> .)
    FOR             reduce using rule 113 (addVar -> .)
    WHILE           reduce using rule 113 (addVar -> .)
    IF              reduce using rule 113 (addVar -> .)
    RCURLY          reduce using rule 113 (addVar -> .)
    LCURLY          reduce using rule 113 (addVar -> .)

    addVar                         shift and go to state 63

state 54

    (108) var1 -> ID COMMA . var1 addVar
    (107) var1 -> . ID
    (108) var1 -> . ID COMMA var1 addVar
    (109) var1 -> . ID createArr arr
    (110) var1 -> . ID createArr arr COMMA var1 addVar
    (111) var1 -> . empty
    (149) empty -> .

    ID              shift and go to state 42
    SEMMICOLON      reduce using rule 149 (empty -> .)

    var1                           shift and go to state 64
    empty                          shift and go to state 43

state 55

    (109) var1 -> ID createArr . arr
    (110) var1 -> ID createArr . arr COMMA var1 addVar
    (118) arr -> . LBRACKET CTEI setArraySize RBRACKET

    LBRACKET        shift and go to state 66

    arr                            shift and go to state 65

state 56

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars . statements RCURLY
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)

    statements                     shift and go to state 67
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 57

    (120) functions -> FUNCTION INT saveFunType functions2 endFunc . functions
    (120) functions -> . FUNCTION INT saveFunType functions2 endFunc functions
    (121) functions -> . FUNCTION CHAR saveFunType functions2 endFunc functions
    (122) functions -> . FUNCTION FLOAT saveFunType functions2 endFunc functions
    (123) functions -> . FUNCTION VOID saveFunType functions1 endFunc functions
    (124) functions -> . empty
    (149) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 149 (empty -> .)
    $end            reduce using rule 149 (empty -> .)

    functions                      shift and go to state 82
    empty                          shift and go to state 20

state 58

    (128) functions2 -> ID saveFunction . LPAREN parameters RPAREN vars LCURLY setStartDirection statements return RCURLY

    LPAREN          shift and go to state 83


state 59

    (121) functions -> FUNCTION CHAR saveFunType functions2 endFunc . functions
    (120) functions -> . FUNCTION INT saveFunType functions2 endFunc functions
    (121) functions -> . FUNCTION CHAR saveFunType functions2 endFunc functions
    (122) functions -> . FUNCTION FLOAT saveFunType functions2 endFunc functions
    (123) functions -> . FUNCTION VOID saveFunType functions1 endFunc functions
    (124) functions -> . empty
    (149) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 149 (empty -> .)
    $end            reduce using rule 149 (empty -> .)

    functions                      shift and go to state 84
    empty                          shift and go to state 20

state 60

    (122) functions -> FUNCTION FLOAT saveFunType functions2 endFunc . functions
    (120) functions -> . FUNCTION INT saveFunType functions2 endFunc functions
    (121) functions -> . FUNCTION CHAR saveFunType functions2 endFunc functions
    (122) functions -> . FUNCTION FLOAT saveFunType functions2 endFunc functions
    (123) functions -> . FUNCTION VOID saveFunType functions1 endFunc functions
    (124) functions -> . empty
    (149) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 149 (empty -> .)
    $end            reduce using rule 149 (empty -> .)

    functions                      shift and go to state 85
    empty                          shift and go to state 20

state 61

    (123) functions -> FUNCTION VOID saveFunType functions1 endFunc . functions
    (120) functions -> . FUNCTION INT saveFunType functions2 endFunc functions
    (121) functions -> . FUNCTION CHAR saveFunType functions2 endFunc functions
    (122) functions -> . FUNCTION FLOAT saveFunType functions2 endFunc functions
    (123) functions -> . FUNCTION VOID saveFunType functions1 endFunc functions
    (124) functions -> . empty
    (149) empty -> .

    FUNCTION        shift and go to state 19
    PRINCIPAL       reduce using rule 149 (empty -> .)
    $end            reduce using rule 149 (empty -> .)

    functions                      shift and go to state 86
    empty                          shift and go to state 20

state 62

    (126) functions1 -> ID saveFunction . LPAREN parameters RPAREN vars LCURLY setStartDirection statements RCURLY

    LPAREN          shift and go to state 87


state 63

    (105) var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .

    INT             reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    CHAR            reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FLOAT           reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FUNCTION        reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    PRINCIPAL       reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    $end            reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    ID              reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    READ            reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WRITE           reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FOR             reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WHILE           reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    IF              reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    RCURLY          reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    LCURLY          reduce using rule 105 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)


state 64

    (108) var1 -> ID COMMA var1 . addVar
    (113) addVar -> .

    SEMMICOLON      reduce using rule 113 (addVar -> .)

    addVar                         shift and go to state 88

state 65

    (109) var1 -> ID createArr arr .
    (110) var1 -> ID createArr arr . COMMA var1 addVar

    SEMMICOLON      reduce using rule 109 (var1 -> ID createArr arr .)
    COMMA           shift and go to state 89


state 66

    (118) arr -> LBRACKET . CTEI setArraySize RBRACKET

    CTEI            shift and go to state 90


state 67

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements . RCURLY

    RCURLY          shift and go to state 91


state 68

    (10) statements -> assign . SEMMICOLON statements

    SEMMICOLON      shift and go to state 92


state 69

    (11) statements -> functionCall . SEMMICOLON statements

    SEMMICOLON      shift and go to state 93


state 70

    (12) statements -> read . statements SEMMICOLON statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    SEMMICOLON      reduce using rule 149 (empty -> .)

    read                           shift and go to state 70
    statements                     shift and go to state 94
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 71

    (13) statements -> write . statements SEMMICOLON statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    SEMMICOLON      reduce using rule 149 (empty -> .)

    write                          shift and go to state 71
    statements                     shift and go to state 95
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 72

    (14) statements -> for . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    RETURN          reduce using rule 149 (empty -> .)

    for                            shift and go to state 72
    statements                     shift and go to state 96
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 73

    (15) statements -> while . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    RETURN          reduce using rule 149 (empty -> .)

    while                          shift and go to state 73
    statements                     shift and go to state 97
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    for                            shift and go to state 72
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 74

    (16) statements -> if . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    RETURN          reduce using rule 149 (empty -> .)

    if                             shift and go to state 74
    statements                     shift and go to state 98
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    empty                          shift and go to state 75

state 75

    (17) statements -> empty .

    RCURLY          reduce using rule 17 (statements -> empty .)
    SEMMICOLON      reduce using rule 17 (statements -> empty .)
    RETURN          reduce using rule 17 (statements -> empty .)


state 76

    (18) assign -> ID . add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> ID . arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> ID . add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> ID . validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (23) add_id2 -> .
    (95) arrStatement -> . LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress
    (96) arrStatement -> . empty
    (27) validateFunctionID -> .
    (149) empty -> .

  ! reduce/reduce conflict for EQUALS resolved using rule 23 (add_id2 -> .)
    EQUALS          reduce using rule 23 (add_id2 -> .)
    LBRACKET        shift and go to state 102
    LPAREN          reduce using rule 27 (validateFunctionID -> .)

  ! EQUALS          [ reduce using rule 149 (empty -> .) ]

    add_id2                        shift and go to state 99
    arrStatement                   shift and go to state 100
    validateFunctionID             shift and go to state 101
    empty                          shift and go to state 103

state 77

    (37) read -> READ . operatorRead LPAREN paramReadAux RPAREN
    (42) operatorRead -> .

    LPAREN          reduce using rule 42 (operatorRead -> .)

    operatorRead                   shift and go to state 104

state 78

    (44) write -> WRITE . writeOperator LPAREN paramWrite RPAREN
    (49) writeOperator -> .

    LPAREN          reduce using rule 49 (writeOperator -> .)

    writeOperator                  shift and go to state 105

state 79

    (52) for -> FOR . forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (53) forOP -> .

    ID              reduce using rule 53 (forOP -> .)

    forOP                          shift and go to state 106

state 80

    (55) while -> WHILE . whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (56) whileOP -> .

    LPAREN          reduce using rule 56 (whileOP -> .)

    whileOP                        shift and go to state 107

state 81

    (58) if -> IF . LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF

    LPAREN          shift and go to state 108


state 82

    (120) functions -> FUNCTION INT saveFunType functions2 endFunc functions .

    PRINCIPAL       reduce using rule 120 (functions -> FUNCTION INT saveFunType functions2 endFunc functions .)
    $end            reduce using rule 120 (functions -> FUNCTION INT saveFunType functions2 endFunc functions .)


state 83

    (128) functions2 -> ID saveFunction LPAREN . parameters RPAREN vars LCURLY setStartDirection statements return RCURLY
    (132) parameters -> . paramsAux
    (133) parameters -> . empty
    (134) paramsAux -> . INT saveTypeVar TWOPOINTS ID addParameter nextParam
    (135) paramsAux -> . FLOAT saveTypeVar TWOPOINTS ID addParameter nextParam
    (136) paramsAux -> . CHAR saveTypeVar TWOPOINTS ID addParameter nextParam
    (149) empty -> .

    INT             shift and go to state 112
    FLOAT           shift and go to state 113
    CHAR            shift and go to state 114
    RPAREN          reduce using rule 149 (empty -> .)

    parameters                     shift and go to state 109
    paramsAux                      shift and go to state 110
    empty                          shift and go to state 111

state 84

    (121) functions -> FUNCTION CHAR saveFunType functions2 endFunc functions .

    PRINCIPAL       reduce using rule 121 (functions -> FUNCTION CHAR saveFunType functions2 endFunc functions .)
    $end            reduce using rule 121 (functions -> FUNCTION CHAR saveFunType functions2 endFunc functions .)


state 85

    (122) functions -> FUNCTION FLOAT saveFunType functions2 endFunc functions .

    PRINCIPAL       reduce using rule 122 (functions -> FUNCTION FLOAT saveFunType functions2 endFunc functions .)
    $end            reduce using rule 122 (functions -> FUNCTION FLOAT saveFunType functions2 endFunc functions .)


state 86

    (123) functions -> FUNCTION VOID saveFunType functions1 endFunc functions .

    PRINCIPAL       reduce using rule 123 (functions -> FUNCTION VOID saveFunType functions1 endFunc functions .)
    $end            reduce using rule 123 (functions -> FUNCTION VOID saveFunType functions1 endFunc functions .)


state 87

    (126) functions1 -> ID saveFunction LPAREN . parameters RPAREN vars LCURLY setStartDirection statements RCURLY
    (132) parameters -> . paramsAux
    (133) parameters -> . empty
    (134) paramsAux -> . INT saveTypeVar TWOPOINTS ID addParameter nextParam
    (135) paramsAux -> . FLOAT saveTypeVar TWOPOINTS ID addParameter nextParam
    (136) paramsAux -> . CHAR saveTypeVar TWOPOINTS ID addParameter nextParam
    (149) empty -> .

    INT             shift and go to state 112
    FLOAT           shift and go to state 113
    CHAR            shift and go to state 114
    RPAREN          reduce using rule 149 (empty -> .)

    parameters                     shift and go to state 115
    paramsAux                      shift and go to state 110
    empty                          shift and go to state 111

state 88

    (108) var1 -> ID COMMA var1 addVar .

    SEMMICOLON      reduce using rule 108 (var1 -> ID COMMA var1 addVar .)


state 89

    (110) var1 -> ID createArr arr COMMA . var1 addVar
    (107) var1 -> . ID
    (108) var1 -> . ID COMMA var1 addVar
    (109) var1 -> . ID createArr arr
    (110) var1 -> . ID createArr arr COMMA var1 addVar
    (111) var1 -> . empty
    (149) empty -> .

    ID              shift and go to state 42
    SEMMICOLON      reduce using rule 149 (empty -> .)

    var1                           shift and go to state 116
    empty                          shift and go to state 43

state 90

    (118) arr -> LBRACKET CTEI . setArraySize RBRACKET
    (119) setArraySize -> .

    RBRACKET        reduce using rule 119 (setArraySize -> .)

    setArraySize                   shift and go to state 117

state 91

    (7) principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY .

    $end            reduce using rule 7 (principal -> PRINCIPAL saveFunction LPAREN RPAREN LCURLY vars statements RCURLY .)


state 92

    (10) statements -> assign SEMMICOLON . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    RETURN          reduce using rule 149 (empty -> .)

    assign                         shift and go to state 68
    statements                     shift and go to state 118
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 93

    (11) statements -> functionCall SEMMICOLON . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    RETURN          reduce using rule 149 (empty -> .)

    functionCall                   shift and go to state 69
    statements                     shift and go to state 119
    assign                         shift and go to state 68
    read                           shift and go to state 70
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 94

    (12) statements -> read statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 120


state 95

    (13) statements -> write statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 121


state 96

    (14) statements -> for statements .

    RCURLY          reduce using rule 14 (statements -> for statements .)
    SEMMICOLON      reduce using rule 14 (statements -> for statements .)
    RETURN          reduce using rule 14 (statements -> for statements .)


state 97

    (15) statements -> while statements .

    RCURLY          reduce using rule 15 (statements -> while statements .)
    SEMMICOLON      reduce using rule 15 (statements -> while statements .)
    RETURN          reduce using rule 15 (statements -> while statements .)


state 98

    (16) statements -> if statements .

    RCURLY          reduce using rule 16 (statements -> if statements .)
    SEMMICOLON      reduce using rule 16 (statements -> if statements .)
    RETURN          reduce using rule 16 (statements -> if statements .)


state 99

    (18) assign -> ID add_id2 . EQUALS saveOperator exp generateAssignQuad
    (20) assign -> ID add_id2 . EQUALS saveOperator functionCall generateAssignQuad

    EQUALS          shift and go to state 122


state 100

    (19) assign -> ID arrStatement . EQUALS saveOperator exp generateAssignQuad

    EQUALS          shift and go to state 123


state 101

    (26) functionCall -> ID validateFunctionID . functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (36) functionERA -> .

    LPAREN          reduce using rule 36 (functionERA -> .)

    functionERA                    shift and go to state 124

state 102

    (95) arrStatement -> LBRACKET . checkArray exp generateQuadVER RBRACKET getArrFinalAddress
    (98) checkArray -> .

    ID              reduce using rule 98 (checkArray -> .)
    CTEI            reduce using rule 98 (checkArray -> .)
    CTEF            reduce using rule 98 (checkArray -> .)
    CTEC            reduce using rule 98 (checkArray -> .)
    CTESTRING       reduce using rule 98 (checkArray -> .)
    LPAREN          reduce using rule 98 (checkArray -> .)
    RBRACKET        reduce using rule 98 (checkArray -> .)
    OR              reduce using rule 98 (checkArray -> .)
    AND             reduce using rule 98 (checkArray -> .)
    GT              reduce using rule 98 (checkArray -> .)
    LT              reduce using rule 98 (checkArray -> .)
    GTE             reduce using rule 98 (checkArray -> .)
    LTE             reduce using rule 98 (checkArray -> .)
    NE              reduce using rule 98 (checkArray -> .)
    PLUS            reduce using rule 98 (checkArray -> .)
    MINUS           reduce using rule 98 (checkArray -> .)
    MUL             reduce using rule 98 (checkArray -> .)
    DIV             reduce using rule 98 (checkArray -> .)

    checkArray                     shift and go to state 125

state 103

    (96) arrStatement -> empty .

    EQUALS          reduce using rule 96 (arrStatement -> empty .)
    MUL             reduce using rule 96 (arrStatement -> empty .)
    DIV             reduce using rule 96 (arrStatement -> empty .)
    PLUS            reduce using rule 96 (arrStatement -> empty .)
    MINUS           reduce using rule 96 (arrStatement -> empty .)
    GT              reduce using rule 96 (arrStatement -> empty .)
    LT              reduce using rule 96 (arrStatement -> empty .)
    GTE             reduce using rule 96 (arrStatement -> empty .)
    LTE             reduce using rule 96 (arrStatement -> empty .)
    NE              reduce using rule 96 (arrStatement -> empty .)
    AND             reduce using rule 96 (arrStatement -> empty .)
    OR              reduce using rule 96 (arrStatement -> empty .)
    RPAREN          reduce using rule 96 (arrStatement -> empty .)
    RBRACKET        reduce using rule 96 (arrStatement -> empty .)
    COMMA           reduce using rule 96 (arrStatement -> empty .)
    SEMMICOLON      reduce using rule 96 (arrStatement -> empty .)
    TO              reduce using rule 96 (arrStatement -> empty .)
    ID              reduce using rule 96 (arrStatement -> empty .)
    CTEI            reduce using rule 96 (arrStatement -> empty .)
    CTEF            reduce using rule 96 (arrStatement -> empty .)
    CTEC            reduce using rule 96 (arrStatement -> empty .)
    CTESTRING       reduce using rule 96 (arrStatement -> empty .)
    LPAREN          reduce using rule 96 (arrStatement -> empty .)


state 104

    (37) read -> READ operatorRead . LPAREN paramReadAux RPAREN

    LPAREN          shift and go to state 126


state 105

    (44) write -> WRITE writeOperator . LPAREN paramWrite RPAREN

    LPAREN          shift and go to state 127


state 106

    (52) for -> FOR forOP . assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad

    ID              shift and go to state 129

    assign                         shift and go to state 128

state 107

    (55) while -> WHILE whileOP . LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    LPAREN          shift and go to state 130


state 108

    (58) if -> IF LPAREN . exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)

    exp                            shift and go to state 132
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 109

    (128) functions2 -> ID saveFunction LPAREN parameters . RPAREN vars LCURLY setStartDirection statements return RCURLY

    RPAREN          shift and go to state 146


state 110

    (132) parameters -> paramsAux .

    RPAREN          reduce using rule 132 (parameters -> paramsAux .)


state 111

    (133) parameters -> empty .

    RPAREN          reduce using rule 133 (parameters -> empty .)


state 112

    (134) paramsAux -> INT . saveTypeVar TWOPOINTS ID addParameter nextParam
    (114) saveTypeVar -> .

    TWOPOINTS       reduce using rule 114 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 147

state 113

    (135) paramsAux -> FLOAT . saveTypeVar TWOPOINTS ID addParameter nextParam
    (114) saveTypeVar -> .

    TWOPOINTS       reduce using rule 114 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 148

state 114

    (136) paramsAux -> CHAR . saveTypeVar TWOPOINTS ID addParameter nextParam
    (114) saveTypeVar -> .

    TWOPOINTS       reduce using rule 114 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 149

state 115

    (126) functions1 -> ID saveFunction LPAREN parameters . RPAREN vars LCURLY setStartDirection statements RCURLY

    RPAREN          shift and go to state 150


state 116

    (110) var1 -> ID createArr arr COMMA var1 . addVar
    (113) addVar -> .

    SEMMICOLON      reduce using rule 113 (addVar -> .)

    addVar                         shift and go to state 151

state 117

    (118) arr -> LBRACKET CTEI setArraySize . RBRACKET

    RBRACKET        shift and go to state 152


state 118

    (10) statements -> assign SEMMICOLON statements .

    RCURLY          reduce using rule 10 (statements -> assign SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 10 (statements -> assign SEMMICOLON statements .)
    RETURN          reduce using rule 10 (statements -> assign SEMMICOLON statements .)


state 119

    (11) statements -> functionCall SEMMICOLON statements .

    RCURLY          reduce using rule 11 (statements -> functionCall SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 11 (statements -> functionCall SEMMICOLON statements .)
    RETURN          reduce using rule 11 (statements -> functionCall SEMMICOLON statements .)


state 120

    (12) statements -> read statements SEMMICOLON . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    RETURN          reduce using rule 149 (empty -> .)

    read                           shift and go to state 70
    statements                     shift and go to state 153
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 121

    (13) statements -> write statements SEMMICOLON . statements
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    RETURN          reduce using rule 149 (empty -> .)

    write                          shift and go to state 71
    statements                     shift and go to state 154
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 122

    (18) assign -> ID add_id2 EQUALS . saveOperator exp generateAssignQuad
    (20) assign -> ID add_id2 EQUALS . saveOperator functionCall generateAssignQuad
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    GT              reduce using rule 101 (saveOperator -> .)
    LT              reduce using rule 101 (saveOperator -> .)
    GTE             reduce using rule 101 (saveOperator -> .)
    LTE             reduce using rule 101 (saveOperator -> .)
    NE              reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 155

state 123

    (19) assign -> ID arrStatement EQUALS . saveOperator exp generateAssignQuad
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    GT              reduce using rule 101 (saveOperator -> .)
    LT              reduce using rule 101 (saveOperator -> .)
    GTE             reduce using rule 101 (saveOperator -> .)
    LTE             reduce using rule 101 (saveOperator -> .)
    NE              reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 156

state 124

    (26) functionCall -> ID validateFunctionID functionERA . LPAREN expAux verifyParams RPAREN generateQuadGOSUB

    LPAREN          shift and go to state 157


state 125

    (95) arrStatement -> LBRACKET checkArray . exp generateQuadVER RBRACKET getArrFinalAddress
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)

    exp                            shift and go to state 158
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 126

    (37) read -> READ operatorRead LPAREN . paramReadAux RPAREN
    (40) paramReadAux -> . exp generateQuadREAD
    (41) paramReadAux -> . exp generateQuadREAD COMMA operatorRead paramReadAux
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)

    paramReadAux                   shift and go to state 159
    exp                            shift and go to state 160
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 127

    (44) write -> WRITE writeOperator LPAREN . paramWrite RPAREN
    (45) paramWrite -> . paramWriteAux
    (46) paramWrite -> . empty
    (47) paramWriteAux -> . exp generateQuadPRINT
    (48) paramWriteAux -> . exp generateQuadPRINT COMMA writeOperator paramWriteAux
    (149) empty -> .
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB

    RPAREN          reduce using rule 149 (empty -> .)
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131

    paramWrite                     shift and go to state 161
    paramWriteAux                  shift and go to state 162
    empty                          shift and go to state 163
    exp                            shift and go to state 164
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144

state 128

    (52) for -> FOR forOP assign . TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    TO              shift and go to state 165


state 129

    (18) assign -> ID . add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> ID . arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> ID . add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (23) add_id2 -> .
    (95) arrStatement -> . LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress
    (96) arrStatement -> . empty
    (149) empty -> .

  ! reduce/reduce conflict for EQUALS resolved using rule 23 (add_id2 -> .)
    EQUALS          reduce using rule 23 (add_id2 -> .)
    LBRACKET        shift and go to state 102

  ! EQUALS          [ reduce using rule 149 (empty -> .) ]

    add_id2                        shift and go to state 99
    arrStatement                   shift and go to state 100
    empty                          shift and go to state 103

state 130

    (55) while -> WHILE whileOP LPAREN . exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)

    exp                            shift and go to state 166
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 131

    (92) pexp -> LPAREN . exp RPAREN
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)

    exp                            shift and go to state 167
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 132

    (58) if -> IF LPAREN exp . RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF

    RPAREN          shift and go to state 168


state 133

    (64) exp -> nexp . generateQuadOR
    (65) exp -> nexp . generateQuadOR OR saveOperator nexp
    (66) generateQuadOR -> .

    OR              reduce using rule 66 (generateQuadOR -> .)
    RPAREN          reduce using rule 66 (generateQuadOR -> .)
    RBRACKET        reduce using rule 66 (generateQuadOR -> .)
    COMMA           reduce using rule 66 (generateQuadOR -> .)
    SEMMICOLON      reduce using rule 66 (generateQuadOR -> .)
    TO              reduce using rule 66 (generateQuadOR -> .)

    generateQuadOR                 shift and go to state 169

state 134

    (67) nexp -> compexp . generateQuadAND
    (68) nexp -> compexp . generateQuadAND AND saveOperator compexp
    (69) generateQuadAND -> .

    AND             reduce using rule 69 (generateQuadAND -> .)
    OR              reduce using rule 69 (generateQuadAND -> .)
    RPAREN          reduce using rule 69 (generateQuadAND -> .)
    RBRACKET        reduce using rule 69 (generateQuadAND -> .)
    COMMA           reduce using rule 69 (generateQuadAND -> .)
    SEMMICOLON      reduce using rule 69 (generateQuadAND -> .)
    TO              reduce using rule 69 (generateQuadAND -> .)

    generateQuadAND                shift and go to state 170

state 135

    (70) compexp -> sumexp .
    (72) compexp1 -> sumexp . GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> sumexp . LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> sumexp . GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> sumexp . LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> sumexp . NE saveOperator sumexp generateQuadCOMPARE

    AND             reduce using rule 70 (compexp -> sumexp .)
    OR              reduce using rule 70 (compexp -> sumexp .)
    RPAREN          reduce using rule 70 (compexp -> sumexp .)
    RBRACKET        reduce using rule 70 (compexp -> sumexp .)
    COMMA           reduce using rule 70 (compexp -> sumexp .)
    SEMMICOLON      reduce using rule 70 (compexp -> sumexp .)
    TO              reduce using rule 70 (compexp -> sumexp .)
    GT              shift and go to state 171
    LT              shift and go to state 172
    GTE             shift and go to state 173
    LTE             shift and go to state 174
    NE              shift and go to state 175


state 136

    (71) compexp -> compexp1 . sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)

    sumexp                         shift and go to state 176
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 137

    (78) sumexp -> mulexp .
    (79) sumexp -> mulexp . PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> mulexp . MINUS saveOperator mulexp generateQuadSUM

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    GT              reduce using rule 78 (sumexp -> mulexp .)
    LT              reduce using rule 78 (sumexp -> mulexp .)
    GTE             reduce using rule 78 (sumexp -> mulexp .)
    LTE             reduce using rule 78 (sumexp -> mulexp .)
    NE              reduce using rule 78 (sumexp -> mulexp .)
    AND             reduce using rule 78 (sumexp -> mulexp .)
    OR              reduce using rule 78 (sumexp -> mulexp .)
    RPAREN          reduce using rule 78 (sumexp -> mulexp .)
    RBRACKET        reduce using rule 78 (sumexp -> mulexp .)
    COMMA           reduce using rule 78 (sumexp -> mulexp .)
    SEMMICOLON      reduce using rule 78 (sumexp -> mulexp .)
    TO              reduce using rule 78 (sumexp -> mulexp .)
    ID              reduce using rule 78 (sumexp -> mulexp .)
    CTEI            reduce using rule 78 (sumexp -> mulexp .)
    CTEF            reduce using rule 78 (sumexp -> mulexp .)
    CTEC            reduce using rule 78 (sumexp -> mulexp .)
    CTESTRING       reduce using rule 78 (sumexp -> mulexp .)
    LPAREN          reduce using rule 78 (sumexp -> mulexp .)
    MUL             reduce using rule 78 (sumexp -> mulexp .)
    DIV             reduce using rule 78 (sumexp -> mulexp .)
    PLUS            shift and go to state 177
    MINUS           shift and go to state 178

  ! PLUS            [ reduce using rule 78 (sumexp -> mulexp .) ]
  ! MINUS           [ reduce using rule 78 (sumexp -> mulexp .) ]


state 138

    (82) mulexp -> pexp .
    (83) mulexp -> pexp . MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> pexp . DIV saveOperator pexp generateQuadMUL

  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    PLUS            reduce using rule 82 (mulexp -> pexp .)
    MINUS           reduce using rule 82 (mulexp -> pexp .)
    GT              reduce using rule 82 (mulexp -> pexp .)
    LT              reduce using rule 82 (mulexp -> pexp .)
    GTE             reduce using rule 82 (mulexp -> pexp .)
    LTE             reduce using rule 82 (mulexp -> pexp .)
    NE              reduce using rule 82 (mulexp -> pexp .)
    AND             reduce using rule 82 (mulexp -> pexp .)
    OR              reduce using rule 82 (mulexp -> pexp .)
    RPAREN          reduce using rule 82 (mulexp -> pexp .)
    RBRACKET        reduce using rule 82 (mulexp -> pexp .)
    COMMA           reduce using rule 82 (mulexp -> pexp .)
    SEMMICOLON      reduce using rule 82 (mulexp -> pexp .)
    TO              reduce using rule 82 (mulexp -> pexp .)
    ID              reduce using rule 82 (mulexp -> pexp .)
    CTEI            reduce using rule 82 (mulexp -> pexp .)
    CTEF            reduce using rule 82 (mulexp -> pexp .)
    CTEC            reduce using rule 82 (mulexp -> pexp .)
    CTESTRING       reduce using rule 82 (mulexp -> pexp .)
    LPAREN          reduce using rule 82 (mulexp -> pexp .)
    MUL             shift and go to state 179
    DIV             shift and go to state 180

  ! MUL             [ reduce using rule 82 (mulexp -> pexp .) ]
  ! DIV             [ reduce using rule 82 (mulexp -> pexp .) ]


state 139

    (86) pexp -> ID . add_id2
    (93) pexp -> ID . arrStatement
    (26) functionCall -> ID . validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (23) add_id2 -> .
    (95) arrStatement -> . LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress
    (96) arrStatement -> . empty
    (27) validateFunctionID -> .
    (149) empty -> .

  ! reduce/reduce conflict for LPAREN resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for MUL resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for DIV resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for PLUS resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for GT resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for LT resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for GTE resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for LTE resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for NE resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for AND resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for OR resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for COMMA resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for SEMMICOLON resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for TO resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for ID resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for CTEI resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for CTEF resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for CTEC resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for CTESTRING resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 23 (add_id2 -> .)
    MUL             reduce using rule 23 (add_id2 -> .)
    DIV             reduce using rule 23 (add_id2 -> .)
    PLUS            reduce using rule 23 (add_id2 -> .)
    MINUS           reduce using rule 23 (add_id2 -> .)
    GT              reduce using rule 23 (add_id2 -> .)
    LT              reduce using rule 23 (add_id2 -> .)
    GTE             reduce using rule 23 (add_id2 -> .)
    LTE             reduce using rule 23 (add_id2 -> .)
    NE              reduce using rule 23 (add_id2 -> .)
    AND             reduce using rule 23 (add_id2 -> .)
    OR              reduce using rule 23 (add_id2 -> .)
    RPAREN          reduce using rule 23 (add_id2 -> .)
    RBRACKET        reduce using rule 23 (add_id2 -> .)
    COMMA           reduce using rule 23 (add_id2 -> .)
    SEMMICOLON      reduce using rule 23 (add_id2 -> .)
    TO              reduce using rule 23 (add_id2 -> .)
    ID              reduce using rule 23 (add_id2 -> .)
    CTEI            reduce using rule 23 (add_id2 -> .)
    CTEF            reduce using rule 23 (add_id2 -> .)
    CTEC            reduce using rule 23 (add_id2 -> .)
    CTESTRING       reduce using rule 23 (add_id2 -> .)
    LPAREN          reduce using rule 23 (add_id2 -> .)
    LBRACKET        shift and go to state 102

  ! LPAREN          [ reduce using rule 27 (validateFunctionID -> .) ]
  ! MUL             [ reduce using rule 149 (empty -> .) ]
  ! DIV             [ reduce using rule 149 (empty -> .) ]
  ! PLUS            [ reduce using rule 149 (empty -> .) ]
  ! MINUS           [ reduce using rule 149 (empty -> .) ]
  ! GT              [ reduce using rule 149 (empty -> .) ]
  ! LT              [ reduce using rule 149 (empty -> .) ]
  ! GTE             [ reduce using rule 149 (empty -> .) ]
  ! LTE             [ reduce using rule 149 (empty -> .) ]
  ! NE              [ reduce using rule 149 (empty -> .) ]
  ! AND             [ reduce using rule 149 (empty -> .) ]
  ! OR              [ reduce using rule 149 (empty -> .) ]
  ! RPAREN          [ reduce using rule 149 (empty -> .) ]
  ! RBRACKET        [ reduce using rule 149 (empty -> .) ]
  ! COMMA           [ reduce using rule 149 (empty -> .) ]
  ! SEMMICOLON      [ reduce using rule 149 (empty -> .) ]
  ! TO              [ reduce using rule 149 (empty -> .) ]
  ! ID              [ reduce using rule 149 (empty -> .) ]
  ! CTEI            [ reduce using rule 149 (empty -> .) ]
  ! CTEF            [ reduce using rule 149 (empty -> .) ]
  ! CTEC            [ reduce using rule 149 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 149 (empty -> .) ]
  ! LPAREN          [ reduce using rule 149 (empty -> .) ]

    add_id2                        shift and go to state 181
    arrStatement                   shift and go to state 182
    validateFunctionID             shift and go to state 101
    empty                          shift and go to state 103

state 140

    (87) pexp -> CTEI . saveCTE
    (100) saveCTE -> .

    MUL             reduce using rule 100 (saveCTE -> .)
    DIV             reduce using rule 100 (saveCTE -> .)
    PLUS            reduce using rule 100 (saveCTE -> .)
    MINUS           reduce using rule 100 (saveCTE -> .)
    GT              reduce using rule 100 (saveCTE -> .)
    LT              reduce using rule 100 (saveCTE -> .)
    GTE             reduce using rule 100 (saveCTE -> .)
    LTE             reduce using rule 100 (saveCTE -> .)
    NE              reduce using rule 100 (saveCTE -> .)
    AND             reduce using rule 100 (saveCTE -> .)
    OR              reduce using rule 100 (saveCTE -> .)
    RPAREN          reduce using rule 100 (saveCTE -> .)
    RBRACKET        reduce using rule 100 (saveCTE -> .)
    COMMA           reduce using rule 100 (saveCTE -> .)
    SEMMICOLON      reduce using rule 100 (saveCTE -> .)
    TO              reduce using rule 100 (saveCTE -> .)
    ID              reduce using rule 100 (saveCTE -> .)
    CTEI            reduce using rule 100 (saveCTE -> .)
    CTEF            reduce using rule 100 (saveCTE -> .)
    CTEC            reduce using rule 100 (saveCTE -> .)
    CTESTRING       reduce using rule 100 (saveCTE -> .)
    LPAREN          reduce using rule 100 (saveCTE -> .)

    saveCTE                        shift and go to state 183

state 141

    (88) pexp -> CTEF . saveCTE
    (100) saveCTE -> .

    MUL             reduce using rule 100 (saveCTE -> .)
    DIV             reduce using rule 100 (saveCTE -> .)
    PLUS            reduce using rule 100 (saveCTE -> .)
    MINUS           reduce using rule 100 (saveCTE -> .)
    GT              reduce using rule 100 (saveCTE -> .)
    LT              reduce using rule 100 (saveCTE -> .)
    GTE             reduce using rule 100 (saveCTE -> .)
    LTE             reduce using rule 100 (saveCTE -> .)
    NE              reduce using rule 100 (saveCTE -> .)
    AND             reduce using rule 100 (saveCTE -> .)
    OR              reduce using rule 100 (saveCTE -> .)
    RPAREN          reduce using rule 100 (saveCTE -> .)
    RBRACKET        reduce using rule 100 (saveCTE -> .)
    COMMA           reduce using rule 100 (saveCTE -> .)
    SEMMICOLON      reduce using rule 100 (saveCTE -> .)
    TO              reduce using rule 100 (saveCTE -> .)
    ID              reduce using rule 100 (saveCTE -> .)
    CTEI            reduce using rule 100 (saveCTE -> .)
    CTEF            reduce using rule 100 (saveCTE -> .)
    CTEC            reduce using rule 100 (saveCTE -> .)
    CTESTRING       reduce using rule 100 (saveCTE -> .)
    LPAREN          reduce using rule 100 (saveCTE -> .)

    saveCTE                        shift and go to state 184

state 142

    (89) pexp -> CTEC . saveCTE
    (100) saveCTE -> .

    MUL             reduce using rule 100 (saveCTE -> .)
    DIV             reduce using rule 100 (saveCTE -> .)
    PLUS            reduce using rule 100 (saveCTE -> .)
    MINUS           reduce using rule 100 (saveCTE -> .)
    GT              reduce using rule 100 (saveCTE -> .)
    LT              reduce using rule 100 (saveCTE -> .)
    GTE             reduce using rule 100 (saveCTE -> .)
    LTE             reduce using rule 100 (saveCTE -> .)
    NE              reduce using rule 100 (saveCTE -> .)
    AND             reduce using rule 100 (saveCTE -> .)
    OR              reduce using rule 100 (saveCTE -> .)
    RPAREN          reduce using rule 100 (saveCTE -> .)
    RBRACKET        reduce using rule 100 (saveCTE -> .)
    COMMA           reduce using rule 100 (saveCTE -> .)
    SEMMICOLON      reduce using rule 100 (saveCTE -> .)
    TO              reduce using rule 100 (saveCTE -> .)
    ID              reduce using rule 100 (saveCTE -> .)
    CTEI            reduce using rule 100 (saveCTE -> .)
    CTEF            reduce using rule 100 (saveCTE -> .)
    CTEC            reduce using rule 100 (saveCTE -> .)
    CTESTRING       reduce using rule 100 (saveCTE -> .)
    LPAREN          reduce using rule 100 (saveCTE -> .)

    saveCTE                        shift and go to state 185

state 143

    (90) pexp -> CTESTRING . saveCTE
    (100) saveCTE -> .

    MUL             reduce using rule 100 (saveCTE -> .)
    DIV             reduce using rule 100 (saveCTE -> .)
    PLUS            reduce using rule 100 (saveCTE -> .)
    MINUS           reduce using rule 100 (saveCTE -> .)
    GT              reduce using rule 100 (saveCTE -> .)
    LT              reduce using rule 100 (saveCTE -> .)
    GTE             reduce using rule 100 (saveCTE -> .)
    LTE             reduce using rule 100 (saveCTE -> .)
    NE              reduce using rule 100 (saveCTE -> .)
    AND             reduce using rule 100 (saveCTE -> .)
    OR              reduce using rule 100 (saveCTE -> .)
    RPAREN          reduce using rule 100 (saveCTE -> .)
    RBRACKET        reduce using rule 100 (saveCTE -> .)
    COMMA           reduce using rule 100 (saveCTE -> .)
    SEMMICOLON      reduce using rule 100 (saveCTE -> .)
    TO              reduce using rule 100 (saveCTE -> .)
    ID              reduce using rule 100 (saveCTE -> .)
    CTEI            reduce using rule 100 (saveCTE -> .)
    CTEF            reduce using rule 100 (saveCTE -> .)
    CTEC            reduce using rule 100 (saveCTE -> .)
    CTESTRING       reduce using rule 100 (saveCTE -> .)
    LPAREN          reduce using rule 100 (saveCTE -> .)

    saveCTE                        shift and go to state 186

state 144

    (91) pexp -> functionCall .

    MUL             reduce using rule 91 (pexp -> functionCall .)
    DIV             reduce using rule 91 (pexp -> functionCall .)
    PLUS            reduce using rule 91 (pexp -> functionCall .)
    MINUS           reduce using rule 91 (pexp -> functionCall .)
    GT              reduce using rule 91 (pexp -> functionCall .)
    LT              reduce using rule 91 (pexp -> functionCall .)
    GTE             reduce using rule 91 (pexp -> functionCall .)
    LTE             reduce using rule 91 (pexp -> functionCall .)
    NE              reduce using rule 91 (pexp -> functionCall .)
    AND             reduce using rule 91 (pexp -> functionCall .)
    OR              reduce using rule 91 (pexp -> functionCall .)
    RPAREN          reduce using rule 91 (pexp -> functionCall .)
    RBRACKET        reduce using rule 91 (pexp -> functionCall .)
    COMMA           reduce using rule 91 (pexp -> functionCall .)
    SEMMICOLON      reduce using rule 91 (pexp -> functionCall .)
    TO              reduce using rule 91 (pexp -> functionCall .)
    ID              reduce using rule 91 (pexp -> functionCall .)
    CTEI            reduce using rule 91 (pexp -> functionCall .)
    CTEF            reduce using rule 91 (pexp -> functionCall .)
    CTEC            reduce using rule 91 (pexp -> functionCall .)
    CTESTRING       reduce using rule 91 (pexp -> functionCall .)
    LPAREN          reduce using rule 91 (pexp -> functionCall .)


state 145

    (94) pexp -> empty .

    MUL             reduce using rule 94 (pexp -> empty .)
    DIV             reduce using rule 94 (pexp -> empty .)
    PLUS            reduce using rule 94 (pexp -> empty .)
    MINUS           reduce using rule 94 (pexp -> empty .)
    GT              reduce using rule 94 (pexp -> empty .)
    LT              reduce using rule 94 (pexp -> empty .)
    GTE             reduce using rule 94 (pexp -> empty .)
    LTE             reduce using rule 94 (pexp -> empty .)
    NE              reduce using rule 94 (pexp -> empty .)
    AND             reduce using rule 94 (pexp -> empty .)
    OR              reduce using rule 94 (pexp -> empty .)
    RPAREN          reduce using rule 94 (pexp -> empty .)
    RBRACKET        reduce using rule 94 (pexp -> empty .)
    COMMA           reduce using rule 94 (pexp -> empty .)
    SEMMICOLON      reduce using rule 94 (pexp -> empty .)
    TO              reduce using rule 94 (pexp -> empty .)
    ID              reduce using rule 94 (pexp -> empty .)
    CTEI            reduce using rule 94 (pexp -> empty .)
    CTEF            reduce using rule 94 (pexp -> empty .)
    CTEC            reduce using rule 94 (pexp -> empty .)
    CTESTRING       reduce using rule 94 (pexp -> empty .)
    LPAREN          reduce using rule 94 (pexp -> empty .)


state 146

    (128) functions2 -> ID saveFunction LPAREN parameters RPAREN . vars LCURLY setStartDirection statements return RCURLY
    (102) vars -> . var
    (103) vars -> . empty
    (104) var -> . VARS var2
    (149) empty -> .

    VARS            shift and go to state 12
    LCURLY          reduce using rule 149 (empty -> .)

    vars                           shift and go to state 187
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 147

    (134) paramsAux -> INT saveTypeVar . TWOPOINTS ID addParameter nextParam

    TWOPOINTS       shift and go to state 188


state 148

    (135) paramsAux -> FLOAT saveTypeVar . TWOPOINTS ID addParameter nextParam

    TWOPOINTS       shift and go to state 189


state 149

    (136) paramsAux -> CHAR saveTypeVar . TWOPOINTS ID addParameter nextParam

    TWOPOINTS       shift and go to state 190


state 150

    (126) functions1 -> ID saveFunction LPAREN parameters RPAREN . vars LCURLY setStartDirection statements RCURLY
    (102) vars -> . var
    (103) vars -> . empty
    (104) var -> . VARS var2
    (149) empty -> .

    VARS            shift and go to state 12
    LCURLY          reduce using rule 149 (empty -> .)

    vars                           shift and go to state 191
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 151

    (110) var1 -> ID createArr arr COMMA var1 addVar .

    SEMMICOLON      reduce using rule 110 (var1 -> ID createArr arr COMMA var1 addVar .)


state 152

    (118) arr -> LBRACKET CTEI setArraySize RBRACKET .

    COMMA           reduce using rule 118 (arr -> LBRACKET CTEI setArraySize RBRACKET .)
    SEMMICOLON      reduce using rule 118 (arr -> LBRACKET CTEI setArraySize RBRACKET .)


state 153

    (12) statements -> read statements SEMMICOLON statements .

    RCURLY          reduce using rule 12 (statements -> read statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 12 (statements -> read statements SEMMICOLON statements .)
    RETURN          reduce using rule 12 (statements -> read statements SEMMICOLON statements .)


state 154

    (13) statements -> write statements SEMMICOLON statements .

    RCURLY          reduce using rule 13 (statements -> write statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 13 (statements -> write statements SEMMICOLON statements .)
    RETURN          reduce using rule 13 (statements -> write statements SEMMICOLON statements .)


state 155

    (18) assign -> ID add_id2 EQUALS saveOperator . exp generateAssignQuad
    (20) assign -> ID add_id2 EQUALS saveOperator . functionCall generateAssignQuad
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (149) empty -> .

    ID              shift and go to state 192
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)

    exp                            shift and go to state 193
    functionCall                   shift and go to state 194
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    empty                          shift and go to state 145

state 156

    (19) assign -> ID arrStatement EQUALS saveOperator . exp generateAssignQuad
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)

    exp                            shift and go to state 195
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 157

    (26) functionCall -> ID validateFunctionID functionERA LPAREN . expAux verifyParams RPAREN generateQuadGOSUB
    (31) expAux -> . exp generateQuadPARAM paramsCount
    (32) expAux -> . exp generateQuadPARAM COMMA paramsCount expAux
    (33) expAux -> . empty
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (149) empty -> .
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB

    RPAREN          reduce using rule 149 (empty -> .)
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131

    expAux                         shift and go to state 196
    exp                            shift and go to state 197
    empty                          shift and go to state 198
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144

state 158

    (95) arrStatement -> LBRACKET checkArray exp . generateQuadVER RBRACKET getArrFinalAddress
    (99) generateQuadVER -> .

    RBRACKET        reduce using rule 99 (generateQuadVER -> .)

    generateQuadVER                shift and go to state 199

state 159

    (37) read -> READ operatorRead LPAREN paramReadAux . RPAREN

    RPAREN          shift and go to state 200


state 160

    (40) paramReadAux -> exp . generateQuadREAD
    (41) paramReadAux -> exp . generateQuadREAD COMMA operatorRead paramReadAux
    (43) generateQuadREAD -> .

    COMMA           reduce using rule 43 (generateQuadREAD -> .)
    RPAREN          reduce using rule 43 (generateQuadREAD -> .)

    generateQuadREAD               shift and go to state 201

state 161

    (44) write -> WRITE writeOperator LPAREN paramWrite . RPAREN

    RPAREN          shift and go to state 202


state 162

    (45) paramWrite -> paramWriteAux .

    RPAREN          reduce using rule 45 (paramWrite -> paramWriteAux .)


state 163

    (46) paramWrite -> empty .
    (94) pexp -> empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 46 (paramWrite -> empty .)
    RPAREN          reduce using rule 46 (paramWrite -> empty .)
    MUL             reduce using rule 94 (pexp -> empty .)
    DIV             reduce using rule 94 (pexp -> empty .)
    PLUS            reduce using rule 94 (pexp -> empty .)
    MINUS           reduce using rule 94 (pexp -> empty .)
    GT              reduce using rule 94 (pexp -> empty .)
    LT              reduce using rule 94 (pexp -> empty .)
    GTE             reduce using rule 94 (pexp -> empty .)
    LTE             reduce using rule 94 (pexp -> empty .)
    NE              reduce using rule 94 (pexp -> empty .)
    AND             reduce using rule 94 (pexp -> empty .)
    OR              reduce using rule 94 (pexp -> empty .)
    COMMA           reduce using rule 94 (pexp -> empty .)

  ! RPAREN          [ reduce using rule 94 (pexp -> empty .) ]


state 164

    (47) paramWriteAux -> exp . generateQuadPRINT
    (48) paramWriteAux -> exp . generateQuadPRINT COMMA writeOperator paramWriteAux
    (50) generateQuadPRINT -> .

    COMMA           reduce using rule 50 (generateQuadPRINT -> .)
    RPAREN          reduce using rule 50 (generateQuadPRINT -> .)

    generateQuadPRINT              shift and go to state 203

state 165

    (52) for -> FOR forOP assign TO . CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    CTEI            shift and go to state 204


state 166

    (55) while -> WHILE whileOP LPAREN exp . RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    RPAREN          shift and go to state 205


state 167

    (92) pexp -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 206


state 168

    (58) if -> IF LPAREN exp RPAREN . generateQuadIF THEN LCURLY statements RCURLY else endIF
    (61) generateQuadIF -> .

    THEN            reduce using rule 61 (generateQuadIF -> .)

    generateQuadIF                 shift and go to state 207

state 169

    (64) exp -> nexp generateQuadOR .
    (65) exp -> nexp generateQuadOR . OR saveOperator nexp

    RPAREN          reduce using rule 64 (exp -> nexp generateQuadOR .)
    RBRACKET        reduce using rule 64 (exp -> nexp generateQuadOR .)
    COMMA           reduce using rule 64 (exp -> nexp generateQuadOR .)
    SEMMICOLON      reduce using rule 64 (exp -> nexp generateQuadOR .)
    TO              reduce using rule 64 (exp -> nexp generateQuadOR .)
    OR              shift and go to state 208


state 170

    (67) nexp -> compexp generateQuadAND .
    (68) nexp -> compexp generateQuadAND . AND saveOperator compexp

    OR              reduce using rule 67 (nexp -> compexp generateQuadAND .)
    RPAREN          reduce using rule 67 (nexp -> compexp generateQuadAND .)
    RBRACKET        reduce using rule 67 (nexp -> compexp generateQuadAND .)
    COMMA           reduce using rule 67 (nexp -> compexp generateQuadAND .)
    SEMMICOLON      reduce using rule 67 (nexp -> compexp generateQuadAND .)
    TO              reduce using rule 67 (nexp -> compexp generateQuadAND .)
    AND             shift and go to state 209


state 171

    (72) compexp1 -> sumexp GT . saveOperator sumexp generateQuadCOMPARE
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    RPAREN          reduce using rule 101 (saveOperator -> .)
    RBRACKET        reduce using rule 101 (saveOperator -> .)
    COMMA           reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 210

state 172

    (73) compexp1 -> sumexp LT . saveOperator sumexp generateQuadCOMPARE
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    RPAREN          reduce using rule 101 (saveOperator -> .)
    RBRACKET        reduce using rule 101 (saveOperator -> .)
    COMMA           reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 211

state 173

    (74) compexp1 -> sumexp GTE . saveOperator sumexp generateQuadCOMPARE
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    RPAREN          reduce using rule 101 (saveOperator -> .)
    RBRACKET        reduce using rule 101 (saveOperator -> .)
    COMMA           reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 212

state 174

    (75) compexp1 -> sumexp LTE . saveOperator sumexp generateQuadCOMPARE
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    RPAREN          reduce using rule 101 (saveOperator -> .)
    RBRACKET        reduce using rule 101 (saveOperator -> .)
    COMMA           reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 213

state 175

    (76) compexp1 -> sumexp NE . saveOperator sumexp generateQuadCOMPARE
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    RPAREN          reduce using rule 101 (saveOperator -> .)
    RBRACKET        reduce using rule 101 (saveOperator -> .)
    COMMA           reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 214

state 176

    (71) compexp -> compexp1 sumexp .

    AND             reduce using rule 71 (compexp -> compexp1 sumexp .)
    OR              reduce using rule 71 (compexp -> compexp1 sumexp .)
    RPAREN          reduce using rule 71 (compexp -> compexp1 sumexp .)
    RBRACKET        reduce using rule 71 (compexp -> compexp1 sumexp .)
    COMMA           reduce using rule 71 (compexp -> compexp1 sumexp .)
    SEMMICOLON      reduce using rule 71 (compexp -> compexp1 sumexp .)
    TO              reduce using rule 71 (compexp -> compexp1 sumexp .)


state 177

    (79) sumexp -> mulexp PLUS . saveOperator mulexp generateQuadSUM
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)
    GT              reduce using rule 101 (saveOperator -> .)
    LT              reduce using rule 101 (saveOperator -> .)
    GTE             reduce using rule 101 (saveOperator -> .)
    LTE             reduce using rule 101 (saveOperator -> .)
    NE              reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    RPAREN          reduce using rule 101 (saveOperator -> .)
    RBRACKET        reduce using rule 101 (saveOperator -> .)
    COMMA           reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 215

state 178

    (80) sumexp -> mulexp MINUS . saveOperator mulexp generateQuadSUM
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)
    GT              reduce using rule 101 (saveOperator -> .)
    LT              reduce using rule 101 (saveOperator -> .)
    GTE             reduce using rule 101 (saveOperator -> .)
    LTE             reduce using rule 101 (saveOperator -> .)
    NE              reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    RPAREN          reduce using rule 101 (saveOperator -> .)
    RBRACKET        reduce using rule 101 (saveOperator -> .)
    COMMA           reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 216

state 179

    (83) mulexp -> pexp MUL . saveOperator pexp generateQuadMUL
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)
    GT              reduce using rule 101 (saveOperator -> .)
    LT              reduce using rule 101 (saveOperator -> .)
    GTE             reduce using rule 101 (saveOperator -> .)
    LTE             reduce using rule 101 (saveOperator -> .)
    NE              reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    RPAREN          reduce using rule 101 (saveOperator -> .)
    RBRACKET        reduce using rule 101 (saveOperator -> .)
    COMMA           reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 217

state 180

    (84) mulexp -> pexp DIV . saveOperator pexp generateQuadMUL
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)
    GT              reduce using rule 101 (saveOperator -> .)
    LT              reduce using rule 101 (saveOperator -> .)
    GTE             reduce using rule 101 (saveOperator -> .)
    LTE             reduce using rule 101 (saveOperator -> .)
    NE              reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    RPAREN          reduce using rule 101 (saveOperator -> .)
    RBRACKET        reduce using rule 101 (saveOperator -> .)
    COMMA           reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 218

state 181

    (86) pexp -> ID add_id2 .

    MUL             reduce using rule 86 (pexp -> ID add_id2 .)
    DIV             reduce using rule 86 (pexp -> ID add_id2 .)
    PLUS            reduce using rule 86 (pexp -> ID add_id2 .)
    MINUS           reduce using rule 86 (pexp -> ID add_id2 .)
    GT              reduce using rule 86 (pexp -> ID add_id2 .)
    LT              reduce using rule 86 (pexp -> ID add_id2 .)
    GTE             reduce using rule 86 (pexp -> ID add_id2 .)
    LTE             reduce using rule 86 (pexp -> ID add_id2 .)
    NE              reduce using rule 86 (pexp -> ID add_id2 .)
    AND             reduce using rule 86 (pexp -> ID add_id2 .)
    OR              reduce using rule 86 (pexp -> ID add_id2 .)
    RPAREN          reduce using rule 86 (pexp -> ID add_id2 .)
    RBRACKET        reduce using rule 86 (pexp -> ID add_id2 .)
    COMMA           reduce using rule 86 (pexp -> ID add_id2 .)
    SEMMICOLON      reduce using rule 86 (pexp -> ID add_id2 .)
    TO              reduce using rule 86 (pexp -> ID add_id2 .)
    ID              reduce using rule 86 (pexp -> ID add_id2 .)
    CTEI            reduce using rule 86 (pexp -> ID add_id2 .)
    CTEF            reduce using rule 86 (pexp -> ID add_id2 .)
    CTEC            reduce using rule 86 (pexp -> ID add_id2 .)
    CTESTRING       reduce using rule 86 (pexp -> ID add_id2 .)
    LPAREN          reduce using rule 86 (pexp -> ID add_id2 .)


state 182

    (93) pexp -> ID arrStatement .

    MUL             reduce using rule 93 (pexp -> ID arrStatement .)
    DIV             reduce using rule 93 (pexp -> ID arrStatement .)
    PLUS            reduce using rule 93 (pexp -> ID arrStatement .)
    MINUS           reduce using rule 93 (pexp -> ID arrStatement .)
    GT              reduce using rule 93 (pexp -> ID arrStatement .)
    LT              reduce using rule 93 (pexp -> ID arrStatement .)
    GTE             reduce using rule 93 (pexp -> ID arrStatement .)
    LTE             reduce using rule 93 (pexp -> ID arrStatement .)
    NE              reduce using rule 93 (pexp -> ID arrStatement .)
    AND             reduce using rule 93 (pexp -> ID arrStatement .)
    OR              reduce using rule 93 (pexp -> ID arrStatement .)
    RPAREN          reduce using rule 93 (pexp -> ID arrStatement .)
    RBRACKET        reduce using rule 93 (pexp -> ID arrStatement .)
    COMMA           reduce using rule 93 (pexp -> ID arrStatement .)
    SEMMICOLON      reduce using rule 93 (pexp -> ID arrStatement .)
    TO              reduce using rule 93 (pexp -> ID arrStatement .)
    ID              reduce using rule 93 (pexp -> ID arrStatement .)
    CTEI            reduce using rule 93 (pexp -> ID arrStatement .)
    CTEF            reduce using rule 93 (pexp -> ID arrStatement .)
    CTEC            reduce using rule 93 (pexp -> ID arrStatement .)
    CTESTRING       reduce using rule 93 (pexp -> ID arrStatement .)
    LPAREN          reduce using rule 93 (pexp -> ID arrStatement .)


state 183

    (87) pexp -> CTEI saveCTE .

    MUL             reduce using rule 87 (pexp -> CTEI saveCTE .)
    DIV             reduce using rule 87 (pexp -> CTEI saveCTE .)
    PLUS            reduce using rule 87 (pexp -> CTEI saveCTE .)
    MINUS           reduce using rule 87 (pexp -> CTEI saveCTE .)
    GT              reduce using rule 87 (pexp -> CTEI saveCTE .)
    LT              reduce using rule 87 (pexp -> CTEI saveCTE .)
    GTE             reduce using rule 87 (pexp -> CTEI saveCTE .)
    LTE             reduce using rule 87 (pexp -> CTEI saveCTE .)
    NE              reduce using rule 87 (pexp -> CTEI saveCTE .)
    AND             reduce using rule 87 (pexp -> CTEI saveCTE .)
    OR              reduce using rule 87 (pexp -> CTEI saveCTE .)
    RPAREN          reduce using rule 87 (pexp -> CTEI saveCTE .)
    RBRACKET        reduce using rule 87 (pexp -> CTEI saveCTE .)
    COMMA           reduce using rule 87 (pexp -> CTEI saveCTE .)
    SEMMICOLON      reduce using rule 87 (pexp -> CTEI saveCTE .)
    TO              reduce using rule 87 (pexp -> CTEI saveCTE .)
    ID              reduce using rule 87 (pexp -> CTEI saveCTE .)
    CTEI            reduce using rule 87 (pexp -> CTEI saveCTE .)
    CTEF            reduce using rule 87 (pexp -> CTEI saveCTE .)
    CTEC            reduce using rule 87 (pexp -> CTEI saveCTE .)
    CTESTRING       reduce using rule 87 (pexp -> CTEI saveCTE .)
    LPAREN          reduce using rule 87 (pexp -> CTEI saveCTE .)


state 184

    (88) pexp -> CTEF saveCTE .

    MUL             reduce using rule 88 (pexp -> CTEF saveCTE .)
    DIV             reduce using rule 88 (pexp -> CTEF saveCTE .)
    PLUS            reduce using rule 88 (pexp -> CTEF saveCTE .)
    MINUS           reduce using rule 88 (pexp -> CTEF saveCTE .)
    GT              reduce using rule 88 (pexp -> CTEF saveCTE .)
    LT              reduce using rule 88 (pexp -> CTEF saveCTE .)
    GTE             reduce using rule 88 (pexp -> CTEF saveCTE .)
    LTE             reduce using rule 88 (pexp -> CTEF saveCTE .)
    NE              reduce using rule 88 (pexp -> CTEF saveCTE .)
    AND             reduce using rule 88 (pexp -> CTEF saveCTE .)
    OR              reduce using rule 88 (pexp -> CTEF saveCTE .)
    RPAREN          reduce using rule 88 (pexp -> CTEF saveCTE .)
    RBRACKET        reduce using rule 88 (pexp -> CTEF saveCTE .)
    COMMA           reduce using rule 88 (pexp -> CTEF saveCTE .)
    SEMMICOLON      reduce using rule 88 (pexp -> CTEF saveCTE .)
    TO              reduce using rule 88 (pexp -> CTEF saveCTE .)
    ID              reduce using rule 88 (pexp -> CTEF saveCTE .)
    CTEI            reduce using rule 88 (pexp -> CTEF saveCTE .)
    CTEF            reduce using rule 88 (pexp -> CTEF saveCTE .)
    CTEC            reduce using rule 88 (pexp -> CTEF saveCTE .)
    CTESTRING       reduce using rule 88 (pexp -> CTEF saveCTE .)
    LPAREN          reduce using rule 88 (pexp -> CTEF saveCTE .)


state 185

    (89) pexp -> CTEC saveCTE .

    MUL             reduce using rule 89 (pexp -> CTEC saveCTE .)
    DIV             reduce using rule 89 (pexp -> CTEC saveCTE .)
    PLUS            reduce using rule 89 (pexp -> CTEC saveCTE .)
    MINUS           reduce using rule 89 (pexp -> CTEC saveCTE .)
    GT              reduce using rule 89 (pexp -> CTEC saveCTE .)
    LT              reduce using rule 89 (pexp -> CTEC saveCTE .)
    GTE             reduce using rule 89 (pexp -> CTEC saveCTE .)
    LTE             reduce using rule 89 (pexp -> CTEC saveCTE .)
    NE              reduce using rule 89 (pexp -> CTEC saveCTE .)
    AND             reduce using rule 89 (pexp -> CTEC saveCTE .)
    OR              reduce using rule 89 (pexp -> CTEC saveCTE .)
    RPAREN          reduce using rule 89 (pexp -> CTEC saveCTE .)
    RBRACKET        reduce using rule 89 (pexp -> CTEC saveCTE .)
    COMMA           reduce using rule 89 (pexp -> CTEC saveCTE .)
    SEMMICOLON      reduce using rule 89 (pexp -> CTEC saveCTE .)
    TO              reduce using rule 89 (pexp -> CTEC saveCTE .)
    ID              reduce using rule 89 (pexp -> CTEC saveCTE .)
    CTEI            reduce using rule 89 (pexp -> CTEC saveCTE .)
    CTEF            reduce using rule 89 (pexp -> CTEC saveCTE .)
    CTEC            reduce using rule 89 (pexp -> CTEC saveCTE .)
    CTESTRING       reduce using rule 89 (pexp -> CTEC saveCTE .)
    LPAREN          reduce using rule 89 (pexp -> CTEC saveCTE .)


state 186

    (90) pexp -> CTESTRING saveCTE .

    MUL             reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    DIV             reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    PLUS            reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    MINUS           reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    GT              reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    LT              reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    GTE             reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    LTE             reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    NE              reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    AND             reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    OR              reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    RPAREN          reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    RBRACKET        reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    COMMA           reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    SEMMICOLON      reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    TO              reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    ID              reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    CTEI            reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    CTEF            reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    CTEC            reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    CTESTRING       reduce using rule 90 (pexp -> CTESTRING saveCTE .)
    LPAREN          reduce using rule 90 (pexp -> CTESTRING saveCTE .)


state 187

    (128) functions2 -> ID saveFunction LPAREN parameters RPAREN vars . LCURLY setStartDirection statements return RCURLY

    LCURLY          shift and go to state 219


state 188

    (134) paramsAux -> INT saveTypeVar TWOPOINTS . ID addParameter nextParam

    ID              shift and go to state 220


state 189

    (135) paramsAux -> FLOAT saveTypeVar TWOPOINTS . ID addParameter nextParam

    ID              shift and go to state 221


state 190

    (136) paramsAux -> CHAR saveTypeVar TWOPOINTS . ID addParameter nextParam

    ID              shift and go to state 222


state 191

    (126) functions1 -> ID saveFunction LPAREN parameters RPAREN vars . LCURLY setStartDirection statements RCURLY

    LCURLY          shift and go to state 223


state 192

    (26) functionCall -> ID . validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (86) pexp -> ID . add_id2
    (93) pexp -> ID . arrStatement
    (27) validateFunctionID -> .
    (23) add_id2 -> .
    (95) arrStatement -> . LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress
    (96) arrStatement -> . empty
    (149) empty -> .

  ! reduce/reduce conflict for MUL resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for DIV resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for PLUS resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for MINUS resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for GT resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for LT resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for GTE resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for LTE resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for NE resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for AND resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for OR resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for SEMMICOLON resolved using rule 23 (add_id2 -> .)
  ! reduce/reduce conflict for TO resolved using rule 23 (add_id2 -> .)
    LPAREN          reduce using rule 27 (validateFunctionID -> .)
    MUL             reduce using rule 23 (add_id2 -> .)
    DIV             reduce using rule 23 (add_id2 -> .)
    PLUS            reduce using rule 23 (add_id2 -> .)
    MINUS           reduce using rule 23 (add_id2 -> .)
    GT              reduce using rule 23 (add_id2 -> .)
    LT              reduce using rule 23 (add_id2 -> .)
    GTE             reduce using rule 23 (add_id2 -> .)
    LTE             reduce using rule 23 (add_id2 -> .)
    NE              reduce using rule 23 (add_id2 -> .)
    AND             reduce using rule 23 (add_id2 -> .)
    OR              reduce using rule 23 (add_id2 -> .)
    SEMMICOLON      reduce using rule 23 (add_id2 -> .)
    TO              reduce using rule 23 (add_id2 -> .)
    LBRACKET        shift and go to state 102

  ! MUL             [ reduce using rule 149 (empty -> .) ]
  ! DIV             [ reduce using rule 149 (empty -> .) ]
  ! PLUS            [ reduce using rule 149 (empty -> .) ]
  ! MINUS           [ reduce using rule 149 (empty -> .) ]
  ! GT              [ reduce using rule 149 (empty -> .) ]
  ! LT              [ reduce using rule 149 (empty -> .) ]
  ! GTE             [ reduce using rule 149 (empty -> .) ]
  ! LTE             [ reduce using rule 149 (empty -> .) ]
  ! NE              [ reduce using rule 149 (empty -> .) ]
  ! AND             [ reduce using rule 149 (empty -> .) ]
  ! OR              [ reduce using rule 149 (empty -> .) ]
  ! SEMMICOLON      [ reduce using rule 149 (empty -> .) ]
  ! TO              [ reduce using rule 149 (empty -> .) ]

    validateFunctionID             shift and go to state 101
    add_id2                        shift and go to state 181
    arrStatement                   shift and go to state 182
    empty                          shift and go to state 103

state 193

    (18) assign -> ID add_id2 EQUALS saveOperator exp . generateAssignQuad
    (21) generateAssignQuad -> .

    SEMMICOLON      reduce using rule 21 (generateAssignQuad -> .)
    TO              reduce using rule 21 (generateAssignQuad -> .)

    generateAssignQuad             shift and go to state 224

state 194

    (20) assign -> ID add_id2 EQUALS saveOperator functionCall . generateAssignQuad
    (91) pexp -> functionCall .
    (21) generateAssignQuad -> .

  ! reduce/reduce conflict for SEMMICOLON resolved using rule 21 (generateAssignQuad -> .)
  ! reduce/reduce conflict for TO resolved using rule 21 (generateAssignQuad -> .)
    MUL             reduce using rule 91 (pexp -> functionCall .)
    DIV             reduce using rule 91 (pexp -> functionCall .)
    PLUS            reduce using rule 91 (pexp -> functionCall .)
    MINUS           reduce using rule 91 (pexp -> functionCall .)
    GT              reduce using rule 91 (pexp -> functionCall .)
    LT              reduce using rule 91 (pexp -> functionCall .)
    GTE             reduce using rule 91 (pexp -> functionCall .)
    LTE             reduce using rule 91 (pexp -> functionCall .)
    NE              reduce using rule 91 (pexp -> functionCall .)
    AND             reduce using rule 91 (pexp -> functionCall .)
    OR              reduce using rule 91 (pexp -> functionCall .)
    SEMMICOLON      reduce using rule 21 (generateAssignQuad -> .)
    TO              reduce using rule 21 (generateAssignQuad -> .)

  ! SEMMICOLON      [ reduce using rule 91 (pexp -> functionCall .) ]
  ! TO              [ reduce using rule 91 (pexp -> functionCall .) ]

    generateAssignQuad             shift and go to state 225

state 195

    (19) assign -> ID arrStatement EQUALS saveOperator exp . generateAssignQuad
    (21) generateAssignQuad -> .

    SEMMICOLON      reduce using rule 21 (generateAssignQuad -> .)
    TO              reduce using rule 21 (generateAssignQuad -> .)

    generateAssignQuad             shift and go to state 226

state 196

    (26) functionCall -> ID validateFunctionID functionERA LPAREN expAux . verifyParams RPAREN generateQuadGOSUB
    (28) verifyParams -> .

    RPAREN          reduce using rule 28 (verifyParams -> .)

    verifyParams                   shift and go to state 227

state 197

    (31) expAux -> exp . generateQuadPARAM paramsCount
    (32) expAux -> exp . generateQuadPARAM COMMA paramsCount expAux
    (30) generateQuadPARAM -> .

    COMMA           reduce using rule 30 (generateQuadPARAM -> .)
    RPAREN          reduce using rule 30 (generateQuadPARAM -> .)

    generateQuadPARAM              shift and go to state 228

state 198

    (33) expAux -> empty .
    (94) pexp -> empty .

  ! reduce/reduce conflict for RPAREN resolved using rule 33 (expAux -> empty .)
    RPAREN          reduce using rule 33 (expAux -> empty .)
    MUL             reduce using rule 94 (pexp -> empty .)
    DIV             reduce using rule 94 (pexp -> empty .)
    PLUS            reduce using rule 94 (pexp -> empty .)
    MINUS           reduce using rule 94 (pexp -> empty .)
    GT              reduce using rule 94 (pexp -> empty .)
    LT              reduce using rule 94 (pexp -> empty .)
    GTE             reduce using rule 94 (pexp -> empty .)
    LTE             reduce using rule 94 (pexp -> empty .)
    NE              reduce using rule 94 (pexp -> empty .)
    AND             reduce using rule 94 (pexp -> empty .)
    OR              reduce using rule 94 (pexp -> empty .)
    COMMA           reduce using rule 94 (pexp -> empty .)

  ! RPAREN          [ reduce using rule 94 (pexp -> empty .) ]


state 199

    (95) arrStatement -> LBRACKET checkArray exp generateQuadVER . RBRACKET getArrFinalAddress

    RBRACKET        shift and go to state 229


state 200

    (37) read -> READ operatorRead LPAREN paramReadAux RPAREN .

    ID              reduce using rule 37 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    READ            reduce using rule 37 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    WRITE           reduce using rule 37 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    FOR             reduce using rule 37 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    WHILE           reduce using rule 37 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    IF              reduce using rule 37 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)
    SEMMICOLON      reduce using rule 37 (read -> READ operatorRead LPAREN paramReadAux RPAREN .)


state 201

    (40) paramReadAux -> exp generateQuadREAD .
    (41) paramReadAux -> exp generateQuadREAD . COMMA operatorRead paramReadAux

    RPAREN          reduce using rule 40 (paramReadAux -> exp generateQuadREAD .)
    COMMA           shift and go to state 230


state 202

    (44) write -> WRITE writeOperator LPAREN paramWrite RPAREN .

    ID              reduce using rule 44 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    READ            reduce using rule 44 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    WRITE           reduce using rule 44 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    FOR             reduce using rule 44 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    WHILE           reduce using rule 44 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    IF              reduce using rule 44 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)
    SEMMICOLON      reduce using rule 44 (write -> WRITE writeOperator LPAREN paramWrite RPAREN .)


state 203

    (47) paramWriteAux -> exp generateQuadPRINT .
    (48) paramWriteAux -> exp generateQuadPRINT . COMMA writeOperator paramWriteAux

    RPAREN          reduce using rule 47 (paramWriteAux -> exp generateQuadPRINT .)
    COMMA           shift and go to state 231


state 204

    (52) for -> FOR forOP assign TO CTEI . DO generateQuadFOR LCURLY statements RCURLY LoopEnd

    DO              shift and go to state 232


state 205

    (55) while -> WHILE whileOP LPAREN exp RPAREN . DO generateQuadWHILE LCURLY statements RCURLY LoopEnd

    DO              shift and go to state 233


state 206

    (92) pexp -> LPAREN exp RPAREN .

    MUL             reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    DIV             reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    AND             reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    OR              reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    SEMMICOLON      reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    TO              reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    CTEI            reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    CTEF            reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    CTEC            reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    CTESTRING       reduce using rule 92 (pexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 92 (pexp -> LPAREN exp RPAREN .)


state 207

    (58) if -> IF LPAREN exp RPAREN generateQuadIF . THEN LCURLY statements RCURLY else endIF

    THEN            shift and go to state 234


state 208

    (65) exp -> nexp generateQuadOR OR . saveOperator nexp
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    AND             reduce using rule 101 (saveOperator -> .)
    GT              reduce using rule 101 (saveOperator -> .)
    LT              reduce using rule 101 (saveOperator -> .)
    GTE             reduce using rule 101 (saveOperator -> .)
    LTE             reduce using rule 101 (saveOperator -> .)
    NE              reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)
    RPAREN          reduce using rule 101 (saveOperator -> .)
    RBRACKET        reduce using rule 101 (saveOperator -> .)
    COMMA           reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 235

state 209

    (68) nexp -> compexp generateQuadAND AND . saveOperator compexp
    (101) saveOperator -> .

    ID              reduce using rule 101 (saveOperator -> .)
    CTEI            reduce using rule 101 (saveOperator -> .)
    CTEF            reduce using rule 101 (saveOperator -> .)
    CTEC            reduce using rule 101 (saveOperator -> .)
    CTESTRING       reduce using rule 101 (saveOperator -> .)
    LPAREN          reduce using rule 101 (saveOperator -> .)
    GT              reduce using rule 101 (saveOperator -> .)
    LT              reduce using rule 101 (saveOperator -> .)
    GTE             reduce using rule 101 (saveOperator -> .)
    LTE             reduce using rule 101 (saveOperator -> .)
    NE              reduce using rule 101 (saveOperator -> .)
    PLUS            reduce using rule 101 (saveOperator -> .)
    MINUS           reduce using rule 101 (saveOperator -> .)
    MUL             reduce using rule 101 (saveOperator -> .)
    DIV             reduce using rule 101 (saveOperator -> .)
    OR              reduce using rule 101 (saveOperator -> .)
    RPAREN          reduce using rule 101 (saveOperator -> .)
    RBRACKET        reduce using rule 101 (saveOperator -> .)
    COMMA           reduce using rule 101 (saveOperator -> .)
    SEMMICOLON      reduce using rule 101 (saveOperator -> .)
    TO              reduce using rule 101 (saveOperator -> .)

    saveOperator                   shift and go to state 236

state 210

    (72) compexp1 -> sumexp GT saveOperator . sumexp generateQuadCOMPARE
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)

  ! ID              [ reduce using rule 149 (empty -> .) ]
  ! CTEI            [ reduce using rule 149 (empty -> .) ]
  ! CTEF            [ reduce using rule 149 (empty -> .) ]
  ! CTEC            [ reduce using rule 149 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 149 (empty -> .) ]
  ! LPAREN          [ reduce using rule 149 (empty -> .) ]

    sumexp                         shift and go to state 237
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 211

    (73) compexp1 -> sumexp LT saveOperator . sumexp generateQuadCOMPARE
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)

  ! ID              [ reduce using rule 149 (empty -> .) ]
  ! CTEI            [ reduce using rule 149 (empty -> .) ]
  ! CTEF            [ reduce using rule 149 (empty -> .) ]
  ! CTEC            [ reduce using rule 149 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 149 (empty -> .) ]
  ! LPAREN          [ reduce using rule 149 (empty -> .) ]

    sumexp                         shift and go to state 238
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 212

    (74) compexp1 -> sumexp GTE saveOperator . sumexp generateQuadCOMPARE
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)

  ! ID              [ reduce using rule 149 (empty -> .) ]
  ! CTEI            [ reduce using rule 149 (empty -> .) ]
  ! CTEF            [ reduce using rule 149 (empty -> .) ]
  ! CTEC            [ reduce using rule 149 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 149 (empty -> .) ]
  ! LPAREN          [ reduce using rule 149 (empty -> .) ]

    sumexp                         shift and go to state 239
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 213

    (75) compexp1 -> sumexp LTE saveOperator . sumexp generateQuadCOMPARE
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)

  ! ID              [ reduce using rule 149 (empty -> .) ]
  ! CTEI            [ reduce using rule 149 (empty -> .) ]
  ! CTEF            [ reduce using rule 149 (empty -> .) ]
  ! CTEC            [ reduce using rule 149 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 149 (empty -> .) ]
  ! LPAREN          [ reduce using rule 149 (empty -> .) ]

    sumexp                         shift and go to state 240
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 214

    (76) compexp1 -> sumexp NE saveOperator . sumexp generateQuadCOMPARE
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)

  ! ID              [ reduce using rule 149 (empty -> .) ]
  ! CTEI            [ reduce using rule 149 (empty -> .) ]
  ! CTEF            [ reduce using rule 149 (empty -> .) ]
  ! CTEC            [ reduce using rule 149 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 149 (empty -> .) ]
  ! LPAREN          [ reduce using rule 149 (empty -> .) ]

    sumexp                         shift and go to state 241
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 215

    (79) sumexp -> mulexp PLUS saveOperator . mulexp generateQuadSUM
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)

  ! ID              [ reduce using rule 149 (empty -> .) ]
  ! CTEI            [ reduce using rule 149 (empty -> .) ]
  ! CTEF            [ reduce using rule 149 (empty -> .) ]
  ! CTEC            [ reduce using rule 149 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 149 (empty -> .) ]
  ! LPAREN          [ reduce using rule 149 (empty -> .) ]

    mulexp                         shift and go to state 242
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 216

    (80) sumexp -> mulexp MINUS saveOperator . mulexp generateQuadSUM
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)

  ! ID              [ reduce using rule 149 (empty -> .) ]
  ! CTEI            [ reduce using rule 149 (empty -> .) ]
  ! CTEF            [ reduce using rule 149 (empty -> .) ]
  ! CTEC            [ reduce using rule 149 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 149 (empty -> .) ]
  ! LPAREN          [ reduce using rule 149 (empty -> .) ]

    mulexp                         shift and go to state 243
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 217

    (83) mulexp -> pexp MUL saveOperator . pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)

  ! ID              [ reduce using rule 149 (empty -> .) ]
  ! CTEI            [ reduce using rule 149 (empty -> .) ]
  ! CTEF            [ reduce using rule 149 (empty -> .) ]
  ! CTEC            [ reduce using rule 149 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 149 (empty -> .) ]
  ! LPAREN          [ reduce using rule 149 (empty -> .) ]

    pexp                           shift and go to state 244
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 218

    (84) mulexp -> pexp DIV saveOperator . pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for CTEC resolved as shift
  ! shift/reduce conflict for CTESTRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)

  ! ID              [ reduce using rule 149 (empty -> .) ]
  ! CTEI            [ reduce using rule 149 (empty -> .) ]
  ! CTEF            [ reduce using rule 149 (empty -> .) ]
  ! CTEC            [ reduce using rule 149 (empty -> .) ]
  ! CTESTRING       [ reduce using rule 149 (empty -> .) ]
  ! LPAREN          [ reduce using rule 149 (empty -> .) ]

    pexp                           shift and go to state 245
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 219

    (128) functions2 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY . setStartDirection statements return RCURLY
    (130) setStartDirection -> .

    ID              reduce using rule 130 (setStartDirection -> .)
    READ            reduce using rule 130 (setStartDirection -> .)
    WRITE           reduce using rule 130 (setStartDirection -> .)
    FOR             reduce using rule 130 (setStartDirection -> .)
    WHILE           reduce using rule 130 (setStartDirection -> .)
    IF              reduce using rule 130 (setStartDirection -> .)
    RETURN          reduce using rule 130 (setStartDirection -> .)

    setStartDirection              shift and go to state 246

state 220

    (134) paramsAux -> INT saveTypeVar TWOPOINTS ID . addParameter nextParam
    (131) addParameter -> .

    COMMA           reduce using rule 131 (addParameter -> .)
    RPAREN          reduce using rule 131 (addParameter -> .)

    addParameter                   shift and go to state 247

state 221

    (135) paramsAux -> FLOAT saveTypeVar TWOPOINTS ID . addParameter nextParam
    (131) addParameter -> .

    COMMA           reduce using rule 131 (addParameter -> .)
    RPAREN          reduce using rule 131 (addParameter -> .)

    addParameter                   shift and go to state 248

state 222

    (136) paramsAux -> CHAR saveTypeVar TWOPOINTS ID . addParameter nextParam
    (131) addParameter -> .

    COMMA           reduce using rule 131 (addParameter -> .)
    RPAREN          reduce using rule 131 (addParameter -> .)

    addParameter                   shift and go to state 249

state 223

    (126) functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY . setStartDirection statements RCURLY
    (130) setStartDirection -> .

    ID              reduce using rule 130 (setStartDirection -> .)
    READ            reduce using rule 130 (setStartDirection -> .)
    WRITE           reduce using rule 130 (setStartDirection -> .)
    FOR             reduce using rule 130 (setStartDirection -> .)
    WHILE           reduce using rule 130 (setStartDirection -> .)
    IF              reduce using rule 130 (setStartDirection -> .)
    RCURLY          reduce using rule 130 (setStartDirection -> .)

    setStartDirection              shift and go to state 250

state 224

    (18) assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .

    SEMMICOLON      reduce using rule 18 (assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .)
    TO              reduce using rule 18 (assign -> ID add_id2 EQUALS saveOperator exp generateAssignQuad .)


state 225

    (20) assign -> ID add_id2 EQUALS saveOperator functionCall generateAssignQuad .

    SEMMICOLON      reduce using rule 20 (assign -> ID add_id2 EQUALS saveOperator functionCall generateAssignQuad .)
    TO              reduce using rule 20 (assign -> ID add_id2 EQUALS saveOperator functionCall generateAssignQuad .)


state 226

    (19) assign -> ID arrStatement EQUALS saveOperator exp generateAssignQuad .

    SEMMICOLON      reduce using rule 19 (assign -> ID arrStatement EQUALS saveOperator exp generateAssignQuad .)
    TO              reduce using rule 19 (assign -> ID arrStatement EQUALS saveOperator exp generateAssignQuad .)


state 227

    (26) functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams . RPAREN generateQuadGOSUB

    RPAREN          shift and go to state 251


state 228

    (31) expAux -> exp generateQuadPARAM . paramsCount
    (32) expAux -> exp generateQuadPARAM . COMMA paramsCount expAux
    (29) paramsCount -> .

    COMMA           shift and go to state 253
    RPAREN          reduce using rule 29 (paramsCount -> .)

    paramsCount                    shift and go to state 252

state 229

    (95) arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET . getArrFinalAddress
    (97) getArrFinalAddress -> .

    EQUALS          reduce using rule 97 (getArrFinalAddress -> .)
    MUL             reduce using rule 97 (getArrFinalAddress -> .)
    DIV             reduce using rule 97 (getArrFinalAddress -> .)
    PLUS            reduce using rule 97 (getArrFinalAddress -> .)
    MINUS           reduce using rule 97 (getArrFinalAddress -> .)
    GT              reduce using rule 97 (getArrFinalAddress -> .)
    LT              reduce using rule 97 (getArrFinalAddress -> .)
    GTE             reduce using rule 97 (getArrFinalAddress -> .)
    LTE             reduce using rule 97 (getArrFinalAddress -> .)
    NE              reduce using rule 97 (getArrFinalAddress -> .)
    AND             reduce using rule 97 (getArrFinalAddress -> .)
    OR              reduce using rule 97 (getArrFinalAddress -> .)
    RPAREN          reduce using rule 97 (getArrFinalAddress -> .)
    RBRACKET        reduce using rule 97 (getArrFinalAddress -> .)
    COMMA           reduce using rule 97 (getArrFinalAddress -> .)
    SEMMICOLON      reduce using rule 97 (getArrFinalAddress -> .)
    TO              reduce using rule 97 (getArrFinalAddress -> .)
    ID              reduce using rule 97 (getArrFinalAddress -> .)
    CTEI            reduce using rule 97 (getArrFinalAddress -> .)
    CTEF            reduce using rule 97 (getArrFinalAddress -> .)
    CTEC            reduce using rule 97 (getArrFinalAddress -> .)
    CTESTRING       reduce using rule 97 (getArrFinalAddress -> .)
    LPAREN          reduce using rule 97 (getArrFinalAddress -> .)

    getArrFinalAddress             shift and go to state 254

state 230

    (41) paramReadAux -> exp generateQuadREAD COMMA . operatorRead paramReadAux
    (42) operatorRead -> .

    ID              reduce using rule 42 (operatorRead -> .)
    CTEI            reduce using rule 42 (operatorRead -> .)
    CTEF            reduce using rule 42 (operatorRead -> .)
    CTEC            reduce using rule 42 (operatorRead -> .)
    CTESTRING       reduce using rule 42 (operatorRead -> .)
    LPAREN          reduce using rule 42 (operatorRead -> .)
    COMMA           reduce using rule 42 (operatorRead -> .)
    OR              reduce using rule 42 (operatorRead -> .)
    AND             reduce using rule 42 (operatorRead -> .)
    GT              reduce using rule 42 (operatorRead -> .)
    LT              reduce using rule 42 (operatorRead -> .)
    GTE             reduce using rule 42 (operatorRead -> .)
    LTE             reduce using rule 42 (operatorRead -> .)
    NE              reduce using rule 42 (operatorRead -> .)
    PLUS            reduce using rule 42 (operatorRead -> .)
    MINUS           reduce using rule 42 (operatorRead -> .)
    MUL             reduce using rule 42 (operatorRead -> .)
    DIV             reduce using rule 42 (operatorRead -> .)
    RPAREN          reduce using rule 42 (operatorRead -> .)

    operatorRead                   shift and go to state 255

state 231

    (48) paramWriteAux -> exp generateQuadPRINT COMMA . writeOperator paramWriteAux
    (49) writeOperator -> .

    ID              reduce using rule 49 (writeOperator -> .)
    CTEI            reduce using rule 49 (writeOperator -> .)
    CTEF            reduce using rule 49 (writeOperator -> .)
    CTEC            reduce using rule 49 (writeOperator -> .)
    CTESTRING       reduce using rule 49 (writeOperator -> .)
    LPAREN          reduce using rule 49 (writeOperator -> .)
    COMMA           reduce using rule 49 (writeOperator -> .)
    OR              reduce using rule 49 (writeOperator -> .)
    AND             reduce using rule 49 (writeOperator -> .)
    GT              reduce using rule 49 (writeOperator -> .)
    LT              reduce using rule 49 (writeOperator -> .)
    GTE             reduce using rule 49 (writeOperator -> .)
    LTE             reduce using rule 49 (writeOperator -> .)
    NE              reduce using rule 49 (writeOperator -> .)
    PLUS            reduce using rule 49 (writeOperator -> .)
    MINUS           reduce using rule 49 (writeOperator -> .)
    MUL             reduce using rule 49 (writeOperator -> .)
    DIV             reduce using rule 49 (writeOperator -> .)
    RPAREN          reduce using rule 49 (writeOperator -> .)

    writeOperator                  shift and go to state 256

state 232

    (52) for -> FOR forOP assign TO CTEI DO . generateQuadFOR LCURLY statements RCURLY LoopEnd
    (54) generateQuadFOR -> .

    LCURLY          reduce using rule 54 (generateQuadFOR -> .)

    generateQuadFOR                shift and go to state 257

state 233

    (55) while -> WHILE whileOP LPAREN exp RPAREN DO . generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (57) generateQuadWHILE -> .

    LCURLY          reduce using rule 57 (generateQuadWHILE -> .)

    generateQuadWHILE              shift and go to state 258

state 234

    (58) if -> IF LPAREN exp RPAREN generateQuadIF THEN . LCURLY statements RCURLY else endIF

    LCURLY          shift and go to state 259


state 235

    (65) exp -> nexp generateQuadOR OR saveOperator . nexp
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)

    nexp                           shift and go to state 260
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 236

    (68) nexp -> compexp generateQuadAND AND saveOperator . compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)
    RBRACKET        reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    TO              reduce using rule 149 (empty -> .)

    compexp                        shift and go to state 261
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 237

    (72) compexp1 -> sumexp GT saveOperator sumexp . generateQuadCOMPARE
    (77) generateQuadCOMPARE -> .

    ID              reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEI            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 77 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 77 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 77 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 77 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 77 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 77 (generateQuadCOMPARE -> .)
    AND             reduce using rule 77 (generateQuadCOMPARE -> .)
    OR              reduce using rule 77 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 77 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 77 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 77 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 77 (generateQuadCOMPARE -> .)
    TO              reduce using rule 77 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 262

state 238

    (73) compexp1 -> sumexp LT saveOperator sumexp . generateQuadCOMPARE
    (77) generateQuadCOMPARE -> .

    ID              reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEI            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 77 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 77 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 77 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 77 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 77 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 77 (generateQuadCOMPARE -> .)
    AND             reduce using rule 77 (generateQuadCOMPARE -> .)
    OR              reduce using rule 77 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 77 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 77 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 77 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 77 (generateQuadCOMPARE -> .)
    TO              reduce using rule 77 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 263

state 239

    (74) compexp1 -> sumexp GTE saveOperator sumexp . generateQuadCOMPARE
    (77) generateQuadCOMPARE -> .

    ID              reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEI            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 77 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 77 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 77 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 77 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 77 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 77 (generateQuadCOMPARE -> .)
    AND             reduce using rule 77 (generateQuadCOMPARE -> .)
    OR              reduce using rule 77 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 77 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 77 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 77 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 77 (generateQuadCOMPARE -> .)
    TO              reduce using rule 77 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 264

state 240

    (75) compexp1 -> sumexp LTE saveOperator sumexp . generateQuadCOMPARE
    (77) generateQuadCOMPARE -> .

    ID              reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEI            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 77 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 77 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 77 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 77 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 77 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 77 (generateQuadCOMPARE -> .)
    AND             reduce using rule 77 (generateQuadCOMPARE -> .)
    OR              reduce using rule 77 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 77 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 77 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 77 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 77 (generateQuadCOMPARE -> .)
    TO              reduce using rule 77 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 265

state 241

    (76) compexp1 -> sumexp NE saveOperator sumexp . generateQuadCOMPARE
    (77) generateQuadCOMPARE -> .

    ID              reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEI            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEF            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTEC            reduce using rule 77 (generateQuadCOMPARE -> .)
    CTESTRING       reduce using rule 77 (generateQuadCOMPARE -> .)
    LPAREN          reduce using rule 77 (generateQuadCOMPARE -> .)
    PLUS            reduce using rule 77 (generateQuadCOMPARE -> .)
    MINUS           reduce using rule 77 (generateQuadCOMPARE -> .)
    MUL             reduce using rule 77 (generateQuadCOMPARE -> .)
    DIV             reduce using rule 77 (generateQuadCOMPARE -> .)
    AND             reduce using rule 77 (generateQuadCOMPARE -> .)
    OR              reduce using rule 77 (generateQuadCOMPARE -> .)
    RPAREN          reduce using rule 77 (generateQuadCOMPARE -> .)
    RBRACKET        reduce using rule 77 (generateQuadCOMPARE -> .)
    COMMA           reduce using rule 77 (generateQuadCOMPARE -> .)
    SEMMICOLON      reduce using rule 77 (generateQuadCOMPARE -> .)
    TO              reduce using rule 77 (generateQuadCOMPARE -> .)

    generateQuadCOMPARE            shift and go to state 266

state 242

    (79) sumexp -> mulexp PLUS saveOperator mulexp . generateQuadSUM
    (81) generateQuadSUM -> .

    GT              reduce using rule 81 (generateQuadSUM -> .)
    LT              reduce using rule 81 (generateQuadSUM -> .)
    GTE             reduce using rule 81 (generateQuadSUM -> .)
    LTE             reduce using rule 81 (generateQuadSUM -> .)
    NE              reduce using rule 81 (generateQuadSUM -> .)
    AND             reduce using rule 81 (generateQuadSUM -> .)
    OR              reduce using rule 81 (generateQuadSUM -> .)
    RPAREN          reduce using rule 81 (generateQuadSUM -> .)
    RBRACKET        reduce using rule 81 (generateQuadSUM -> .)
    COMMA           reduce using rule 81 (generateQuadSUM -> .)
    SEMMICOLON      reduce using rule 81 (generateQuadSUM -> .)
    TO              reduce using rule 81 (generateQuadSUM -> .)
    ID              reduce using rule 81 (generateQuadSUM -> .)
    CTEI            reduce using rule 81 (generateQuadSUM -> .)
    CTEF            reduce using rule 81 (generateQuadSUM -> .)
    CTEC            reduce using rule 81 (generateQuadSUM -> .)
    CTESTRING       reduce using rule 81 (generateQuadSUM -> .)
    LPAREN          reduce using rule 81 (generateQuadSUM -> .)
    PLUS            reduce using rule 81 (generateQuadSUM -> .)
    MINUS           reduce using rule 81 (generateQuadSUM -> .)
    MUL             reduce using rule 81 (generateQuadSUM -> .)
    DIV             reduce using rule 81 (generateQuadSUM -> .)

    generateQuadSUM                shift and go to state 267

state 243

    (80) sumexp -> mulexp MINUS saveOperator mulexp . generateQuadSUM
    (81) generateQuadSUM -> .

    GT              reduce using rule 81 (generateQuadSUM -> .)
    LT              reduce using rule 81 (generateQuadSUM -> .)
    GTE             reduce using rule 81 (generateQuadSUM -> .)
    LTE             reduce using rule 81 (generateQuadSUM -> .)
    NE              reduce using rule 81 (generateQuadSUM -> .)
    AND             reduce using rule 81 (generateQuadSUM -> .)
    OR              reduce using rule 81 (generateQuadSUM -> .)
    RPAREN          reduce using rule 81 (generateQuadSUM -> .)
    RBRACKET        reduce using rule 81 (generateQuadSUM -> .)
    COMMA           reduce using rule 81 (generateQuadSUM -> .)
    SEMMICOLON      reduce using rule 81 (generateQuadSUM -> .)
    TO              reduce using rule 81 (generateQuadSUM -> .)
    ID              reduce using rule 81 (generateQuadSUM -> .)
    CTEI            reduce using rule 81 (generateQuadSUM -> .)
    CTEF            reduce using rule 81 (generateQuadSUM -> .)
    CTEC            reduce using rule 81 (generateQuadSUM -> .)
    CTESTRING       reduce using rule 81 (generateQuadSUM -> .)
    LPAREN          reduce using rule 81 (generateQuadSUM -> .)
    PLUS            reduce using rule 81 (generateQuadSUM -> .)
    MINUS           reduce using rule 81 (generateQuadSUM -> .)
    MUL             reduce using rule 81 (generateQuadSUM -> .)
    DIV             reduce using rule 81 (generateQuadSUM -> .)

    generateQuadSUM                shift and go to state 268

state 244

    (83) mulexp -> pexp MUL saveOperator pexp . generateQuadMUL
    (85) generateQuadMUL -> .

    PLUS            reduce using rule 85 (generateQuadMUL -> .)
    MINUS           reduce using rule 85 (generateQuadMUL -> .)
    GT              reduce using rule 85 (generateQuadMUL -> .)
    LT              reduce using rule 85 (generateQuadMUL -> .)
    GTE             reduce using rule 85 (generateQuadMUL -> .)
    LTE             reduce using rule 85 (generateQuadMUL -> .)
    NE              reduce using rule 85 (generateQuadMUL -> .)
    AND             reduce using rule 85 (generateQuadMUL -> .)
    OR              reduce using rule 85 (generateQuadMUL -> .)
    RPAREN          reduce using rule 85 (generateQuadMUL -> .)
    RBRACKET        reduce using rule 85 (generateQuadMUL -> .)
    COMMA           reduce using rule 85 (generateQuadMUL -> .)
    SEMMICOLON      reduce using rule 85 (generateQuadMUL -> .)
    TO              reduce using rule 85 (generateQuadMUL -> .)
    ID              reduce using rule 85 (generateQuadMUL -> .)
    CTEI            reduce using rule 85 (generateQuadMUL -> .)
    CTEF            reduce using rule 85 (generateQuadMUL -> .)
    CTEC            reduce using rule 85 (generateQuadMUL -> .)
    CTESTRING       reduce using rule 85 (generateQuadMUL -> .)
    LPAREN          reduce using rule 85 (generateQuadMUL -> .)
    MUL             reduce using rule 85 (generateQuadMUL -> .)
    DIV             reduce using rule 85 (generateQuadMUL -> .)

    generateQuadMUL                shift and go to state 269

state 245

    (84) mulexp -> pexp DIV saveOperator pexp . generateQuadMUL
    (85) generateQuadMUL -> .

    PLUS            reduce using rule 85 (generateQuadMUL -> .)
    MINUS           reduce using rule 85 (generateQuadMUL -> .)
    GT              reduce using rule 85 (generateQuadMUL -> .)
    LT              reduce using rule 85 (generateQuadMUL -> .)
    GTE             reduce using rule 85 (generateQuadMUL -> .)
    LTE             reduce using rule 85 (generateQuadMUL -> .)
    NE              reduce using rule 85 (generateQuadMUL -> .)
    AND             reduce using rule 85 (generateQuadMUL -> .)
    OR              reduce using rule 85 (generateQuadMUL -> .)
    RPAREN          reduce using rule 85 (generateQuadMUL -> .)
    RBRACKET        reduce using rule 85 (generateQuadMUL -> .)
    COMMA           reduce using rule 85 (generateQuadMUL -> .)
    SEMMICOLON      reduce using rule 85 (generateQuadMUL -> .)
    TO              reduce using rule 85 (generateQuadMUL -> .)
    ID              reduce using rule 85 (generateQuadMUL -> .)
    CTEI            reduce using rule 85 (generateQuadMUL -> .)
    CTEF            reduce using rule 85 (generateQuadMUL -> .)
    CTEC            reduce using rule 85 (generateQuadMUL -> .)
    CTESTRING       reduce using rule 85 (generateQuadMUL -> .)
    LPAREN          reduce using rule 85 (generateQuadMUL -> .)
    MUL             reduce using rule 85 (generateQuadMUL -> .)
    DIV             reduce using rule 85 (generateQuadMUL -> .)

    generateQuadMUL                shift and go to state 270

state 246

    (128) functions2 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection . statements return RCURLY
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RETURN          reduce using rule 149 (empty -> .)

    statements                     shift and go to state 271
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 247

    (134) paramsAux -> INT saveTypeVar TWOPOINTS ID addParameter . nextParam
    (137) nextParam -> . COMMA paramsAux
    (138) nextParam -> . empty
    (149) empty -> .

    COMMA           shift and go to state 273
    RPAREN          reduce using rule 149 (empty -> .)

    nextParam                      shift and go to state 272
    empty                          shift and go to state 274

state 248

    (135) paramsAux -> FLOAT saveTypeVar TWOPOINTS ID addParameter . nextParam
    (137) nextParam -> . COMMA paramsAux
    (138) nextParam -> . empty
    (149) empty -> .

    COMMA           shift and go to state 273
    RPAREN          reduce using rule 149 (empty -> .)

    nextParam                      shift and go to state 275
    empty                          shift and go to state 274

state 249

    (136) paramsAux -> CHAR saveTypeVar TWOPOINTS ID addParameter . nextParam
    (137) nextParam -> . COMMA paramsAux
    (138) nextParam -> . empty
    (149) empty -> .

    COMMA           shift and go to state 273
    RPAREN          reduce using rule 149 (empty -> .)

    nextParam                      shift and go to state 276
    empty                          shift and go to state 274

state 250

    (126) functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection . statements RCURLY
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)

    statements                     shift and go to state 277
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 251

    (26) functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN . generateQuadGOSUB
    (34) generateQuadGOSUB -> .

    SEMMICOLON      reduce using rule 34 (generateQuadGOSUB -> .)
    MUL             reduce using rule 34 (generateQuadGOSUB -> .)
    DIV             reduce using rule 34 (generateQuadGOSUB -> .)
    PLUS            reduce using rule 34 (generateQuadGOSUB -> .)
    MINUS           reduce using rule 34 (generateQuadGOSUB -> .)
    GT              reduce using rule 34 (generateQuadGOSUB -> .)
    LT              reduce using rule 34 (generateQuadGOSUB -> .)
    GTE             reduce using rule 34 (generateQuadGOSUB -> .)
    LTE             reduce using rule 34 (generateQuadGOSUB -> .)
    NE              reduce using rule 34 (generateQuadGOSUB -> .)
    AND             reduce using rule 34 (generateQuadGOSUB -> .)
    OR              reduce using rule 34 (generateQuadGOSUB -> .)
    RPAREN          reduce using rule 34 (generateQuadGOSUB -> .)
    RBRACKET        reduce using rule 34 (generateQuadGOSUB -> .)
    COMMA           reduce using rule 34 (generateQuadGOSUB -> .)
    TO              reduce using rule 34 (generateQuadGOSUB -> .)
    ID              reduce using rule 34 (generateQuadGOSUB -> .)
    CTEI            reduce using rule 34 (generateQuadGOSUB -> .)
    CTEF            reduce using rule 34 (generateQuadGOSUB -> .)
    CTEC            reduce using rule 34 (generateQuadGOSUB -> .)
    CTESTRING       reduce using rule 34 (generateQuadGOSUB -> .)
    LPAREN          reduce using rule 34 (generateQuadGOSUB -> .)

    generateQuadGOSUB              shift and go to state 278

state 252

    (31) expAux -> exp generateQuadPARAM paramsCount .

    RPAREN          reduce using rule 31 (expAux -> exp generateQuadPARAM paramsCount .)


state 253

    (32) expAux -> exp generateQuadPARAM COMMA . paramsCount expAux
    (29) paramsCount -> .

    ID              reduce using rule 29 (paramsCount -> .)
    CTEI            reduce using rule 29 (paramsCount -> .)
    CTEF            reduce using rule 29 (paramsCount -> .)
    CTEC            reduce using rule 29 (paramsCount -> .)
    CTESTRING       reduce using rule 29 (paramsCount -> .)
    LPAREN          reduce using rule 29 (paramsCount -> .)
    COMMA           reduce using rule 29 (paramsCount -> .)
    OR              reduce using rule 29 (paramsCount -> .)
    AND             reduce using rule 29 (paramsCount -> .)
    GT              reduce using rule 29 (paramsCount -> .)
    LT              reduce using rule 29 (paramsCount -> .)
    GTE             reduce using rule 29 (paramsCount -> .)
    LTE             reduce using rule 29 (paramsCount -> .)
    NE              reduce using rule 29 (paramsCount -> .)
    PLUS            reduce using rule 29 (paramsCount -> .)
    MINUS           reduce using rule 29 (paramsCount -> .)
    MUL             reduce using rule 29 (paramsCount -> .)
    DIV             reduce using rule 29 (paramsCount -> .)
    RPAREN          reduce using rule 29 (paramsCount -> .)

    paramsCount                    shift and go to state 279

state 254

    (95) arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .

    EQUALS          reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    MUL             reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    DIV             reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    PLUS            reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    MINUS           reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    GT              reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    LT              reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    GTE             reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    LTE             reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    NE              reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    AND             reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    OR              reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    RPAREN          reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    RBRACKET        reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    COMMA           reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    SEMMICOLON      reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    TO              reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    ID              reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    CTEI            reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    CTEF            reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    CTEC            reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    CTESTRING       reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)
    LPAREN          reduce using rule 95 (arrStatement -> LBRACKET checkArray exp generateQuadVER RBRACKET getArrFinalAddress .)


state 255

    (41) paramReadAux -> exp generateQuadREAD COMMA operatorRead . paramReadAux
    (40) paramReadAux -> . exp generateQuadREAD
    (41) paramReadAux -> . exp generateQuadREAD COMMA operatorRead paramReadAux
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)

    exp                            shift and go to state 160
    paramReadAux                   shift and go to state 280
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 256

    (48) paramWriteAux -> exp generateQuadPRINT COMMA writeOperator . paramWriteAux
    (47) paramWriteAux -> . exp generateQuadPRINT
    (48) paramWriteAux -> . exp generateQuadPRINT COMMA writeOperator paramWriteAux
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)

    exp                            shift and go to state 164
    paramWriteAux                  shift and go to state 281
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 257

    (52) for -> FOR forOP assign TO CTEI DO generateQuadFOR . LCURLY statements RCURLY LoopEnd

    LCURLY          shift and go to state 282


state 258

    (55) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE . LCURLY statements RCURLY LoopEnd

    LCURLY          shift and go to state 283


state 259

    (58) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY . statements RCURLY else endIF
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)

    statements                     shift and go to state 284
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 260

    (65) exp -> nexp generateQuadOR OR saveOperator nexp .

    RPAREN          reduce using rule 65 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    RBRACKET        reduce using rule 65 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    COMMA           reduce using rule 65 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    SEMMICOLON      reduce using rule 65 (exp -> nexp generateQuadOR OR saveOperator nexp .)
    TO              reduce using rule 65 (exp -> nexp generateQuadOR OR saveOperator nexp .)


state 261

    (68) nexp -> compexp generateQuadAND AND saveOperator compexp .

    OR              reduce using rule 68 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    RPAREN          reduce using rule 68 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    RBRACKET        reduce using rule 68 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    COMMA           reduce using rule 68 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    SEMMICOLON      reduce using rule 68 (nexp -> compexp generateQuadAND AND saveOperator compexp .)
    TO              reduce using rule 68 (nexp -> compexp generateQuadAND AND saveOperator compexp .)


state 262

    (72) compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .

    ID              reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEI            reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 72 (compexp1 -> sumexp GT saveOperator sumexp generateQuadCOMPARE .)


state 263

    (73) compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .

    ID              reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEI            reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 73 (compexp1 -> sumexp LT saveOperator sumexp generateQuadCOMPARE .)


state 264

    (74) compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .

    ID              reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEI            reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 74 (compexp1 -> sumexp GTE saveOperator sumexp generateQuadCOMPARE .)


state 265

    (75) compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .

    ID              reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEI            reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 75 (compexp1 -> sumexp LTE saveOperator sumexp generateQuadCOMPARE .)


state 266

    (76) compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .

    ID              reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEI            reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEF            reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTEC            reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    CTESTRING       reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    LPAREN          reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    PLUS            reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    MINUS           reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    MUL             reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    DIV             reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    AND             reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    OR              reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    RPAREN          reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    RBRACKET        reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    COMMA           reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    SEMMICOLON      reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)
    TO              reduce using rule 76 (compexp1 -> sumexp NE saveOperator sumexp generateQuadCOMPARE .)


state 267

    (79) sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .

    GT              reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LT              reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    GTE             reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LTE             reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    NE              reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    AND             reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    OR              reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    RPAREN          reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    RBRACKET        reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    COMMA           reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    SEMMICOLON      reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    TO              reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    ID              reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEI            reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEF            reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTEC            reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    CTESTRING       reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    LPAREN          reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    PLUS            reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    MINUS           reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    MUL             reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)
    DIV             reduce using rule 79 (sumexp -> mulexp PLUS saveOperator mulexp generateQuadSUM .)


state 268

    (80) sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .

    GT              reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LT              reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    GTE             reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LTE             reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    NE              reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    AND             reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    OR              reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    RPAREN          reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    RBRACKET        reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    COMMA           reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    SEMMICOLON      reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    TO              reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    ID              reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEI            reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEF            reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTEC            reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    CTESTRING       reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    LPAREN          reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    PLUS            reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    MINUS           reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    MUL             reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)
    DIV             reduce using rule 80 (sumexp -> mulexp MINUS saveOperator mulexp generateQuadSUM .)


state 269

    (83) mulexp -> pexp MUL saveOperator pexp generateQuadMUL .

    PLUS            reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    MINUS           reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    GT              reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LT              reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    GTE             reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LTE             reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    NE              reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    AND             reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    OR              reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    RPAREN          reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    RBRACKET        reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    COMMA           reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    SEMMICOLON      reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    TO              reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    ID              reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEI            reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEF            reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTEC            reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    CTESTRING       reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    LPAREN          reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    MUL             reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)
    DIV             reduce using rule 83 (mulexp -> pexp MUL saveOperator pexp generateQuadMUL .)


state 270

    (84) mulexp -> pexp DIV saveOperator pexp generateQuadMUL .

    PLUS            reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    MINUS           reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    GT              reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LT              reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    GTE             reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LTE             reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    NE              reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    AND             reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    OR              reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    RPAREN          reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    RBRACKET        reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    COMMA           reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    SEMMICOLON      reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    TO              reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    ID              reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEI            reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEF            reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTEC            reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    CTESTRING       reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    LPAREN          reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    MUL             reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)
    DIV             reduce using rule 84 (mulexp -> pexp DIV saveOperator pexp generateQuadMUL .)


state 271

    (128) functions2 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements . return RCURLY
    (146) return -> . RETURN LPAREN exp generateQuadRETURN RPAREN SEMMICOLON
    (147) return -> . RETURN LPAREN exp generateQuadRETURN RPAREN

    RETURN          shift and go to state 286

    return                         shift and go to state 285

state 272

    (134) paramsAux -> INT saveTypeVar TWOPOINTS ID addParameter nextParam .

    RPAREN          reduce using rule 134 (paramsAux -> INT saveTypeVar TWOPOINTS ID addParameter nextParam .)


state 273

    (137) nextParam -> COMMA . paramsAux
    (134) paramsAux -> . INT saveTypeVar TWOPOINTS ID addParameter nextParam
    (135) paramsAux -> . FLOAT saveTypeVar TWOPOINTS ID addParameter nextParam
    (136) paramsAux -> . CHAR saveTypeVar TWOPOINTS ID addParameter nextParam

    INT             shift and go to state 112
    FLOAT           shift and go to state 113
    CHAR            shift and go to state 114

    paramsAux                      shift and go to state 287

state 274

    (138) nextParam -> empty .

    RPAREN          reduce using rule 138 (nextParam -> empty .)


state 275

    (135) paramsAux -> FLOAT saveTypeVar TWOPOINTS ID addParameter nextParam .

    RPAREN          reduce using rule 135 (paramsAux -> FLOAT saveTypeVar TWOPOINTS ID addParameter nextParam .)


state 276

    (136) paramsAux -> CHAR saveTypeVar TWOPOINTS ID addParameter nextParam .

    RPAREN          reduce using rule 136 (paramsAux -> CHAR saveTypeVar TWOPOINTS ID addParameter nextParam .)


state 277

    (126) functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements . RCURLY

    RCURLY          shift and go to state 288


state 278

    (26) functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .

    SEMMICOLON      reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    MUL             reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    DIV             reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    PLUS            reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    MINUS           reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    GT              reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    LT              reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    GTE             reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    LTE             reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    NE              reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    AND             reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    OR              reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    RPAREN          reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    RBRACKET        reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    COMMA           reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    TO              reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    ID              reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    CTEI            reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    CTEF            reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    CTEC            reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    CTESTRING       reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)
    LPAREN          reduce using rule 26 (functionCall -> ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB .)


state 279

    (32) expAux -> exp generateQuadPARAM COMMA paramsCount . expAux
    (31) expAux -> . exp generateQuadPARAM paramsCount
    (32) expAux -> . exp generateQuadPARAM COMMA paramsCount expAux
    (33) expAux -> . empty
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (149) empty -> .
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB

    RPAREN          reduce using rule 149 (empty -> .)
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    COMMA           reduce using rule 149 (empty -> .)
    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131

    exp                            shift and go to state 197
    expAux                         shift and go to state 289
    empty                          shift and go to state 198
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144

state 280

    (41) paramReadAux -> exp generateQuadREAD COMMA operatorRead paramReadAux .

    RPAREN          reduce using rule 41 (paramReadAux -> exp generateQuadREAD COMMA operatorRead paramReadAux .)


state 281

    (48) paramWriteAux -> exp generateQuadPRINT COMMA writeOperator paramWriteAux .

    RPAREN          reduce using rule 48 (paramWriteAux -> exp generateQuadPRINT COMMA writeOperator paramWriteAux .)


state 282

    (52) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY . statements RCURLY LoopEnd
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)

    assign                         shift and go to state 68
    statements                     shift and go to state 290
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 283

    (55) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY . statements RCURLY LoopEnd
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)

    statements                     shift and go to state 291
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 284

    (58) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements . RCURLY else endIF

    RCURLY          shift and go to state 292


state 285

    (128) functions2 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements return . RCURLY

    RCURLY          shift and go to state 293


state 286

    (146) return -> RETURN . LPAREN exp generateQuadRETURN RPAREN SEMMICOLON
    (147) return -> RETURN . LPAREN exp generateQuadRETURN RPAREN

    LPAREN          shift and go to state 294


state 287

    (137) nextParam -> COMMA paramsAux .

    RPAREN          reduce using rule 137 (nextParam -> COMMA paramsAux .)


state 288

    (126) functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements RCURLY .

    FUNCTION        reduce using rule 126 (functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements RCURLY .)
    PRINCIPAL       reduce using rule 126 (functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements RCURLY .)
    $end            reduce using rule 126 (functions1 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements RCURLY .)


state 289

    (32) expAux -> exp generateQuadPARAM COMMA paramsCount expAux .

    RPAREN          reduce using rule 32 (expAux -> exp generateQuadPARAM COMMA paramsCount expAux .)


state 290

    (52) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements . RCURLY LoopEnd

    RCURLY          shift and go to state 295


state 291

    (55) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements . RCURLY LoopEnd

    RCURLY          shift and go to state 296


state 292

    (58) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY . else endIF
    (59) else -> . ELSE generateQuadELSE LCURLY statements RCURLY
    (60) else -> . empty
    (149) empty -> .

    ELSE            shift and go to state 298
    ID              reduce using rule 149 (empty -> .)
    READ            reduce using rule 149 (empty -> .)
    WRITE           reduce using rule 149 (empty -> .)
    FOR             reduce using rule 149 (empty -> .)
    WHILE           reduce using rule 149 (empty -> .)
    IF              reduce using rule 149 (empty -> .)
    RCURLY          reduce using rule 149 (empty -> .)
    SEMMICOLON      reduce using rule 149 (empty -> .)
    RETURN          reduce using rule 149 (empty -> .)

    else                           shift and go to state 297
    empty                          shift and go to state 299

state 293

    (128) functions2 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements return RCURLY .

    FUNCTION        reduce using rule 128 (functions2 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements return RCURLY .)
    PRINCIPAL       reduce using rule 128 (functions2 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements return RCURLY .)
    $end            reduce using rule 128 (functions2 -> ID saveFunction LPAREN parameters RPAREN vars LCURLY setStartDirection statements return RCURLY .)


state 294

    (146) return -> RETURN LPAREN . exp generateQuadRETURN RPAREN SEMMICOLON
    (147) return -> RETURN LPAREN . exp generateQuadRETURN RPAREN
    (64) exp -> . nexp generateQuadOR
    (65) exp -> . nexp generateQuadOR OR saveOperator nexp
    (67) nexp -> . compexp generateQuadAND
    (68) nexp -> . compexp generateQuadAND AND saveOperator compexp
    (70) compexp -> . sumexp
    (71) compexp -> . compexp1 sumexp
    (78) sumexp -> . mulexp
    (79) sumexp -> . mulexp PLUS saveOperator mulexp generateQuadSUM
    (80) sumexp -> . mulexp MINUS saveOperator mulexp generateQuadSUM
    (72) compexp1 -> . sumexp GT saveOperator sumexp generateQuadCOMPARE
    (73) compexp1 -> . sumexp LT saveOperator sumexp generateQuadCOMPARE
    (74) compexp1 -> . sumexp GTE saveOperator sumexp generateQuadCOMPARE
    (75) compexp1 -> . sumexp LTE saveOperator sumexp generateQuadCOMPARE
    (76) compexp1 -> . sumexp NE saveOperator sumexp generateQuadCOMPARE
    (82) mulexp -> . pexp
    (83) mulexp -> . pexp MUL saveOperator pexp generateQuadMUL
    (84) mulexp -> . pexp DIV saveOperator pexp generateQuadMUL
    (86) pexp -> . ID add_id2
    (87) pexp -> . CTEI saveCTE
    (88) pexp -> . CTEF saveCTE
    (89) pexp -> . CTEC saveCTE
    (90) pexp -> . CTESTRING saveCTE
    (91) pexp -> . functionCall
    (92) pexp -> . LPAREN exp RPAREN
    (93) pexp -> . ID arrStatement
    (94) pexp -> . empty
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (149) empty -> .

    ID              shift and go to state 139
    CTEI            shift and go to state 140
    CTEF            shift and go to state 141
    CTEC            shift and go to state 142
    CTESTRING       shift and go to state 143
    LPAREN          shift and go to state 131
    MUL             reduce using rule 149 (empty -> .)
    DIV             reduce using rule 149 (empty -> .)
    PLUS            reduce using rule 149 (empty -> .)
    MINUS           reduce using rule 149 (empty -> .)
    GT              reduce using rule 149 (empty -> .)
    LT              reduce using rule 149 (empty -> .)
    GTE             reduce using rule 149 (empty -> .)
    LTE             reduce using rule 149 (empty -> .)
    NE              reduce using rule 149 (empty -> .)
    AND             reduce using rule 149 (empty -> .)
    OR              reduce using rule 149 (empty -> .)
    RPAREN          reduce using rule 149 (empty -> .)

    exp                            shift and go to state 300
    nexp                           shift and go to state 133
    compexp                        shift and go to state 134
    sumexp                         shift and go to state 135
    compexp1                       shift and go to state 136
    mulexp                         shift and go to state 137
    pexp                           shift and go to state 138
    functionCall                   shift and go to state 144
    empty                          shift and go to state 145

state 295

    (52) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY . LoopEnd
    (51) LoopEnd -> .

    ID              reduce using rule 51 (LoopEnd -> .)
    READ            reduce using rule 51 (LoopEnd -> .)
    WRITE           reduce using rule 51 (LoopEnd -> .)
    FOR             reduce using rule 51 (LoopEnd -> .)
    WHILE           reduce using rule 51 (LoopEnd -> .)
    IF              reduce using rule 51 (LoopEnd -> .)
    RCURLY          reduce using rule 51 (LoopEnd -> .)
    SEMMICOLON      reduce using rule 51 (LoopEnd -> .)
    RETURN          reduce using rule 51 (LoopEnd -> .)

    LoopEnd                        shift and go to state 301

state 296

    (55) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY . LoopEnd
    (51) LoopEnd -> .

    ID              reduce using rule 51 (LoopEnd -> .)
    READ            reduce using rule 51 (LoopEnd -> .)
    WRITE           reduce using rule 51 (LoopEnd -> .)
    FOR             reduce using rule 51 (LoopEnd -> .)
    WHILE           reduce using rule 51 (LoopEnd -> .)
    IF              reduce using rule 51 (LoopEnd -> .)
    RCURLY          reduce using rule 51 (LoopEnd -> .)
    SEMMICOLON      reduce using rule 51 (LoopEnd -> .)
    RETURN          reduce using rule 51 (LoopEnd -> .)

    LoopEnd                        shift and go to state 302

state 297

    (58) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else . endIF
    (62) endIF -> .

    ID              reduce using rule 62 (endIF -> .)
    READ            reduce using rule 62 (endIF -> .)
    WRITE           reduce using rule 62 (endIF -> .)
    FOR             reduce using rule 62 (endIF -> .)
    WHILE           reduce using rule 62 (endIF -> .)
    IF              reduce using rule 62 (endIF -> .)
    RCURLY          reduce using rule 62 (endIF -> .)
    SEMMICOLON      reduce using rule 62 (endIF -> .)
    RETURN          reduce using rule 62 (endIF -> .)

    endIF                          shift and go to state 303

state 298

    (59) else -> ELSE . generateQuadELSE LCURLY statements RCURLY
    (63) generateQuadELSE -> .

    LCURLY          reduce using rule 63 (generateQuadELSE -> .)

    generateQuadELSE               shift and go to state 304

state 299

    (60) else -> empty .

    ID              reduce using rule 60 (else -> empty .)
    READ            reduce using rule 60 (else -> empty .)
    WRITE           reduce using rule 60 (else -> empty .)
    FOR             reduce using rule 60 (else -> empty .)
    WHILE           reduce using rule 60 (else -> empty .)
    IF              reduce using rule 60 (else -> empty .)
    RCURLY          reduce using rule 60 (else -> empty .)
    SEMMICOLON      reduce using rule 60 (else -> empty .)
    RETURN          reduce using rule 60 (else -> empty .)


state 300

    (146) return -> RETURN LPAREN exp . generateQuadRETURN RPAREN SEMMICOLON
    (147) return -> RETURN LPAREN exp . generateQuadRETURN RPAREN
    (148) generateQuadRETURN -> .

    RPAREN          reduce using rule 148 (generateQuadRETURN -> .)

    generateQuadRETURN             shift and go to state 305

state 301

    (52) for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .

    ID              reduce using rule 52 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    READ            reduce using rule 52 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    WRITE           reduce using rule 52 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    FOR             reduce using rule 52 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    WHILE           reduce using rule 52 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    IF              reduce using rule 52 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    RCURLY          reduce using rule 52 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    SEMMICOLON      reduce using rule 52 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)
    RETURN          reduce using rule 52 (for -> FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd .)


state 302

    (55) while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .

    ID              reduce using rule 55 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    READ            reduce using rule 55 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    WRITE           reduce using rule 55 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    FOR             reduce using rule 55 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    WHILE           reduce using rule 55 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    IF              reduce using rule 55 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    RCURLY          reduce using rule 55 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    SEMMICOLON      reduce using rule 55 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)
    RETURN          reduce using rule 55 (while -> WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd .)


state 303

    (58) if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .

    ID              reduce using rule 58 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    READ            reduce using rule 58 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    WRITE           reduce using rule 58 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    FOR             reduce using rule 58 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    WHILE           reduce using rule 58 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    IF              reduce using rule 58 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    RCURLY          reduce using rule 58 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    SEMMICOLON      reduce using rule 58 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)
    RETURN          reduce using rule 58 (if -> IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF .)


state 304

    (59) else -> ELSE generateQuadELSE . LCURLY statements RCURLY

    LCURLY          shift and go to state 306


state 305

    (146) return -> RETURN LPAREN exp generateQuadRETURN . RPAREN SEMMICOLON
    (147) return -> RETURN LPAREN exp generateQuadRETURN . RPAREN

    RPAREN          shift and go to state 307


state 306

    (59) else -> ELSE generateQuadELSE LCURLY . statements RCURLY
    (10) statements -> . assign SEMMICOLON statements
    (11) statements -> . functionCall SEMMICOLON statements
    (12) statements -> . read statements SEMMICOLON statements
    (13) statements -> . write statements SEMMICOLON statements
    (14) statements -> . for statements
    (15) statements -> . while statements
    (16) statements -> . if statements
    (17) statements -> . empty
    (18) assign -> . ID add_id2 EQUALS saveOperator exp generateAssignQuad
    (19) assign -> . ID arrStatement EQUALS saveOperator exp generateAssignQuad
    (20) assign -> . ID add_id2 EQUALS saveOperator functionCall generateAssignQuad
    (26) functionCall -> . ID validateFunctionID functionERA LPAREN expAux verifyParams RPAREN generateQuadGOSUB
    (37) read -> . READ operatorRead LPAREN paramReadAux RPAREN
    (44) write -> . WRITE writeOperator LPAREN paramWrite RPAREN
    (52) for -> . FOR forOP assign TO CTEI DO generateQuadFOR LCURLY statements RCURLY LoopEnd
    (55) while -> . WHILE whileOP LPAREN exp RPAREN DO generateQuadWHILE LCURLY statements RCURLY LoopEnd
    (58) if -> . IF LPAREN exp RPAREN generateQuadIF THEN LCURLY statements RCURLY else endIF
    (149) empty -> .

    ID              shift and go to state 76
    READ            shift and go to state 77
    WRITE           shift and go to state 78
    FOR             shift and go to state 79
    WHILE           shift and go to state 80
    IF              shift and go to state 81
    RCURLY          reduce using rule 149 (empty -> .)

    statements                     shift and go to state 308
    assign                         shift and go to state 68
    functionCall                   shift and go to state 69
    read                           shift and go to state 70
    write                          shift and go to state 71
    for                            shift and go to state 72
    while                          shift and go to state 73
    if                             shift and go to state 74
    empty                          shift and go to state 75

state 307

    (146) return -> RETURN LPAREN exp generateQuadRETURN RPAREN . SEMMICOLON
    (147) return -> RETURN LPAREN exp generateQuadRETURN RPAREN .

    SEMMICOLON      shift and go to state 309
    RCURLY          reduce using rule 147 (return -> RETURN LPAREN exp generateQuadRETURN RPAREN .)


state 308

    (59) else -> ELSE generateQuadELSE LCURLY statements . RCURLY

    RCURLY          shift and go to state 310


state 309

    (146) return -> RETURN LPAREN exp generateQuadRETURN RPAREN SEMMICOLON .

    RCURLY          reduce using rule 146 (return -> RETURN LPAREN exp generateQuadRETURN RPAREN SEMMICOLON .)


state 310

    (59) else -> ELSE generateQuadELSE LCURLY statements RCURLY .

    ID              reduce using rule 59 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    READ            reduce using rule 59 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    WRITE           reduce using rule 59 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    FOR             reduce using rule 59 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    WHILE           reduce using rule 59 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    IF              reduce using rule 59 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    RCURLY          reduce using rule 59 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 59 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)
    RETURN          reduce using rule 59 (else -> ELSE generateQuadELSE LCURLY statements RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PRINCIPAL in state 5 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 137 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 137 resolved as shift
WARNING: shift/reduce conflict for MUL in state 138 resolved as shift
WARNING: shift/reduce conflict for DIV in state 138 resolved as shift
WARNING: shift/reduce conflict for ID in state 210 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 210 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 210 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 210 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 210 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 210 resolved as shift
WARNING: shift/reduce conflict for ID in state 211 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 211 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 211 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 211 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 211 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 211 resolved as shift
WARNING: shift/reduce conflict for ID in state 212 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 212 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 212 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 212 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 212 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 212 resolved as shift
WARNING: shift/reduce conflict for ID in state 213 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 213 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 213 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 213 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 213 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 213 resolved as shift
WARNING: shift/reduce conflict for ID in state 214 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 214 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 214 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 214 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 214 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 214 resolved as shift
WARNING: shift/reduce conflict for ID in state 215 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 215 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 215 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 215 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 215 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 215 resolved as shift
WARNING: shift/reduce conflict for ID in state 216 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 216 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 216 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 216 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 216 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 216 resolved as shift
WARNING: shift/reduce conflict for ID in state 217 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 217 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 217 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 217 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 217 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 217 resolved as shift
WARNING: shift/reduce conflict for ID in state 218 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 218 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 218 resolved as shift
WARNING: shift/reduce conflict for CTEC in state 218 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 218 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 218 resolved as shift
WARNING: reduce/reduce conflict in state 76 resolved using rule (add_id2 -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 76
WARNING: reduce/reduce conflict in state 129 resolved using rule (add_id2 -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 129
WARNING: reduce/reduce conflict in state 139 resolved using rule (add_id2 -> <empty>)
WARNING: rejected rule (validateFunctionID -> <empty>) in state 139
WARNING: reduce/reduce conflict in state 139 resolved using rule (add_id2 -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 139
WARNING: reduce/reduce conflict in state 163 resolved using rule (paramWrite -> empty)
WARNING: rejected rule (pexp -> empty) in state 163
WARNING: reduce/reduce conflict in state 192 resolved using rule (add_id2 -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 192
WARNING: reduce/reduce conflict in state 194 resolved using rule (generateAssignQuad -> <empty>)
WARNING: rejected rule (pexp -> functionCall) in state 194
WARNING: reduce/reduce conflict in state 198 resolved using rule (expAux -> empty)
WARNING: rejected rule (pexp -> empty) in state 198
