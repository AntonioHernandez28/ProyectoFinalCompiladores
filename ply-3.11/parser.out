Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CTEC
    END
    FROM
    MODA
    PLOTXY
    SIMPLEREGRESSION
    VARIANZA

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMMICOLON addProgram program1
Rule 2     addProgram -> <empty>
Rule 3     program1 -> vars functions program2
Rule 4     program1 -> vars functions
Rule 5     program1 -> program2
Rule 6     program2 -> principal
Rule 7     principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY
Rule 8     statements -> assign SEMMICOLON statements
Rule 9     statements -> functionCall SEMMICOLON statements
Rule 10    statements -> read statements SEMMICOLON statements
Rule 11    statements -> write statements SEMMICOLON statements
Rule 12    statements -> for statements
Rule 13    statements -> while statements
Rule 14    statements -> if statements
Rule 15    statements -> return statements
Rule 16    statements -> empty
Rule 17    assign -> ID add_id EQUALS exp
Rule 18    assign -> ID add_id arr EQUALS exp
Rule 19    add_id -> <empty>
Rule 20    functionCall -> ID LPAREN exp RPAREN
Rule 21    read -> READ LPAREN read1 RPAREN
Rule 22    read1 -> ID read2
Rule 23    read2 -> COMMA read1
Rule 24    read2 -> empty
Rule 25    media -> MEDIA LPAREN arr RPAREN SEMMICOLON
Rule 26    write -> WRITE LPAREN write1 RPAREN
Rule 27    write1 -> write2 COMMA write2
Rule 28    write1 -> write2
Rule 29    write2 -> CTESTRING
Rule 30    write2 -> CTEI
Rule 31    write2 -> CTEF
Rule 32    write2 -> exp
Rule 33    for -> FOR assign TO CTEI DO LCURLY statements RCURLY
Rule 34    while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
Rule 35    if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
Rule 36    else -> ELSE LCURLY statements RCURLY
Rule 37    else -> empty
Rule 38    exp -> nexp
Rule 39    exp -> nexp OR nexp
Rule 40    nexp -> compexp
Rule 41    nexp -> compexp AND compexp
Rule 42    compexp -> sumexp
Rule 43    compexp -> compexp1 sumexp
Rule 44    compexp1 -> sumexp GT saveOperator sumexp
Rule 45    compexp1 -> sumexp LT saveOperator sumexp
Rule 46    compexp1 -> sumexp GTE saveOperator sumexp
Rule 47    compexp1 -> sumexp LTE saveOperator sumexp
Rule 48    compexp1 -> sumexp NE saveOperator sumexp
Rule 49    sumexp -> mulexp
Rule 50    sumexp -> mulexp PLUS saveOperator mulexp
Rule 51    sumexp -> mulexp MINUS saveOperator mulexp
Rule 52    mulexp -> pexp
Rule 53    mulexp -> pexp MUL saveOperator pexp
Rule 54    mulexp -> pexp DIV saveOperator pexp
Rule 55    pexp -> var1
Rule 56    pexp -> CTEI
Rule 57    pexp -> CTEF
Rule 58    pexp -> functionCall
Rule 59    pexp -> LPAREN exp RPAREN
Rule 60    saveOperator -> <empty>
Rule 61    vars -> var
Rule 62    vars -> empty
Rule 63    var -> VARS var2
Rule 64    var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar
Rule 65    var2 -> empty
Rule 66    var1 -> ID
Rule 67    var1 -> ID COMMA var1 addVar
Rule 68    var1 -> ID arr
Rule 69    var1 -> ID arr COMMA var1 addVar
Rule 70    var1 -> empty
Rule 71    addVar -> <empty>
Rule 72    saveTypeVar -> <empty>
Rule 73    type -> INT saveTypeVar
Rule 74    type -> CHAR saveTypeVar
Rule 75    type -> FLOAT saveTypeVar
Rule 76    arr -> LBRACKET CTEI RBRACKET
Rule 77    arr -> LBRACKET exp RBRACKET
Rule 78    functions -> FUNCTION INT functions1 functions
Rule 79    functions -> FUNCTION CHAR functions1 functions
Rule 80    functions -> FUNCTION FLOAT functions1 functions
Rule 81    functions -> FUNCTION VOID functions1 functions
Rule 82    functions -> empty
Rule 83    functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY functions1
Rule 84    functions1 -> empty
Rule 85    saveFunction -> <empty>
Rule 86    args -> type TWOPOINTS args1
Rule 87    args -> empty
Rule 88    args1 -> ID
Rule 89    args1 -> ID COMMA args1
Rule 90    args1 -> empty
Rule 91    return -> RETURN LPAREN exp RPAREN SEMMICOLON
Rule 92    return -> RETURN LPAREN exp RPAREN
Rule 93    empty -> <empty>

Terminals, with rules where they appear

AND                  : 41
CHAR                 : 74 79
COMMA                : 23 27 67 69 89
CTEC                 : 
CTEF                 : 31 57
CTEI                 : 30 33 56 76
CTESTRING            : 29
DIV                  : 54
DO                   : 33 34
ELSE                 : 36
END                  : 
EQUALS               : 17 18
FLOAT                : 75 80
FOR                  : 33
FROM                 : 
FUNCTION             : 78 79 80 81
GT                   : 44
GTE                  : 46
ID                   : 1 17 18 20 22 66 67 68 69 83 88 89
IF                   : 35
INT                  : 73 78
LBRACKET             : 76 77
LCURLY               : 7 33 34 35 36 83
LPAREN               : 7 20 21 25 26 34 35 59 83 91 92
LT                   : 45
LTE                  : 47
MEDIA                : 25
MINUS                : 51
MODA                 : 
MUL                  : 53
NE                   : 48
OR                   : 39
PLOTXY               : 
PLUS                 : 50
PRINCIPAL            : 7
PROGRAM              : 1
RBRACKET             : 76 77
RCURLY               : 7 33 34 35 36 83
READ                 : 21
RETURN               : 91 92
RPAREN               : 7 20 21 25 26 34 35 59 83 91 92
SEMMICOLON           : 1 8 9 10 11 25 64 91
SIMPLEREGRESSION     : 
THEN                 : 35
TO                   : 33
TWOPOINTS            : 64 86
VARIANZA             : 
VARS                 : 63
VOID                 : 81
WHILE                : 34
WRITE                : 26
error                : 

Nonterminals, with rules where they appear

addProgram           : 1
addVar               : 64 67 69
add_id               : 17 18
args                 : 83
args1                : 86 89
arr                  : 18 25 68 69
assign               : 8 33
compexp              : 40 41 41
compexp1             : 43
else                 : 35
empty                : 16 24 37 62 65 70 82 84 87 90
exp                  : 17 18 20 32 34 35 59 77 91 92
for                  : 12
functionCall         : 9 58
functions            : 3 4 78 79 80 81
functions1           : 78 79 80 81 83
if                   : 14
media                : 
mulexp               : 49 50 50 51 51
nexp                 : 38 39 39
pexp                 : 52 53 53 54 54
principal            : 6
program              : 0
program1             : 1
program2             : 3 5
read                 : 10
read1                : 21 23
read2                : 22
return               : 15
saveFunction         : 83
saveOperator         : 44 45 46 47 48 50 51 53 54
saveTypeVar          : 73 74 75
statements           : 7 8 9 10 10 11 11 12 13 14 15 33 34 35 36 83
sumexp               : 42 43 44 44 45 45 46 46 47 47 48 48
type                 : 64 86
var                  : 61
var1                 : 55 64 67 69
var2                 : 63 64
vars                 : 3 4 7 83
while                : 13
write                : 11
write1               : 26
write2               : 27 27 28

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMMICOLON addProgram program1

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMMICOLON addProgram program1

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMMICOLON addProgram program1

    SEMMICOLON      shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMMICOLON . addProgram program1
    (2) addProgram -> .

    VARS            reduce using rule 2 (addProgram -> .)
    PRINCIPAL       reduce using rule 2 (addProgram -> .)
    FUNCTION        reduce using rule 2 (addProgram -> .)
    $end            reduce using rule 2 (addProgram -> .)

    addProgram                     shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMMICOLON addProgram . program1
    (3) program1 -> . vars functions program2
    (4) program1 -> . vars functions
    (5) program1 -> . program2
    (61) vars -> . var
    (62) vars -> . empty
    (6) program2 -> . principal
    (63) var -> . VARS var2
    (93) empty -> .
    (7) principal -> . PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY

  ! shift/reduce conflict for PRINCIPAL resolved as shift
    VARS            shift and go to state 12
    FUNCTION        reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)
    PRINCIPAL       shift and go to state 13

  ! PRINCIPAL       [ reduce using rule 93 (empty -> .) ]

    program1                       shift and go to state 6
    vars                           shift and go to state 7
    program2                       shift and go to state 8
    var                            shift and go to state 9
    empty                          shift and go to state 10
    principal                      shift and go to state 11

state 6

    (1) program -> PROGRAM ID SEMMICOLON addProgram program1 .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMMICOLON addProgram program1 .)


state 7

    (3) program1 -> vars . functions program2
    (4) program1 -> vars . functions
    (78) functions -> . FUNCTION INT functions1 functions
    (79) functions -> . FUNCTION CHAR functions1 functions
    (80) functions -> . FUNCTION FLOAT functions1 functions
    (81) functions -> . FUNCTION VOID functions1 functions
    (82) functions -> . empty
    (93) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)

    functions                      shift and go to state 14
    empty                          shift and go to state 16

state 8

    (5) program1 -> program2 .

    $end            reduce using rule 5 (program1 -> program2 .)


state 9

    (61) vars -> var .

    FUNCTION        reduce using rule 61 (vars -> var .)
    PRINCIPAL       reduce using rule 61 (vars -> var .)
    $end            reduce using rule 61 (vars -> var .)
    ID              reduce using rule 61 (vars -> var .)
    READ            reduce using rule 61 (vars -> var .)
    WRITE           reduce using rule 61 (vars -> var .)
    FOR             reduce using rule 61 (vars -> var .)
    WHILE           reduce using rule 61 (vars -> var .)
    IF              reduce using rule 61 (vars -> var .)
    RETURN          reduce using rule 61 (vars -> var .)
    RCURLY          reduce using rule 61 (vars -> var .)
    LCURLY          reduce using rule 61 (vars -> var .)


state 10

    (62) vars -> empty .

    FUNCTION        reduce using rule 62 (vars -> empty .)
    PRINCIPAL       reduce using rule 62 (vars -> empty .)
    $end            reduce using rule 62 (vars -> empty .)
    ID              reduce using rule 62 (vars -> empty .)
    READ            reduce using rule 62 (vars -> empty .)
    WRITE           reduce using rule 62 (vars -> empty .)
    FOR             reduce using rule 62 (vars -> empty .)
    WHILE           reduce using rule 62 (vars -> empty .)
    IF              reduce using rule 62 (vars -> empty .)
    RETURN          reduce using rule 62 (vars -> empty .)
    RCURLY          reduce using rule 62 (vars -> empty .)
    LCURLY          reduce using rule 62 (vars -> empty .)


state 11

    (6) program2 -> principal .

    $end            reduce using rule 6 (program2 -> principal .)


state 12

    (63) var -> VARS . var2
    (64) var2 -> . var2 type TWOPOINTS var1 SEMMICOLON addVar
    (65) var2 -> . empty
    (93) empty -> .

    INT             reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    FUNCTION        reduce using rule 93 (empty -> .)
    PRINCIPAL       reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    READ            reduce using rule 93 (empty -> .)
    WRITE           reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)
    LCURLY          reduce using rule 93 (empty -> .)

    var2                           shift and go to state 17
    empty                          shift and go to state 18

state 13

    (7) principal -> PRINCIPAL . LPAREN RPAREN LCURLY vars statements RCURLY

    LPAREN          shift and go to state 19


state 14

    (3) program1 -> vars functions . program2
    (4) program1 -> vars functions .
    (6) program2 -> . principal
    (7) principal -> . PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY

    $end            reduce using rule 4 (program1 -> vars functions .)
    PRINCIPAL       shift and go to state 13

    program2                       shift and go to state 20
    principal                      shift and go to state 11

state 15

    (78) functions -> FUNCTION . INT functions1 functions
    (79) functions -> FUNCTION . CHAR functions1 functions
    (80) functions -> FUNCTION . FLOAT functions1 functions
    (81) functions -> FUNCTION . VOID functions1 functions

    INT             shift and go to state 21
    CHAR            shift and go to state 22
    FLOAT           shift and go to state 23
    VOID            shift and go to state 24


state 16

    (82) functions -> empty .

    PRINCIPAL       reduce using rule 82 (functions -> empty .)
    $end            reduce using rule 82 (functions -> empty .)


state 17

    (63) var -> VARS var2 .
    (64) var2 -> var2 . type TWOPOINTS var1 SEMMICOLON addVar
    (73) type -> . INT saveTypeVar
    (74) type -> . CHAR saveTypeVar
    (75) type -> . FLOAT saveTypeVar

    FUNCTION        reduce using rule 63 (var -> VARS var2 .)
    PRINCIPAL       reduce using rule 63 (var -> VARS var2 .)
    $end            reduce using rule 63 (var -> VARS var2 .)
    ID              reduce using rule 63 (var -> VARS var2 .)
    READ            reduce using rule 63 (var -> VARS var2 .)
    WRITE           reduce using rule 63 (var -> VARS var2 .)
    FOR             reduce using rule 63 (var -> VARS var2 .)
    WHILE           reduce using rule 63 (var -> VARS var2 .)
    IF              reduce using rule 63 (var -> VARS var2 .)
    RETURN          reduce using rule 63 (var -> VARS var2 .)
    RCURLY          reduce using rule 63 (var -> VARS var2 .)
    LCURLY          reduce using rule 63 (var -> VARS var2 .)
    INT             shift and go to state 26
    CHAR            shift and go to state 27
    FLOAT           shift and go to state 28

    type                           shift and go to state 25

state 18

    (65) var2 -> empty .

    INT             reduce using rule 65 (var2 -> empty .)
    CHAR            reduce using rule 65 (var2 -> empty .)
    FLOAT           reduce using rule 65 (var2 -> empty .)
    FUNCTION        reduce using rule 65 (var2 -> empty .)
    PRINCIPAL       reduce using rule 65 (var2 -> empty .)
    $end            reduce using rule 65 (var2 -> empty .)
    ID              reduce using rule 65 (var2 -> empty .)
    READ            reduce using rule 65 (var2 -> empty .)
    WRITE           reduce using rule 65 (var2 -> empty .)
    FOR             reduce using rule 65 (var2 -> empty .)
    WHILE           reduce using rule 65 (var2 -> empty .)
    IF              reduce using rule 65 (var2 -> empty .)
    RETURN          reduce using rule 65 (var2 -> empty .)
    RCURLY          reduce using rule 65 (var2 -> empty .)
    LCURLY          reduce using rule 65 (var2 -> empty .)


state 19

    (7) principal -> PRINCIPAL LPAREN . RPAREN LCURLY vars statements RCURLY

    RPAREN          shift and go to state 29


state 20

    (3) program1 -> vars functions program2 .

    $end            reduce using rule 3 (program1 -> vars functions program2 .)


state 21

    (78) functions -> FUNCTION INT . functions1 functions
    (83) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY functions1
    (84) functions1 -> . empty
    (93) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 93 (empty -> .)
    PRINCIPAL       reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)

    functions1                     shift and go to state 30
    empty                          shift and go to state 32

state 22

    (79) functions -> FUNCTION CHAR . functions1 functions
    (83) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY functions1
    (84) functions1 -> . empty
    (93) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 93 (empty -> .)
    PRINCIPAL       reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)

    functions1                     shift and go to state 33
    empty                          shift and go to state 32

state 23

    (80) functions -> FUNCTION FLOAT . functions1 functions
    (83) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY functions1
    (84) functions1 -> . empty
    (93) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 93 (empty -> .)
    PRINCIPAL       reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)

    functions1                     shift and go to state 34
    empty                          shift and go to state 32

state 24

    (81) functions -> FUNCTION VOID . functions1 functions
    (83) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY functions1
    (84) functions1 -> . empty
    (93) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 93 (empty -> .)
    PRINCIPAL       reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)

    functions1                     shift and go to state 35
    empty                          shift and go to state 32

state 25

    (64) var2 -> var2 type . TWOPOINTS var1 SEMMICOLON addVar

    TWOPOINTS       shift and go to state 36


state 26

    (73) type -> INT . saveTypeVar
    (72) saveTypeVar -> .

    TWOPOINTS       reduce using rule 72 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 37

state 27

    (74) type -> CHAR . saveTypeVar
    (72) saveTypeVar -> .

    TWOPOINTS       reduce using rule 72 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 38

state 28

    (75) type -> FLOAT . saveTypeVar
    (72) saveTypeVar -> .

    TWOPOINTS       reduce using rule 72 (saveTypeVar -> .)

    saveTypeVar                    shift and go to state 39

state 29

    (7) principal -> PRINCIPAL LPAREN RPAREN . LCURLY vars statements RCURLY

    LCURLY          shift and go to state 40


state 30

    (78) functions -> FUNCTION INT functions1 . functions
    (78) functions -> . FUNCTION INT functions1 functions
    (79) functions -> . FUNCTION CHAR functions1 functions
    (80) functions -> . FUNCTION FLOAT functions1 functions
    (81) functions -> . FUNCTION VOID functions1 functions
    (82) functions -> . empty
    (93) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)

    functions                      shift and go to state 41
    empty                          shift and go to state 16

state 31

    (83) functions1 -> ID . saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY functions1
    (85) saveFunction -> .

    LPAREN          reduce using rule 85 (saveFunction -> .)

    saveFunction                   shift and go to state 42

state 32

    (84) functions1 -> empty .

    FUNCTION        reduce using rule 84 (functions1 -> empty .)
    PRINCIPAL       reduce using rule 84 (functions1 -> empty .)
    $end            reduce using rule 84 (functions1 -> empty .)


state 33

    (79) functions -> FUNCTION CHAR functions1 . functions
    (78) functions -> . FUNCTION INT functions1 functions
    (79) functions -> . FUNCTION CHAR functions1 functions
    (80) functions -> . FUNCTION FLOAT functions1 functions
    (81) functions -> . FUNCTION VOID functions1 functions
    (82) functions -> . empty
    (93) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)

    functions                      shift and go to state 43
    empty                          shift and go to state 16

state 34

    (80) functions -> FUNCTION FLOAT functions1 . functions
    (78) functions -> . FUNCTION INT functions1 functions
    (79) functions -> . FUNCTION CHAR functions1 functions
    (80) functions -> . FUNCTION FLOAT functions1 functions
    (81) functions -> . FUNCTION VOID functions1 functions
    (82) functions -> . empty
    (93) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)

    functions                      shift and go to state 44
    empty                          shift and go to state 16

state 35

    (81) functions -> FUNCTION VOID functions1 . functions
    (78) functions -> . FUNCTION INT functions1 functions
    (79) functions -> . FUNCTION CHAR functions1 functions
    (80) functions -> . FUNCTION FLOAT functions1 functions
    (81) functions -> . FUNCTION VOID functions1 functions
    (82) functions -> . empty
    (93) empty -> .

    FUNCTION        shift and go to state 15
    PRINCIPAL       reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)

    functions                      shift and go to state 45
    empty                          shift and go to state 16

state 36

    (64) var2 -> var2 type TWOPOINTS . var1 SEMMICOLON addVar
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (93) empty -> .

    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 93 (empty -> .)

    var1                           shift and go to state 46
    empty                          shift and go to state 48

state 37

    (73) type -> INT saveTypeVar .

    TWOPOINTS       reduce using rule 73 (type -> INT saveTypeVar .)


state 38

    (74) type -> CHAR saveTypeVar .

    TWOPOINTS       reduce using rule 74 (type -> CHAR saveTypeVar .)


state 39

    (75) type -> FLOAT saveTypeVar .

    TWOPOINTS       reduce using rule 75 (type -> FLOAT saveTypeVar .)


state 40

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY . vars statements RCURLY
    (61) vars -> . var
    (62) vars -> . empty
    (63) var -> . VARS var2
    (93) empty -> .

    VARS            shift and go to state 12
    ID              reduce using rule 93 (empty -> .)
    READ            reduce using rule 93 (empty -> .)
    WRITE           reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)

    vars                           shift and go to state 49
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 41

    (78) functions -> FUNCTION INT functions1 functions .

    PRINCIPAL       reduce using rule 78 (functions -> FUNCTION INT functions1 functions .)
    $end            reduce using rule 78 (functions -> FUNCTION INT functions1 functions .)


state 42

    (83) functions1 -> ID saveFunction . LPAREN args RPAREN vars LCURLY statements RCURLY functions1

    LPAREN          shift and go to state 50


state 43

    (79) functions -> FUNCTION CHAR functions1 functions .

    PRINCIPAL       reduce using rule 79 (functions -> FUNCTION CHAR functions1 functions .)
    $end            reduce using rule 79 (functions -> FUNCTION CHAR functions1 functions .)


state 44

    (80) functions -> FUNCTION FLOAT functions1 functions .

    PRINCIPAL       reduce using rule 80 (functions -> FUNCTION FLOAT functions1 functions .)
    $end            reduce using rule 80 (functions -> FUNCTION FLOAT functions1 functions .)


state 45

    (81) functions -> FUNCTION VOID functions1 functions .

    PRINCIPAL       reduce using rule 81 (functions -> FUNCTION VOID functions1 functions .)
    $end            reduce using rule 81 (functions -> FUNCTION VOID functions1 functions .)


state 46

    (64) var2 -> var2 type TWOPOINTS var1 . SEMMICOLON addVar

    SEMMICOLON      shift and go to state 51


state 47

    (66) var1 -> ID .
    (67) var1 -> ID . COMMA var1 addVar
    (68) var1 -> ID . arr
    (69) var1 -> ID . arr COMMA var1 addVar
    (76) arr -> . LBRACKET CTEI RBRACKET
    (77) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 66 (var1 -> ID .)
    MUL             reduce using rule 66 (var1 -> ID .)
    DIV             reduce using rule 66 (var1 -> ID .)
    PLUS            reduce using rule 66 (var1 -> ID .)
    MINUS           reduce using rule 66 (var1 -> ID .)
    GT              reduce using rule 66 (var1 -> ID .)
    LT              reduce using rule 66 (var1 -> ID .)
    GTE             reduce using rule 66 (var1 -> ID .)
    LTE             reduce using rule 66 (var1 -> ID .)
    NE              reduce using rule 66 (var1 -> ID .)
    AND             reduce using rule 66 (var1 -> ID .)
    OR              reduce using rule 66 (var1 -> ID .)
    RBRACKET        reduce using rule 66 (var1 -> ID .)
    RPAREN          reduce using rule 66 (var1 -> ID .)
    TO              reduce using rule 66 (var1 -> ID .)
    CTEI            reduce using rule 66 (var1 -> ID .)
    CTEF            reduce using rule 66 (var1 -> ID .)
    LPAREN          reduce using rule 66 (var1 -> ID .)
    ID              reduce using rule 66 (var1 -> ID .)
    COMMA           shift and go to state 52
    LBRACKET        shift and go to state 54

  ! COMMA           [ reduce using rule 66 (var1 -> ID .) ]

    arr                            shift and go to state 53

state 48

    (70) var1 -> empty .

    SEMMICOLON      reduce using rule 70 (var1 -> empty .)
    MUL             reduce using rule 70 (var1 -> empty .)
    DIV             reduce using rule 70 (var1 -> empty .)
    PLUS            reduce using rule 70 (var1 -> empty .)
    MINUS           reduce using rule 70 (var1 -> empty .)
    GT              reduce using rule 70 (var1 -> empty .)
    LT              reduce using rule 70 (var1 -> empty .)
    GTE             reduce using rule 70 (var1 -> empty .)
    LTE             reduce using rule 70 (var1 -> empty .)
    NE              reduce using rule 70 (var1 -> empty .)
    AND             reduce using rule 70 (var1 -> empty .)
    OR              reduce using rule 70 (var1 -> empty .)
    RBRACKET        reduce using rule 70 (var1 -> empty .)
    RPAREN          reduce using rule 70 (var1 -> empty .)
    COMMA           reduce using rule 70 (var1 -> empty .)
    TO              reduce using rule 70 (var1 -> empty .)
    CTEI            reduce using rule 70 (var1 -> empty .)
    CTEF            reduce using rule 70 (var1 -> empty .)
    LPAREN          reduce using rule 70 (var1 -> empty .)
    ID              reduce using rule 70 (var1 -> empty .)


state 49

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY vars . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)

    statements                     shift and go to state 55
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 50

    (83) functions1 -> ID saveFunction LPAREN . args RPAREN vars LCURLY statements RCURLY functions1
    (86) args -> . type TWOPOINTS args1
    (87) args -> . empty
    (73) type -> . INT saveTypeVar
    (74) type -> . CHAR saveTypeVar
    (75) type -> . FLOAT saveTypeVar
    (93) empty -> .

    INT             shift and go to state 26
    CHAR            shift and go to state 27
    FLOAT           shift and go to state 28
    RPAREN          reduce using rule 93 (empty -> .)

    args                           shift and go to state 72
    type                           shift and go to state 73
    empty                          shift and go to state 74

state 51

    (64) var2 -> var2 type TWOPOINTS var1 SEMMICOLON . addVar
    (71) addVar -> .

    INT             reduce using rule 71 (addVar -> .)
    CHAR            reduce using rule 71 (addVar -> .)
    FLOAT           reduce using rule 71 (addVar -> .)
    FUNCTION        reduce using rule 71 (addVar -> .)
    PRINCIPAL       reduce using rule 71 (addVar -> .)
    $end            reduce using rule 71 (addVar -> .)
    ID              reduce using rule 71 (addVar -> .)
    READ            reduce using rule 71 (addVar -> .)
    WRITE           reduce using rule 71 (addVar -> .)
    FOR             reduce using rule 71 (addVar -> .)
    WHILE           reduce using rule 71 (addVar -> .)
    IF              reduce using rule 71 (addVar -> .)
    RETURN          reduce using rule 71 (addVar -> .)
    RCURLY          reduce using rule 71 (addVar -> .)
    LCURLY          reduce using rule 71 (addVar -> .)

    addVar                         shift and go to state 75

state 52

    (67) var1 -> ID COMMA . var1 addVar
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (93) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 93 (empty -> .)
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    CTEI            reduce using rule 93 (empty -> .)
    CTEF            reduce using rule 93 (empty -> .)
    LPAREN          reduce using rule 93 (empty -> .)

  ! ID              [ reduce using rule 93 (empty -> .) ]

    var1                           shift and go to state 76
    empty                          shift and go to state 48

state 53

    (68) var1 -> ID arr .
    (69) var1 -> ID arr . COMMA var1 addVar

  ! shift/reduce conflict for COMMA resolved as shift
    SEMMICOLON      reduce using rule 68 (var1 -> ID arr .)
    MUL             reduce using rule 68 (var1 -> ID arr .)
    DIV             reduce using rule 68 (var1 -> ID arr .)
    PLUS            reduce using rule 68 (var1 -> ID arr .)
    MINUS           reduce using rule 68 (var1 -> ID arr .)
    GT              reduce using rule 68 (var1 -> ID arr .)
    LT              reduce using rule 68 (var1 -> ID arr .)
    GTE             reduce using rule 68 (var1 -> ID arr .)
    LTE             reduce using rule 68 (var1 -> ID arr .)
    NE              reduce using rule 68 (var1 -> ID arr .)
    AND             reduce using rule 68 (var1 -> ID arr .)
    OR              reduce using rule 68 (var1 -> ID arr .)
    RBRACKET        reduce using rule 68 (var1 -> ID arr .)
    RPAREN          reduce using rule 68 (var1 -> ID arr .)
    TO              reduce using rule 68 (var1 -> ID arr .)
    CTEI            reduce using rule 68 (var1 -> ID arr .)
    CTEF            reduce using rule 68 (var1 -> ID arr .)
    LPAREN          reduce using rule 68 (var1 -> ID arr .)
    ID              reduce using rule 68 (var1 -> ID arr .)
    COMMA           shift and go to state 77

  ! COMMA           [ reduce using rule 68 (var1 -> ID arr .) ]


state 54

    (76) arr -> LBRACKET . CTEI RBRACKET
    (77) arr -> LBRACKET . exp RBRACKET
    (38) exp -> . nexp
    (39) exp -> . nexp OR nexp
    (40) nexp -> . compexp
    (41) nexp -> . compexp AND compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTEI            shift and go to state 78
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)

    exp                            shift and go to state 79
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 55

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements . RCURLY

    RCURLY          shift and go to state 91


state 56

    (8) statements -> assign . SEMMICOLON statements

    SEMMICOLON      shift and go to state 92


state 57

    (9) statements -> functionCall . SEMMICOLON statements

    SEMMICOLON      shift and go to state 93


state 58

    (10) statements -> read . statements SEMMICOLON statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    SEMMICOLON      reduce using rule 93 (empty -> .)

    read                           shift and go to state 58
    statements                     shift and go to state 94
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 59

    (11) statements -> write . statements SEMMICOLON statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    SEMMICOLON      reduce using rule 93 (empty -> .)

    write                          shift and go to state 59
    statements                     shift and go to state 95
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 60

    (12) statements -> for . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)

    for                            shift and go to state 60
    statements                     shift and go to state 96
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 61

    (13) statements -> while . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)

    while                          shift and go to state 61
    statements                     shift and go to state 97
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 62

    (14) statements -> if . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)

    if                             shift and go to state 62
    statements                     shift and go to state 98
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 63

    (15) statements -> return . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)

    return                         shift and go to state 63
    statements                     shift and go to state 99
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    empty                          shift and go to state 64

state 64

    (16) statements -> empty .

    RCURLY          reduce using rule 16 (statements -> empty .)
    SEMMICOLON      reduce using rule 16 (statements -> empty .)


state 65

    (17) assign -> ID . add_id EQUALS exp
    (18) assign -> ID . add_id arr EQUALS exp
    (20) functionCall -> ID . LPAREN exp RPAREN
    (19) add_id -> .

    LPAREN          shift and go to state 101
    EQUALS          reduce using rule 19 (add_id -> .)
    LBRACKET        reduce using rule 19 (add_id -> .)

    add_id                         shift and go to state 100

state 66

    (21) read -> READ . LPAREN read1 RPAREN

    LPAREN          shift and go to state 102


state 67

    (26) write -> WRITE . LPAREN write1 RPAREN

    LPAREN          shift and go to state 103


state 68

    (33) for -> FOR . assign TO CTEI DO LCURLY statements RCURLY
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp

    ID              shift and go to state 105

    assign                         shift and go to state 104

state 69

    (34) while -> WHILE . LPAREN exp RPAREN DO LCURLY statements RCURLY

    LPAREN          shift and go to state 106


state 70

    (35) if -> IF . LPAREN exp RPAREN THEN LCURLY statements RCURLY else

    LPAREN          shift and go to state 107


state 71

    (91) return -> RETURN . LPAREN exp RPAREN SEMMICOLON
    (92) return -> RETURN . LPAREN exp RPAREN

    LPAREN          shift and go to state 108


state 72

    (83) functions1 -> ID saveFunction LPAREN args . RPAREN vars LCURLY statements RCURLY functions1

    RPAREN          shift and go to state 109


state 73

    (86) args -> type . TWOPOINTS args1

    TWOPOINTS       shift and go to state 110


state 74

    (87) args -> empty .

    RPAREN          reduce using rule 87 (args -> empty .)


state 75

    (64) var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .

    INT             reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    CHAR            reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FLOAT           reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FUNCTION        reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    PRINCIPAL       reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    $end            reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    ID              reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    READ            reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WRITE           reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    FOR             reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    WHILE           reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    IF              reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    RETURN          reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    RCURLY          reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)
    LCURLY          reduce using rule 64 (var2 -> var2 type TWOPOINTS var1 SEMMICOLON addVar .)


state 76

    (67) var1 -> ID COMMA var1 . addVar
    (71) addVar -> .

    SEMMICOLON      reduce using rule 71 (addVar -> .)
    MUL             reduce using rule 71 (addVar -> .)
    DIV             reduce using rule 71 (addVar -> .)
    PLUS            reduce using rule 71 (addVar -> .)
    MINUS           reduce using rule 71 (addVar -> .)
    GT              reduce using rule 71 (addVar -> .)
    LT              reduce using rule 71 (addVar -> .)
    GTE             reduce using rule 71 (addVar -> .)
    LTE             reduce using rule 71 (addVar -> .)
    NE              reduce using rule 71 (addVar -> .)
    AND             reduce using rule 71 (addVar -> .)
    OR              reduce using rule 71 (addVar -> .)
    RBRACKET        reduce using rule 71 (addVar -> .)
    RPAREN          reduce using rule 71 (addVar -> .)
    COMMA           reduce using rule 71 (addVar -> .)
    TO              reduce using rule 71 (addVar -> .)
    CTEI            reduce using rule 71 (addVar -> .)
    CTEF            reduce using rule 71 (addVar -> .)
    LPAREN          reduce using rule 71 (addVar -> .)
    ID              reduce using rule 71 (addVar -> .)

    addVar                         shift and go to state 111

state 77

    (69) var1 -> ID arr COMMA . var1 addVar
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (93) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 47
    SEMMICOLON      reduce using rule 93 (empty -> .)
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    CTEI            reduce using rule 93 (empty -> .)
    CTEF            reduce using rule 93 (empty -> .)
    LPAREN          reduce using rule 93 (empty -> .)

  ! ID              [ reduce using rule 93 (empty -> .) ]

    var1                           shift and go to state 112
    empty                          shift and go to state 48

state 78

    (76) arr -> LBRACKET CTEI . RBRACKET
    (56) pexp -> CTEI .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 113
    MUL             reduce using rule 56 (pexp -> CTEI .)
    DIV             reduce using rule 56 (pexp -> CTEI .)
    PLUS            reduce using rule 56 (pexp -> CTEI .)
    MINUS           reduce using rule 56 (pexp -> CTEI .)
    GT              reduce using rule 56 (pexp -> CTEI .)
    LT              reduce using rule 56 (pexp -> CTEI .)
    GTE             reduce using rule 56 (pexp -> CTEI .)
    LTE             reduce using rule 56 (pexp -> CTEI .)
    NE              reduce using rule 56 (pexp -> CTEI .)
    AND             reduce using rule 56 (pexp -> CTEI .)
    OR              reduce using rule 56 (pexp -> CTEI .)

  ! RBRACKET        [ reduce using rule 56 (pexp -> CTEI .) ]


state 79

    (77) arr -> LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 114


state 80

    (38) exp -> nexp .
    (39) exp -> nexp . OR nexp

    RBRACKET        reduce using rule 38 (exp -> nexp .)
    RPAREN          reduce using rule 38 (exp -> nexp .)
    COMMA           reduce using rule 38 (exp -> nexp .)
    SEMMICOLON      reduce using rule 38 (exp -> nexp .)
    TO              reduce using rule 38 (exp -> nexp .)
    OR              shift and go to state 115


state 81

    (40) nexp -> compexp .
    (41) nexp -> compexp . AND compexp

    OR              reduce using rule 40 (nexp -> compexp .)
    RBRACKET        reduce using rule 40 (nexp -> compexp .)
    RPAREN          reduce using rule 40 (nexp -> compexp .)
    COMMA           reduce using rule 40 (nexp -> compexp .)
    SEMMICOLON      reduce using rule 40 (nexp -> compexp .)
    TO              reduce using rule 40 (nexp -> compexp .)
    AND             shift and go to state 116


state 82

    (42) compexp -> sumexp .
    (44) compexp1 -> sumexp . GT saveOperator sumexp
    (45) compexp1 -> sumexp . LT saveOperator sumexp
    (46) compexp1 -> sumexp . GTE saveOperator sumexp
    (47) compexp1 -> sumexp . LTE saveOperator sumexp
    (48) compexp1 -> sumexp . NE saveOperator sumexp

    AND             reduce using rule 42 (compexp -> sumexp .)
    OR              reduce using rule 42 (compexp -> sumexp .)
    RBRACKET        reduce using rule 42 (compexp -> sumexp .)
    RPAREN          reduce using rule 42 (compexp -> sumexp .)
    COMMA           reduce using rule 42 (compexp -> sumexp .)
    SEMMICOLON      reduce using rule 42 (compexp -> sumexp .)
    TO              reduce using rule 42 (compexp -> sumexp .)
    GT              shift and go to state 117
    LT              shift and go to state 118
    GTE             shift and go to state 119
    LTE             shift and go to state 120
    NE              shift and go to state 121


state 83

    (43) compexp -> compexp1 . sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)

    sumexp                         shift and go to state 122
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 84

    (49) sumexp -> mulexp .
    (50) sumexp -> mulexp . PLUS saveOperator mulexp
    (51) sumexp -> mulexp . MINUS saveOperator mulexp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    GT              reduce using rule 49 (sumexp -> mulexp .)
    LT              reduce using rule 49 (sumexp -> mulexp .)
    GTE             reduce using rule 49 (sumexp -> mulexp .)
    LTE             reduce using rule 49 (sumexp -> mulexp .)
    NE              reduce using rule 49 (sumexp -> mulexp .)
    AND             reduce using rule 49 (sumexp -> mulexp .)
    OR              reduce using rule 49 (sumexp -> mulexp .)
    RBRACKET        reduce using rule 49 (sumexp -> mulexp .)
    RPAREN          reduce using rule 49 (sumexp -> mulexp .)
    COMMA           reduce using rule 49 (sumexp -> mulexp .)
    SEMMICOLON      reduce using rule 49 (sumexp -> mulexp .)
    TO              reduce using rule 49 (sumexp -> mulexp .)
    CTEI            reduce using rule 49 (sumexp -> mulexp .)
    CTEF            reduce using rule 49 (sumexp -> mulexp .)
    LPAREN          reduce using rule 49 (sumexp -> mulexp .)
    ID              reduce using rule 49 (sumexp -> mulexp .)
    MUL             reduce using rule 49 (sumexp -> mulexp .)
    DIV             reduce using rule 49 (sumexp -> mulexp .)
    PLUS            shift and go to state 124
    MINUS           shift and go to state 125

  ! PLUS            [ reduce using rule 49 (sumexp -> mulexp .) ]
  ! MINUS           [ reduce using rule 49 (sumexp -> mulexp .) ]


state 85

    (52) mulexp -> pexp .
    (53) mulexp -> pexp . MUL saveOperator pexp
    (54) mulexp -> pexp . DIV saveOperator pexp

  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
    PLUS            reduce using rule 52 (mulexp -> pexp .)
    MINUS           reduce using rule 52 (mulexp -> pexp .)
    GT              reduce using rule 52 (mulexp -> pexp .)
    LT              reduce using rule 52 (mulexp -> pexp .)
    GTE             reduce using rule 52 (mulexp -> pexp .)
    LTE             reduce using rule 52 (mulexp -> pexp .)
    NE              reduce using rule 52 (mulexp -> pexp .)
    AND             reduce using rule 52 (mulexp -> pexp .)
    OR              reduce using rule 52 (mulexp -> pexp .)
    RBRACKET        reduce using rule 52 (mulexp -> pexp .)
    RPAREN          reduce using rule 52 (mulexp -> pexp .)
    COMMA           reduce using rule 52 (mulexp -> pexp .)
    SEMMICOLON      reduce using rule 52 (mulexp -> pexp .)
    TO              reduce using rule 52 (mulexp -> pexp .)
    CTEI            reduce using rule 52 (mulexp -> pexp .)
    CTEF            reduce using rule 52 (mulexp -> pexp .)
    LPAREN          reduce using rule 52 (mulexp -> pexp .)
    ID              reduce using rule 52 (mulexp -> pexp .)
    MUL             shift and go to state 126
    DIV             shift and go to state 127

  ! MUL             [ reduce using rule 52 (mulexp -> pexp .) ]
  ! DIV             [ reduce using rule 52 (mulexp -> pexp .) ]


state 86

    (55) pexp -> var1 .

    MUL             reduce using rule 55 (pexp -> var1 .)
    DIV             reduce using rule 55 (pexp -> var1 .)
    PLUS            reduce using rule 55 (pexp -> var1 .)
    MINUS           reduce using rule 55 (pexp -> var1 .)
    GT              reduce using rule 55 (pexp -> var1 .)
    LT              reduce using rule 55 (pexp -> var1 .)
    GTE             reduce using rule 55 (pexp -> var1 .)
    LTE             reduce using rule 55 (pexp -> var1 .)
    NE              reduce using rule 55 (pexp -> var1 .)
    AND             reduce using rule 55 (pexp -> var1 .)
    OR              reduce using rule 55 (pexp -> var1 .)
    RBRACKET        reduce using rule 55 (pexp -> var1 .)
    RPAREN          reduce using rule 55 (pexp -> var1 .)
    COMMA           reduce using rule 55 (pexp -> var1 .)
    SEMMICOLON      reduce using rule 55 (pexp -> var1 .)
    TO              reduce using rule 55 (pexp -> var1 .)
    CTEI            reduce using rule 55 (pexp -> var1 .)
    CTEF            reduce using rule 55 (pexp -> var1 .)
    LPAREN          reduce using rule 55 (pexp -> var1 .)
    ID              reduce using rule 55 (pexp -> var1 .)


state 87

    (57) pexp -> CTEF .

    MUL             reduce using rule 57 (pexp -> CTEF .)
    DIV             reduce using rule 57 (pexp -> CTEF .)
    PLUS            reduce using rule 57 (pexp -> CTEF .)
    MINUS           reduce using rule 57 (pexp -> CTEF .)
    GT              reduce using rule 57 (pexp -> CTEF .)
    LT              reduce using rule 57 (pexp -> CTEF .)
    GTE             reduce using rule 57 (pexp -> CTEF .)
    LTE             reduce using rule 57 (pexp -> CTEF .)
    NE              reduce using rule 57 (pexp -> CTEF .)
    AND             reduce using rule 57 (pexp -> CTEF .)
    OR              reduce using rule 57 (pexp -> CTEF .)
    RBRACKET        reduce using rule 57 (pexp -> CTEF .)
    RPAREN          reduce using rule 57 (pexp -> CTEF .)
    COMMA           reduce using rule 57 (pexp -> CTEF .)
    SEMMICOLON      reduce using rule 57 (pexp -> CTEF .)
    TO              reduce using rule 57 (pexp -> CTEF .)
    CTEI            reduce using rule 57 (pexp -> CTEF .)
    CTEF            reduce using rule 57 (pexp -> CTEF .)
    LPAREN          reduce using rule 57 (pexp -> CTEF .)
    ID              reduce using rule 57 (pexp -> CTEF .)


state 88

    (58) pexp -> functionCall .

    MUL             reduce using rule 58 (pexp -> functionCall .)
    DIV             reduce using rule 58 (pexp -> functionCall .)
    PLUS            reduce using rule 58 (pexp -> functionCall .)
    MINUS           reduce using rule 58 (pexp -> functionCall .)
    GT              reduce using rule 58 (pexp -> functionCall .)
    LT              reduce using rule 58 (pexp -> functionCall .)
    GTE             reduce using rule 58 (pexp -> functionCall .)
    LTE             reduce using rule 58 (pexp -> functionCall .)
    NE              reduce using rule 58 (pexp -> functionCall .)
    AND             reduce using rule 58 (pexp -> functionCall .)
    OR              reduce using rule 58 (pexp -> functionCall .)
    RBRACKET        reduce using rule 58 (pexp -> functionCall .)
    RPAREN          reduce using rule 58 (pexp -> functionCall .)
    COMMA           reduce using rule 58 (pexp -> functionCall .)
    SEMMICOLON      reduce using rule 58 (pexp -> functionCall .)
    TO              reduce using rule 58 (pexp -> functionCall .)
    CTEI            reduce using rule 58 (pexp -> functionCall .)
    CTEF            reduce using rule 58 (pexp -> functionCall .)
    LPAREN          reduce using rule 58 (pexp -> functionCall .)
    ID              reduce using rule 58 (pexp -> functionCall .)


state 89

    (59) pexp -> LPAREN . exp RPAREN
    (38) exp -> . nexp
    (39) exp -> . nexp OR nexp
    (40) nexp -> . compexp
    (41) nexp -> . compexp AND compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    exp                            shift and go to state 128
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 90

    (66) var1 -> ID .
    (67) var1 -> ID . COMMA var1 addVar
    (68) var1 -> ID . arr
    (69) var1 -> ID . arr COMMA var1 addVar
    (20) functionCall -> ID . LPAREN exp RPAREN
    (76) arr -> . LBRACKET CTEI RBRACKET
    (77) arr -> . LBRACKET exp RBRACKET

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    MUL             reduce using rule 66 (var1 -> ID .)
    DIV             reduce using rule 66 (var1 -> ID .)
    PLUS            reduce using rule 66 (var1 -> ID .)
    MINUS           reduce using rule 66 (var1 -> ID .)
    GT              reduce using rule 66 (var1 -> ID .)
    LT              reduce using rule 66 (var1 -> ID .)
    GTE             reduce using rule 66 (var1 -> ID .)
    LTE             reduce using rule 66 (var1 -> ID .)
    NE              reduce using rule 66 (var1 -> ID .)
    AND             reduce using rule 66 (var1 -> ID .)
    OR              reduce using rule 66 (var1 -> ID .)
    RBRACKET        reduce using rule 66 (var1 -> ID .)
    RPAREN          reduce using rule 66 (var1 -> ID .)
    SEMMICOLON      reduce using rule 66 (var1 -> ID .)
    TO              reduce using rule 66 (var1 -> ID .)
    CTEI            reduce using rule 66 (var1 -> ID .)
    CTEF            reduce using rule 66 (var1 -> ID .)
    ID              reduce using rule 66 (var1 -> ID .)
    COMMA           shift and go to state 52
    LPAREN          shift and go to state 101
    LBRACKET        shift and go to state 54

  ! COMMA           [ reduce using rule 66 (var1 -> ID .) ]
  ! LPAREN          [ reduce using rule 66 (var1 -> ID .) ]

    arr                            shift and go to state 53

state 91

    (7) principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY .

    $end            reduce using rule 7 (principal -> PRINCIPAL LPAREN RPAREN LCURLY vars statements RCURLY .)


state 92

    (8) statements -> assign SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)

    assign                         shift and go to state 56
    statements                     shift and go to state 129
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 93

    (9) statements -> functionCall SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)

    functionCall                   shift and go to state 57
    statements                     shift and go to state 130
    assign                         shift and go to state 56
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 94

    (10) statements -> read statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 131


state 95

    (11) statements -> write statements . SEMMICOLON statements

    SEMMICOLON      shift and go to state 132


state 96

    (12) statements -> for statements .

    RCURLY          reduce using rule 12 (statements -> for statements .)
    SEMMICOLON      reduce using rule 12 (statements -> for statements .)


state 97

    (13) statements -> while statements .

    RCURLY          reduce using rule 13 (statements -> while statements .)
    SEMMICOLON      reduce using rule 13 (statements -> while statements .)


state 98

    (14) statements -> if statements .

    RCURLY          reduce using rule 14 (statements -> if statements .)
    SEMMICOLON      reduce using rule 14 (statements -> if statements .)


state 99

    (15) statements -> return statements .

    RCURLY          reduce using rule 15 (statements -> return statements .)
    SEMMICOLON      reduce using rule 15 (statements -> return statements .)


state 100

    (17) assign -> ID add_id . EQUALS exp
    (18) assign -> ID add_id . arr EQUALS exp
    (76) arr -> . LBRACKET CTEI RBRACKET
    (77) arr -> . LBRACKET exp RBRACKET

    EQUALS          shift and go to state 133
    LBRACKET        shift and go to state 54

    arr                            shift and go to state 134

state 101

    (20) functionCall -> ID LPAREN . exp RPAREN
    (38) exp -> . nexp
    (39) exp -> . nexp OR nexp
    (40) nexp -> . compexp
    (41) nexp -> . compexp AND compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    exp                            shift and go to state 135
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 102

    (21) read -> READ LPAREN . read1 RPAREN
    (22) read1 -> . ID read2

    ID              shift and go to state 137

    read1                          shift and go to state 136

state 103

    (26) write -> WRITE LPAREN . write1 RPAREN
    (27) write1 -> . write2 COMMA write2
    (28) write1 -> . write2
    (29) write2 -> . CTESTRING
    (30) write2 -> . CTEI
    (31) write2 -> . CTEF
    (32) write2 -> . exp
    (38) exp -> . nexp
    (39) exp -> . nexp OR nexp
    (40) nexp -> . compexp
    (41) nexp -> . compexp AND compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTESTRING       shift and go to state 140
    CTEI            shift and go to state 141
    CTEF            shift and go to state 142
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    write1                         shift and go to state 138
    write2                         shift and go to state 139
    exp                            shift and go to state 143
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 104

    (33) for -> FOR assign . TO CTEI DO LCURLY statements RCURLY

    TO              shift and go to state 144


state 105

    (17) assign -> ID . add_id EQUALS exp
    (18) assign -> ID . add_id arr EQUALS exp
    (19) add_id -> .

    EQUALS          reduce using rule 19 (add_id -> .)
    LBRACKET        reduce using rule 19 (add_id -> .)

    add_id                         shift and go to state 100

state 106

    (34) while -> WHILE LPAREN . exp RPAREN DO LCURLY statements RCURLY
    (38) exp -> . nexp
    (39) exp -> . nexp OR nexp
    (40) nexp -> . compexp
    (41) nexp -> . compexp AND compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    exp                            shift and go to state 145
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 107

    (35) if -> IF LPAREN . exp RPAREN THEN LCURLY statements RCURLY else
    (38) exp -> . nexp
    (39) exp -> . nexp OR nexp
    (40) nexp -> . compexp
    (41) nexp -> . compexp AND compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    exp                            shift and go to state 146
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 108

    (91) return -> RETURN LPAREN . exp RPAREN SEMMICOLON
    (92) return -> RETURN LPAREN . exp RPAREN
    (38) exp -> . nexp
    (39) exp -> . nexp OR nexp
    (40) nexp -> . compexp
    (41) nexp -> . compexp AND compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    exp                            shift and go to state 147
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 109

    (83) functions1 -> ID saveFunction LPAREN args RPAREN . vars LCURLY statements RCURLY functions1
    (61) vars -> . var
    (62) vars -> . empty
    (63) var -> . VARS var2
    (93) empty -> .

    VARS            shift and go to state 12
    LCURLY          reduce using rule 93 (empty -> .)

    vars                           shift and go to state 148
    var                            shift and go to state 9
    empty                          shift and go to state 10

state 110

    (86) args -> type TWOPOINTS . args1
    (88) args1 -> . ID
    (89) args1 -> . ID COMMA args1
    (90) args1 -> . empty
    (93) empty -> .

    ID              shift and go to state 150
    RPAREN          reduce using rule 93 (empty -> .)

    args1                          shift and go to state 149
    empty                          shift and go to state 151

state 111

    (67) var1 -> ID COMMA var1 addVar .

    SEMMICOLON      reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    MUL             reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    DIV             reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    PLUS            reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    MINUS           reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    GT              reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    LT              reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    GTE             reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    LTE             reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    NE              reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    AND             reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    OR              reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    RBRACKET        reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    RPAREN          reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    COMMA           reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    TO              reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    CTEI            reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    CTEF            reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    LPAREN          reduce using rule 67 (var1 -> ID COMMA var1 addVar .)
    ID              reduce using rule 67 (var1 -> ID COMMA var1 addVar .)


state 112

    (69) var1 -> ID arr COMMA var1 . addVar
    (71) addVar -> .

    SEMMICOLON      reduce using rule 71 (addVar -> .)
    MUL             reduce using rule 71 (addVar -> .)
    DIV             reduce using rule 71 (addVar -> .)
    PLUS            reduce using rule 71 (addVar -> .)
    MINUS           reduce using rule 71 (addVar -> .)
    GT              reduce using rule 71 (addVar -> .)
    LT              reduce using rule 71 (addVar -> .)
    GTE             reduce using rule 71 (addVar -> .)
    LTE             reduce using rule 71 (addVar -> .)
    NE              reduce using rule 71 (addVar -> .)
    AND             reduce using rule 71 (addVar -> .)
    OR              reduce using rule 71 (addVar -> .)
    RBRACKET        reduce using rule 71 (addVar -> .)
    RPAREN          reduce using rule 71 (addVar -> .)
    COMMA           reduce using rule 71 (addVar -> .)
    TO              reduce using rule 71 (addVar -> .)
    CTEI            reduce using rule 71 (addVar -> .)
    CTEF            reduce using rule 71 (addVar -> .)
    LPAREN          reduce using rule 71 (addVar -> .)
    ID              reduce using rule 71 (addVar -> .)

    addVar                         shift and go to state 152

state 113

    (76) arr -> LBRACKET CTEI RBRACKET .

    COMMA           reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    SEMMICOLON      reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    MUL             reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    DIV             reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    PLUS            reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    MINUS           reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    GT              reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    LT              reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    GTE             reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    LTE             reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    NE              reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    AND             reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    OR              reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    RBRACKET        reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    RPAREN          reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    TO              reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    CTEI            reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    CTEF            reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    LPAREN          reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    ID              reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)
    EQUALS          reduce using rule 76 (arr -> LBRACKET CTEI RBRACKET .)


state 114

    (77) arr -> LBRACKET exp RBRACKET .

    COMMA           reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    SEMMICOLON      reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    MUL             reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    DIV             reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    GT              reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    LT              reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    GTE             reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    LTE             reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    NE              reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    AND             reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    OR              reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    TO              reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    CTEI            reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    CTEF            reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    ID              reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)
    EQUALS          reduce using rule 77 (arr -> LBRACKET exp RBRACKET .)


state 115

    (39) exp -> nexp OR . nexp
    (40) nexp -> . compexp
    (41) nexp -> . compexp AND compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)

    nexp                           shift and go to state 153
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 116

    (41) nexp -> compexp AND . compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)

    compexp                        shift and go to state 154
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 117

    (44) compexp1 -> sumexp GT . saveOperator sumexp
    (60) saveOperator -> .

    CTEI            reduce using rule 60 (saveOperator -> .)
    CTEF            reduce using rule 60 (saveOperator -> .)
    LPAREN          reduce using rule 60 (saveOperator -> .)
    ID              reduce using rule 60 (saveOperator -> .)
    PLUS            reduce using rule 60 (saveOperator -> .)
    MINUS           reduce using rule 60 (saveOperator -> .)
    MUL             reduce using rule 60 (saveOperator -> .)
    DIV             reduce using rule 60 (saveOperator -> .)
    AND             reduce using rule 60 (saveOperator -> .)
    OR              reduce using rule 60 (saveOperator -> .)
    RBRACKET        reduce using rule 60 (saveOperator -> .)
    RPAREN          reduce using rule 60 (saveOperator -> .)
    COMMA           reduce using rule 60 (saveOperator -> .)
    SEMMICOLON      reduce using rule 60 (saveOperator -> .)
    TO              reduce using rule 60 (saveOperator -> .)

    saveOperator                   shift and go to state 155

state 118

    (45) compexp1 -> sumexp LT . saveOperator sumexp
    (60) saveOperator -> .

    CTEI            reduce using rule 60 (saveOperator -> .)
    CTEF            reduce using rule 60 (saveOperator -> .)
    LPAREN          reduce using rule 60 (saveOperator -> .)
    ID              reduce using rule 60 (saveOperator -> .)
    PLUS            reduce using rule 60 (saveOperator -> .)
    MINUS           reduce using rule 60 (saveOperator -> .)
    MUL             reduce using rule 60 (saveOperator -> .)
    DIV             reduce using rule 60 (saveOperator -> .)
    AND             reduce using rule 60 (saveOperator -> .)
    OR              reduce using rule 60 (saveOperator -> .)
    RBRACKET        reduce using rule 60 (saveOperator -> .)
    RPAREN          reduce using rule 60 (saveOperator -> .)
    COMMA           reduce using rule 60 (saveOperator -> .)
    SEMMICOLON      reduce using rule 60 (saveOperator -> .)
    TO              reduce using rule 60 (saveOperator -> .)

    saveOperator                   shift and go to state 156

state 119

    (46) compexp1 -> sumexp GTE . saveOperator sumexp
    (60) saveOperator -> .

    CTEI            reduce using rule 60 (saveOperator -> .)
    CTEF            reduce using rule 60 (saveOperator -> .)
    LPAREN          reduce using rule 60 (saveOperator -> .)
    ID              reduce using rule 60 (saveOperator -> .)
    PLUS            reduce using rule 60 (saveOperator -> .)
    MINUS           reduce using rule 60 (saveOperator -> .)
    MUL             reduce using rule 60 (saveOperator -> .)
    DIV             reduce using rule 60 (saveOperator -> .)
    AND             reduce using rule 60 (saveOperator -> .)
    OR              reduce using rule 60 (saveOperator -> .)
    RBRACKET        reduce using rule 60 (saveOperator -> .)
    RPAREN          reduce using rule 60 (saveOperator -> .)
    COMMA           reduce using rule 60 (saveOperator -> .)
    SEMMICOLON      reduce using rule 60 (saveOperator -> .)
    TO              reduce using rule 60 (saveOperator -> .)

    saveOperator                   shift and go to state 157

state 120

    (47) compexp1 -> sumexp LTE . saveOperator sumexp
    (60) saveOperator -> .

    CTEI            reduce using rule 60 (saveOperator -> .)
    CTEF            reduce using rule 60 (saveOperator -> .)
    LPAREN          reduce using rule 60 (saveOperator -> .)
    ID              reduce using rule 60 (saveOperator -> .)
    PLUS            reduce using rule 60 (saveOperator -> .)
    MINUS           reduce using rule 60 (saveOperator -> .)
    MUL             reduce using rule 60 (saveOperator -> .)
    DIV             reduce using rule 60 (saveOperator -> .)
    AND             reduce using rule 60 (saveOperator -> .)
    OR              reduce using rule 60 (saveOperator -> .)
    RBRACKET        reduce using rule 60 (saveOperator -> .)
    RPAREN          reduce using rule 60 (saveOperator -> .)
    COMMA           reduce using rule 60 (saveOperator -> .)
    SEMMICOLON      reduce using rule 60 (saveOperator -> .)
    TO              reduce using rule 60 (saveOperator -> .)

    saveOperator                   shift and go to state 158

state 121

    (48) compexp1 -> sumexp NE . saveOperator sumexp
    (60) saveOperator -> .

    CTEI            reduce using rule 60 (saveOperator -> .)
    CTEF            reduce using rule 60 (saveOperator -> .)
    LPAREN          reduce using rule 60 (saveOperator -> .)
    ID              reduce using rule 60 (saveOperator -> .)
    PLUS            reduce using rule 60 (saveOperator -> .)
    MINUS           reduce using rule 60 (saveOperator -> .)
    MUL             reduce using rule 60 (saveOperator -> .)
    DIV             reduce using rule 60 (saveOperator -> .)
    AND             reduce using rule 60 (saveOperator -> .)
    OR              reduce using rule 60 (saveOperator -> .)
    RBRACKET        reduce using rule 60 (saveOperator -> .)
    RPAREN          reduce using rule 60 (saveOperator -> .)
    COMMA           reduce using rule 60 (saveOperator -> .)
    SEMMICOLON      reduce using rule 60 (saveOperator -> .)
    TO              reduce using rule 60 (saveOperator -> .)

    saveOperator                   shift and go to state 159

state 122

    (43) compexp -> compexp1 sumexp .

    AND             reduce using rule 43 (compexp -> compexp1 sumexp .)
    OR              reduce using rule 43 (compexp -> compexp1 sumexp .)
    RBRACKET        reduce using rule 43 (compexp -> compexp1 sumexp .)
    RPAREN          reduce using rule 43 (compexp -> compexp1 sumexp .)
    COMMA           reduce using rule 43 (compexp -> compexp1 sumexp .)
    SEMMICOLON      reduce using rule 43 (compexp -> compexp1 sumexp .)
    TO              reduce using rule 43 (compexp -> compexp1 sumexp .)


state 123

    (56) pexp -> CTEI .

    MUL             reduce using rule 56 (pexp -> CTEI .)
    DIV             reduce using rule 56 (pexp -> CTEI .)
    PLUS            reduce using rule 56 (pexp -> CTEI .)
    MINUS           reduce using rule 56 (pexp -> CTEI .)
    AND             reduce using rule 56 (pexp -> CTEI .)
    OR              reduce using rule 56 (pexp -> CTEI .)
    RBRACKET        reduce using rule 56 (pexp -> CTEI .)
    RPAREN          reduce using rule 56 (pexp -> CTEI .)
    COMMA           reduce using rule 56 (pexp -> CTEI .)
    SEMMICOLON      reduce using rule 56 (pexp -> CTEI .)
    TO              reduce using rule 56 (pexp -> CTEI .)
    GT              reduce using rule 56 (pexp -> CTEI .)
    LT              reduce using rule 56 (pexp -> CTEI .)
    GTE             reduce using rule 56 (pexp -> CTEI .)
    LTE             reduce using rule 56 (pexp -> CTEI .)
    NE              reduce using rule 56 (pexp -> CTEI .)
    CTEI            reduce using rule 56 (pexp -> CTEI .)
    CTEF            reduce using rule 56 (pexp -> CTEI .)
    LPAREN          reduce using rule 56 (pexp -> CTEI .)
    ID              reduce using rule 56 (pexp -> CTEI .)


state 124

    (50) sumexp -> mulexp PLUS . saveOperator mulexp
    (60) saveOperator -> .

    CTEI            reduce using rule 60 (saveOperator -> .)
    CTEF            reduce using rule 60 (saveOperator -> .)
    LPAREN          reduce using rule 60 (saveOperator -> .)
    ID              reduce using rule 60 (saveOperator -> .)
    MUL             reduce using rule 60 (saveOperator -> .)
    DIV             reduce using rule 60 (saveOperator -> .)
    GT              reduce using rule 60 (saveOperator -> .)
    LT              reduce using rule 60 (saveOperator -> .)
    GTE             reduce using rule 60 (saveOperator -> .)
    LTE             reduce using rule 60 (saveOperator -> .)
    NE              reduce using rule 60 (saveOperator -> .)
    AND             reduce using rule 60 (saveOperator -> .)
    OR              reduce using rule 60 (saveOperator -> .)
    RBRACKET        reduce using rule 60 (saveOperator -> .)
    RPAREN          reduce using rule 60 (saveOperator -> .)
    COMMA           reduce using rule 60 (saveOperator -> .)
    SEMMICOLON      reduce using rule 60 (saveOperator -> .)
    TO              reduce using rule 60 (saveOperator -> .)
    PLUS            reduce using rule 60 (saveOperator -> .)
    MINUS           reduce using rule 60 (saveOperator -> .)

    saveOperator                   shift and go to state 160

state 125

    (51) sumexp -> mulexp MINUS . saveOperator mulexp
    (60) saveOperator -> .

    CTEI            reduce using rule 60 (saveOperator -> .)
    CTEF            reduce using rule 60 (saveOperator -> .)
    LPAREN          reduce using rule 60 (saveOperator -> .)
    ID              reduce using rule 60 (saveOperator -> .)
    MUL             reduce using rule 60 (saveOperator -> .)
    DIV             reduce using rule 60 (saveOperator -> .)
    GT              reduce using rule 60 (saveOperator -> .)
    LT              reduce using rule 60 (saveOperator -> .)
    GTE             reduce using rule 60 (saveOperator -> .)
    LTE             reduce using rule 60 (saveOperator -> .)
    NE              reduce using rule 60 (saveOperator -> .)
    AND             reduce using rule 60 (saveOperator -> .)
    OR              reduce using rule 60 (saveOperator -> .)
    RBRACKET        reduce using rule 60 (saveOperator -> .)
    RPAREN          reduce using rule 60 (saveOperator -> .)
    COMMA           reduce using rule 60 (saveOperator -> .)
    SEMMICOLON      reduce using rule 60 (saveOperator -> .)
    TO              reduce using rule 60 (saveOperator -> .)
    PLUS            reduce using rule 60 (saveOperator -> .)
    MINUS           reduce using rule 60 (saveOperator -> .)

    saveOperator                   shift and go to state 161

state 126

    (53) mulexp -> pexp MUL . saveOperator pexp
    (60) saveOperator -> .

    CTEI            reduce using rule 60 (saveOperator -> .)
    CTEF            reduce using rule 60 (saveOperator -> .)
    LPAREN          reduce using rule 60 (saveOperator -> .)
    ID              reduce using rule 60 (saveOperator -> .)
    PLUS            reduce using rule 60 (saveOperator -> .)
    MINUS           reduce using rule 60 (saveOperator -> .)
    GT              reduce using rule 60 (saveOperator -> .)
    LT              reduce using rule 60 (saveOperator -> .)
    GTE             reduce using rule 60 (saveOperator -> .)
    LTE             reduce using rule 60 (saveOperator -> .)
    NE              reduce using rule 60 (saveOperator -> .)
    AND             reduce using rule 60 (saveOperator -> .)
    OR              reduce using rule 60 (saveOperator -> .)
    RBRACKET        reduce using rule 60 (saveOperator -> .)
    RPAREN          reduce using rule 60 (saveOperator -> .)
    COMMA           reduce using rule 60 (saveOperator -> .)
    SEMMICOLON      reduce using rule 60 (saveOperator -> .)
    TO              reduce using rule 60 (saveOperator -> .)
    MUL             reduce using rule 60 (saveOperator -> .)
    DIV             reduce using rule 60 (saveOperator -> .)

    saveOperator                   shift and go to state 162

state 127

    (54) mulexp -> pexp DIV . saveOperator pexp
    (60) saveOperator -> .

    CTEI            reduce using rule 60 (saveOperator -> .)
    CTEF            reduce using rule 60 (saveOperator -> .)
    LPAREN          reduce using rule 60 (saveOperator -> .)
    ID              reduce using rule 60 (saveOperator -> .)
    PLUS            reduce using rule 60 (saveOperator -> .)
    MINUS           reduce using rule 60 (saveOperator -> .)
    GT              reduce using rule 60 (saveOperator -> .)
    LT              reduce using rule 60 (saveOperator -> .)
    GTE             reduce using rule 60 (saveOperator -> .)
    LTE             reduce using rule 60 (saveOperator -> .)
    NE              reduce using rule 60 (saveOperator -> .)
    AND             reduce using rule 60 (saveOperator -> .)
    OR              reduce using rule 60 (saveOperator -> .)
    RBRACKET        reduce using rule 60 (saveOperator -> .)
    RPAREN          reduce using rule 60 (saveOperator -> .)
    COMMA           reduce using rule 60 (saveOperator -> .)
    SEMMICOLON      reduce using rule 60 (saveOperator -> .)
    TO              reduce using rule 60 (saveOperator -> .)
    MUL             reduce using rule 60 (saveOperator -> .)
    DIV             reduce using rule 60 (saveOperator -> .)

    saveOperator                   shift and go to state 163

state 128

    (59) pexp -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 164


state 129

    (8) statements -> assign SEMMICOLON statements .

    RCURLY          reduce using rule 8 (statements -> assign SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 8 (statements -> assign SEMMICOLON statements .)


state 130

    (9) statements -> functionCall SEMMICOLON statements .

    RCURLY          reduce using rule 9 (statements -> functionCall SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 9 (statements -> functionCall SEMMICOLON statements .)


state 131

    (10) statements -> read statements SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)

    read                           shift and go to state 58
    statements                     shift and go to state 165
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 132

    (11) statements -> write statements SEMMICOLON . statements
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)

    write                          shift and go to state 59
    statements                     shift and go to state 166
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 133

    (17) assign -> ID add_id EQUALS . exp
    (38) exp -> . nexp
    (39) exp -> . nexp OR nexp
    (40) nexp -> . compexp
    (41) nexp -> . compexp AND compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)

    exp                            shift and go to state 167
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 134

    (18) assign -> ID add_id arr . EQUALS exp

    EQUALS          shift and go to state 168


state 135

    (20) functionCall -> ID LPAREN exp . RPAREN

    RPAREN          shift and go to state 169


state 136

    (21) read -> READ LPAREN read1 . RPAREN

    RPAREN          shift and go to state 170


state 137

    (22) read1 -> ID . read2
    (23) read2 -> . COMMA read1
    (24) read2 -> . empty
    (93) empty -> .

    COMMA           shift and go to state 172
    RPAREN          reduce using rule 93 (empty -> .)

    read2                          shift and go to state 171
    empty                          shift and go to state 173

state 138

    (26) write -> WRITE LPAREN write1 . RPAREN

    RPAREN          shift and go to state 174


state 139

    (27) write1 -> write2 . COMMA write2
    (28) write1 -> write2 .

    COMMA           shift and go to state 175
    RPAREN          reduce using rule 28 (write1 -> write2 .)


state 140

    (29) write2 -> CTESTRING .

    COMMA           reduce using rule 29 (write2 -> CTESTRING .)
    RPAREN          reduce using rule 29 (write2 -> CTESTRING .)


state 141

    (30) write2 -> CTEI .
    (56) pexp -> CTEI .

  ! reduce/reduce conflict for COMMA resolved using rule 30 (write2 -> CTEI .)
  ! reduce/reduce conflict for RPAREN resolved using rule 30 (write2 -> CTEI .)
    COMMA           reduce using rule 30 (write2 -> CTEI .)
    RPAREN          reduce using rule 30 (write2 -> CTEI .)
    MUL             reduce using rule 56 (pexp -> CTEI .)
    DIV             reduce using rule 56 (pexp -> CTEI .)
    PLUS            reduce using rule 56 (pexp -> CTEI .)
    MINUS           reduce using rule 56 (pexp -> CTEI .)
    GT              reduce using rule 56 (pexp -> CTEI .)
    LT              reduce using rule 56 (pexp -> CTEI .)
    GTE             reduce using rule 56 (pexp -> CTEI .)
    LTE             reduce using rule 56 (pexp -> CTEI .)
    NE              reduce using rule 56 (pexp -> CTEI .)
    AND             reduce using rule 56 (pexp -> CTEI .)
    OR              reduce using rule 56 (pexp -> CTEI .)

  ! COMMA           [ reduce using rule 56 (pexp -> CTEI .) ]
  ! RPAREN          [ reduce using rule 56 (pexp -> CTEI .) ]


state 142

    (31) write2 -> CTEF .
    (57) pexp -> CTEF .

  ! reduce/reduce conflict for COMMA resolved using rule 31 (write2 -> CTEF .)
  ! reduce/reduce conflict for RPAREN resolved using rule 31 (write2 -> CTEF .)
    COMMA           reduce using rule 31 (write2 -> CTEF .)
    RPAREN          reduce using rule 31 (write2 -> CTEF .)
    MUL             reduce using rule 57 (pexp -> CTEF .)
    DIV             reduce using rule 57 (pexp -> CTEF .)
    PLUS            reduce using rule 57 (pexp -> CTEF .)
    MINUS           reduce using rule 57 (pexp -> CTEF .)
    GT              reduce using rule 57 (pexp -> CTEF .)
    LT              reduce using rule 57 (pexp -> CTEF .)
    GTE             reduce using rule 57 (pexp -> CTEF .)
    LTE             reduce using rule 57 (pexp -> CTEF .)
    NE              reduce using rule 57 (pexp -> CTEF .)
    AND             reduce using rule 57 (pexp -> CTEF .)
    OR              reduce using rule 57 (pexp -> CTEF .)

  ! COMMA           [ reduce using rule 57 (pexp -> CTEF .) ]
  ! RPAREN          [ reduce using rule 57 (pexp -> CTEF .) ]


state 143

    (32) write2 -> exp .

    COMMA           reduce using rule 32 (write2 -> exp .)
    RPAREN          reduce using rule 32 (write2 -> exp .)


state 144

    (33) for -> FOR assign TO . CTEI DO LCURLY statements RCURLY

    CTEI            shift and go to state 176


state 145

    (34) while -> WHILE LPAREN exp . RPAREN DO LCURLY statements RCURLY

    RPAREN          shift and go to state 177


state 146

    (35) if -> IF LPAREN exp . RPAREN THEN LCURLY statements RCURLY else

    RPAREN          shift and go to state 178


state 147

    (91) return -> RETURN LPAREN exp . RPAREN SEMMICOLON
    (92) return -> RETURN LPAREN exp . RPAREN

    RPAREN          shift and go to state 179


state 148

    (83) functions1 -> ID saveFunction LPAREN args RPAREN vars . LCURLY statements RCURLY functions1

    LCURLY          shift and go to state 180


state 149

    (86) args -> type TWOPOINTS args1 .

    RPAREN          reduce using rule 86 (args -> type TWOPOINTS args1 .)


state 150

    (88) args1 -> ID .
    (89) args1 -> ID . COMMA args1

    RPAREN          reduce using rule 88 (args1 -> ID .)
    COMMA           shift and go to state 181


state 151

    (90) args1 -> empty .

    RPAREN          reduce using rule 90 (args1 -> empty .)


state 152

    (69) var1 -> ID arr COMMA var1 addVar .

    SEMMICOLON      reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    MUL             reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    DIV             reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    PLUS            reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    MINUS           reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    GT              reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    LT              reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    GTE             reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    LTE             reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    NE              reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    AND             reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    OR              reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    RBRACKET        reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    RPAREN          reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    COMMA           reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    TO              reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    CTEI            reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    CTEF            reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    LPAREN          reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)
    ID              reduce using rule 69 (var1 -> ID arr COMMA var1 addVar .)


state 153

    (39) exp -> nexp OR nexp .

    RBRACKET        reduce using rule 39 (exp -> nexp OR nexp .)
    RPAREN          reduce using rule 39 (exp -> nexp OR nexp .)
    COMMA           reduce using rule 39 (exp -> nexp OR nexp .)
    SEMMICOLON      reduce using rule 39 (exp -> nexp OR nexp .)
    TO              reduce using rule 39 (exp -> nexp OR nexp .)


state 154

    (41) nexp -> compexp AND compexp .

    OR              reduce using rule 41 (nexp -> compexp AND compexp .)
    RBRACKET        reduce using rule 41 (nexp -> compexp AND compexp .)
    RPAREN          reduce using rule 41 (nexp -> compexp AND compexp .)
    COMMA           reduce using rule 41 (nexp -> compexp AND compexp .)
    SEMMICOLON      reduce using rule 41 (nexp -> compexp AND compexp .)
    TO              reduce using rule 41 (nexp -> compexp AND compexp .)


state 155

    (44) compexp1 -> sumexp GT saveOperator . sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)

  ! CTEI            [ reduce using rule 93 (empty -> .) ]
  ! CTEF            [ reduce using rule 93 (empty -> .) ]
  ! LPAREN          [ reduce using rule 93 (empty -> .) ]
  ! ID              [ reduce using rule 93 (empty -> .) ]

    sumexp                         shift and go to state 182
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 156

    (45) compexp1 -> sumexp LT saveOperator . sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)

  ! CTEI            [ reduce using rule 93 (empty -> .) ]
  ! CTEF            [ reduce using rule 93 (empty -> .) ]
  ! LPAREN          [ reduce using rule 93 (empty -> .) ]
  ! ID              [ reduce using rule 93 (empty -> .) ]

    sumexp                         shift and go to state 183
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 157

    (46) compexp1 -> sumexp GTE saveOperator . sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)

  ! CTEI            [ reduce using rule 93 (empty -> .) ]
  ! CTEF            [ reduce using rule 93 (empty -> .) ]
  ! LPAREN          [ reduce using rule 93 (empty -> .) ]
  ! ID              [ reduce using rule 93 (empty -> .) ]

    sumexp                         shift and go to state 184
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 158

    (47) compexp1 -> sumexp LTE saveOperator . sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)

  ! CTEI            [ reduce using rule 93 (empty -> .) ]
  ! CTEF            [ reduce using rule 93 (empty -> .) ]
  ! LPAREN          [ reduce using rule 93 (empty -> .) ]
  ! ID              [ reduce using rule 93 (empty -> .) ]

    sumexp                         shift and go to state 185
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 159

    (48) compexp1 -> sumexp NE saveOperator . sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)

  ! CTEI            [ reduce using rule 93 (empty -> .) ]
  ! CTEF            [ reduce using rule 93 (empty -> .) ]
  ! LPAREN          [ reduce using rule 93 (empty -> .) ]
  ! ID              [ reduce using rule 93 (empty -> .) ]

    sumexp                         shift and go to state 186
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 160

    (50) sumexp -> mulexp PLUS saveOperator . mulexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)

  ! CTEI            [ reduce using rule 93 (empty -> .) ]
  ! CTEF            [ reduce using rule 93 (empty -> .) ]
  ! LPAREN          [ reduce using rule 93 (empty -> .) ]
  ! ID              [ reduce using rule 93 (empty -> .) ]

    mulexp                         shift and go to state 187
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 161

    (51) sumexp -> mulexp MINUS saveOperator . mulexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)

  ! CTEI            [ reduce using rule 93 (empty -> .) ]
  ! CTEF            [ reduce using rule 93 (empty -> .) ]
  ! LPAREN          [ reduce using rule 93 (empty -> .) ]
  ! ID              [ reduce using rule 93 (empty -> .) ]

    mulexp                         shift and go to state 188
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 162

    (53) mulexp -> pexp MUL saveOperator . pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)

  ! CTEI            [ reduce using rule 93 (empty -> .) ]
  ! CTEF            [ reduce using rule 93 (empty -> .) ]
  ! LPAREN          [ reduce using rule 93 (empty -> .) ]
  ! ID              [ reduce using rule 93 (empty -> .) ]

    pexp                           shift and go to state 189
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 163

    (54) mulexp -> pexp DIV saveOperator . pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

  ! shift/reduce conflict for CTEI resolved as shift
  ! shift/reduce conflict for CTEF resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RBRACKET        reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)

  ! CTEI            [ reduce using rule 93 (empty -> .) ]
  ! CTEF            [ reduce using rule 93 (empty -> .) ]
  ! LPAREN          [ reduce using rule 93 (empty -> .) ]
  ! ID              [ reduce using rule 93 (empty -> .) ]

    pexp                           shift and go to state 190
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 164

    (59) pexp -> LPAREN exp RPAREN .

    MUL             reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    DIV             reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    GT              reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    LT              reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    GTE             reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    LTE             reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    NE              reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    AND             reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    OR              reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    SEMMICOLON      reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    TO              reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    CTEI            reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    CTEF            reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 59 (pexp -> LPAREN exp RPAREN .)
    ID              reduce using rule 59 (pexp -> LPAREN exp RPAREN .)


state 165

    (10) statements -> read statements SEMMICOLON statements .

    RCURLY          reduce using rule 10 (statements -> read statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 10 (statements -> read statements SEMMICOLON statements .)


state 166

    (11) statements -> write statements SEMMICOLON statements .

    RCURLY          reduce using rule 11 (statements -> write statements SEMMICOLON statements .)
    SEMMICOLON      reduce using rule 11 (statements -> write statements SEMMICOLON statements .)


state 167

    (17) assign -> ID add_id EQUALS exp .

    SEMMICOLON      reduce using rule 17 (assign -> ID add_id EQUALS exp .)
    TO              reduce using rule 17 (assign -> ID add_id EQUALS exp .)


state 168

    (18) assign -> ID add_id arr EQUALS . exp
    (38) exp -> . nexp
    (39) exp -> . nexp OR nexp
    (40) nexp -> . compexp
    (41) nexp -> . compexp AND compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTEI            shift and go to state 123
    CTEF            shift and go to state 87
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)
    TO              reduce using rule 93 (empty -> .)

    exp                            shift and go to state 191
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 169

    (20) functionCall -> ID LPAREN exp RPAREN .

    SEMMICOLON      reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    MUL             reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    DIV             reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    PLUS            reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    MINUS           reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    GT              reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    LT              reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    GTE             reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    LTE             reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    NE              reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    AND             reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    OR              reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    RPAREN          reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    COMMA           reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    TO              reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    CTEI            reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    CTEF            reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    LPAREN          reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)
    ID              reduce using rule 20 (functionCall -> ID LPAREN exp RPAREN .)


state 170

    (21) read -> READ LPAREN read1 RPAREN .

    ID              reduce using rule 21 (read -> READ LPAREN read1 RPAREN .)
    READ            reduce using rule 21 (read -> READ LPAREN read1 RPAREN .)
    WRITE           reduce using rule 21 (read -> READ LPAREN read1 RPAREN .)
    FOR             reduce using rule 21 (read -> READ LPAREN read1 RPAREN .)
    WHILE           reduce using rule 21 (read -> READ LPAREN read1 RPAREN .)
    IF              reduce using rule 21 (read -> READ LPAREN read1 RPAREN .)
    RETURN          reduce using rule 21 (read -> READ LPAREN read1 RPAREN .)
    SEMMICOLON      reduce using rule 21 (read -> READ LPAREN read1 RPAREN .)


state 171

    (22) read1 -> ID read2 .

    RPAREN          reduce using rule 22 (read1 -> ID read2 .)


state 172

    (23) read2 -> COMMA . read1
    (22) read1 -> . ID read2

    ID              shift and go to state 137

    read1                          shift and go to state 192

state 173

    (24) read2 -> empty .

    RPAREN          reduce using rule 24 (read2 -> empty .)


state 174

    (26) write -> WRITE LPAREN write1 RPAREN .

    ID              reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    READ            reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    WRITE           reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    FOR             reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    WHILE           reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    IF              reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    RETURN          reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)
    SEMMICOLON      reduce using rule 26 (write -> WRITE LPAREN write1 RPAREN .)


state 175

    (27) write1 -> write2 COMMA . write2
    (29) write2 -> . CTESTRING
    (30) write2 -> . CTEI
    (31) write2 -> . CTEF
    (32) write2 -> . exp
    (38) exp -> . nexp
    (39) exp -> . nexp OR nexp
    (40) nexp -> . compexp
    (41) nexp -> . compexp AND compexp
    (42) compexp -> . sumexp
    (43) compexp -> . compexp1 sumexp
    (49) sumexp -> . mulexp
    (50) sumexp -> . mulexp PLUS saveOperator mulexp
    (51) sumexp -> . mulexp MINUS saveOperator mulexp
    (44) compexp1 -> . sumexp GT saveOperator sumexp
    (45) compexp1 -> . sumexp LT saveOperator sumexp
    (46) compexp1 -> . sumexp GTE saveOperator sumexp
    (47) compexp1 -> . sumexp LTE saveOperator sumexp
    (48) compexp1 -> . sumexp NE saveOperator sumexp
    (52) mulexp -> . pexp
    (53) mulexp -> . pexp MUL saveOperator pexp
    (54) mulexp -> . pexp DIV saveOperator pexp
    (55) pexp -> . var1
    (56) pexp -> . CTEI
    (57) pexp -> . CTEF
    (58) pexp -> . functionCall
    (59) pexp -> . LPAREN exp RPAREN
    (66) var1 -> . ID
    (67) var1 -> . ID COMMA var1 addVar
    (68) var1 -> . ID arr
    (69) var1 -> . ID arr COMMA var1 addVar
    (70) var1 -> . empty
    (20) functionCall -> . ID LPAREN exp RPAREN
    (93) empty -> .

    CTESTRING       shift and go to state 140
    CTEI            shift and go to state 141
    CTEF            shift and go to state 142
    LPAREN          shift and go to state 89
    ID              shift and go to state 90
    MUL             reduce using rule 93 (empty -> .)
    DIV             reduce using rule 93 (empty -> .)
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    GT              reduce using rule 93 (empty -> .)
    LT              reduce using rule 93 (empty -> .)
    GTE             reduce using rule 93 (empty -> .)
    LTE             reduce using rule 93 (empty -> .)
    NE              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)

    write2                         shift and go to state 193
    exp                            shift and go to state 143
    nexp                           shift and go to state 80
    compexp                        shift and go to state 81
    sumexp                         shift and go to state 82
    compexp1                       shift and go to state 83
    mulexp                         shift and go to state 84
    pexp                           shift and go to state 85
    var1                           shift and go to state 86
    functionCall                   shift and go to state 88
    empty                          shift and go to state 48

state 176

    (33) for -> FOR assign TO CTEI . DO LCURLY statements RCURLY

    DO              shift and go to state 194


state 177

    (34) while -> WHILE LPAREN exp RPAREN . DO LCURLY statements RCURLY

    DO              shift and go to state 195


state 178

    (35) if -> IF LPAREN exp RPAREN . THEN LCURLY statements RCURLY else

    THEN            shift and go to state 196


state 179

    (91) return -> RETURN LPAREN exp RPAREN . SEMMICOLON
    (92) return -> RETURN LPAREN exp RPAREN .

  ! shift/reduce conflict for SEMMICOLON resolved as shift
    SEMMICOLON      shift and go to state 197
    ID              reduce using rule 92 (return -> RETURN LPAREN exp RPAREN .)
    READ            reduce using rule 92 (return -> RETURN LPAREN exp RPAREN .)
    WRITE           reduce using rule 92 (return -> RETURN LPAREN exp RPAREN .)
    FOR             reduce using rule 92 (return -> RETURN LPAREN exp RPAREN .)
    WHILE           reduce using rule 92 (return -> RETURN LPAREN exp RPAREN .)
    IF              reduce using rule 92 (return -> RETURN LPAREN exp RPAREN .)
    RETURN          reduce using rule 92 (return -> RETURN LPAREN exp RPAREN .)
    RCURLY          reduce using rule 92 (return -> RETURN LPAREN exp RPAREN .)

  ! SEMMICOLON      [ reduce using rule 92 (return -> RETURN LPAREN exp RPAREN .) ]


state 180

    (83) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY . statements RCURLY functions1
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)

    statements                     shift and go to state 198
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 181

    (89) args1 -> ID COMMA . args1
    (88) args1 -> . ID
    (89) args1 -> . ID COMMA args1
    (90) args1 -> . empty
    (93) empty -> .

    ID              shift and go to state 150
    RPAREN          reduce using rule 93 (empty -> .)

    args1                          shift and go to state 199
    empty                          shift and go to state 151

state 182

    (44) compexp1 -> sumexp GT saveOperator sumexp .

    CTEI            reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    CTEF            reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    LPAREN          reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    ID              reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    PLUS            reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    MINUS           reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    MUL             reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    DIV             reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    AND             reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    OR              reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    RBRACKET        reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    RPAREN          reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    COMMA           reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    SEMMICOLON      reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)
    TO              reduce using rule 44 (compexp1 -> sumexp GT saveOperator sumexp .)


state 183

    (45) compexp1 -> sumexp LT saveOperator sumexp .

    CTEI            reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    CTEF            reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    LPAREN          reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    ID              reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    PLUS            reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    MINUS           reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    MUL             reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    DIV             reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    AND             reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    OR              reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    RBRACKET        reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    RPAREN          reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    COMMA           reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    SEMMICOLON      reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)
    TO              reduce using rule 45 (compexp1 -> sumexp LT saveOperator sumexp .)


state 184

    (46) compexp1 -> sumexp GTE saveOperator sumexp .

    CTEI            reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    CTEF            reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    LPAREN          reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    ID              reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    PLUS            reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    MINUS           reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    MUL             reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    DIV             reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    AND             reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    OR              reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    RBRACKET        reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    RPAREN          reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    COMMA           reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    SEMMICOLON      reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)
    TO              reduce using rule 46 (compexp1 -> sumexp GTE saveOperator sumexp .)


state 185

    (47) compexp1 -> sumexp LTE saveOperator sumexp .

    CTEI            reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    CTEF            reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    LPAREN          reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    ID              reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    PLUS            reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    MINUS           reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    MUL             reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    DIV             reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    AND             reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    OR              reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    RBRACKET        reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    RPAREN          reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    COMMA           reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    SEMMICOLON      reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)
    TO              reduce using rule 47 (compexp1 -> sumexp LTE saveOperator sumexp .)


state 186

    (48) compexp1 -> sumexp NE saveOperator sumexp .

    CTEI            reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    CTEF            reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    LPAREN          reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    ID              reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    PLUS            reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    MINUS           reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    MUL             reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    DIV             reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    AND             reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    OR              reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    RBRACKET        reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    RPAREN          reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    COMMA           reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    SEMMICOLON      reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)
    TO              reduce using rule 48 (compexp1 -> sumexp NE saveOperator sumexp .)


state 187

    (50) sumexp -> mulexp PLUS saveOperator mulexp .

    GT              reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    LT              reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    GTE             reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    LTE             reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    NE              reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    AND             reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    OR              reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    RBRACKET        reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    RPAREN          reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    COMMA           reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    SEMMICOLON      reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    TO              reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    CTEI            reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    CTEF            reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    LPAREN          reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    ID              reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    PLUS            reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    MINUS           reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    MUL             reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)
    DIV             reduce using rule 50 (sumexp -> mulexp PLUS saveOperator mulexp .)


state 188

    (51) sumexp -> mulexp MINUS saveOperator mulexp .

    GT              reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    LT              reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    GTE             reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    LTE             reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    NE              reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    AND             reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    OR              reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    RBRACKET        reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    RPAREN          reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    COMMA           reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    SEMMICOLON      reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    TO              reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    CTEI            reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    CTEF            reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    LPAREN          reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    ID              reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    PLUS            reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    MINUS           reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    MUL             reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)
    DIV             reduce using rule 51 (sumexp -> mulexp MINUS saveOperator mulexp .)


state 189

    (53) mulexp -> pexp MUL saveOperator pexp .

    PLUS            reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    MINUS           reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    GT              reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    LT              reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    GTE             reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    LTE             reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    NE              reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    AND             reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    OR              reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    RBRACKET        reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    RPAREN          reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    COMMA           reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    SEMMICOLON      reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    TO              reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    CTEI            reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    CTEF            reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    LPAREN          reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    ID              reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    MUL             reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)
    DIV             reduce using rule 53 (mulexp -> pexp MUL saveOperator pexp .)


state 190

    (54) mulexp -> pexp DIV saveOperator pexp .

    PLUS            reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    MINUS           reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    GT              reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    LT              reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    GTE             reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    LTE             reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    NE              reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    AND             reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    OR              reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    RBRACKET        reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    RPAREN          reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    COMMA           reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    SEMMICOLON      reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    TO              reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    CTEI            reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    CTEF            reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    LPAREN          reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    ID              reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    MUL             reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)
    DIV             reduce using rule 54 (mulexp -> pexp DIV saveOperator pexp .)


state 191

    (18) assign -> ID add_id arr EQUALS exp .

    SEMMICOLON      reduce using rule 18 (assign -> ID add_id arr EQUALS exp .)
    TO              reduce using rule 18 (assign -> ID add_id arr EQUALS exp .)


state 192

    (23) read2 -> COMMA read1 .

    RPAREN          reduce using rule 23 (read2 -> COMMA read1 .)


state 193

    (27) write1 -> write2 COMMA write2 .

    RPAREN          reduce using rule 27 (write1 -> write2 COMMA write2 .)


state 194

    (33) for -> FOR assign TO CTEI DO . LCURLY statements RCURLY

    LCURLY          shift and go to state 200


state 195

    (34) while -> WHILE LPAREN exp RPAREN DO . LCURLY statements RCURLY

    LCURLY          shift and go to state 201


state 196

    (35) if -> IF LPAREN exp RPAREN THEN . LCURLY statements RCURLY else

    LCURLY          shift and go to state 202


state 197

    (91) return -> RETURN LPAREN exp RPAREN SEMMICOLON .

    ID              reduce using rule 91 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    READ            reduce using rule 91 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WRITE           reduce using rule 91 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    FOR             reduce using rule 91 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    WHILE           reduce using rule 91 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    IF              reduce using rule 91 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RETURN          reduce using rule 91 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    RCURLY          reduce using rule 91 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)
    SEMMICOLON      reduce using rule 91 (return -> RETURN LPAREN exp RPAREN SEMMICOLON .)


state 198

    (83) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements . RCURLY functions1

    RCURLY          shift and go to state 203


state 199

    (89) args1 -> ID COMMA args1 .

    RPAREN          reduce using rule 89 (args1 -> ID COMMA args1 .)


state 200

    (33) for -> FOR assign TO CTEI DO LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)

    assign                         shift and go to state 56
    statements                     shift and go to state 204
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 201

    (34) while -> WHILE LPAREN exp RPAREN DO LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)

    statements                     shift and go to state 205
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 202

    (35) if -> IF LPAREN exp RPAREN THEN LCURLY . statements RCURLY else
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)

    statements                     shift and go to state 206
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 203

    (83) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY . functions1
    (83) functions1 -> . ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY functions1
    (84) functions1 -> . empty
    (93) empty -> .

    ID              shift and go to state 31
    FUNCTION        reduce using rule 93 (empty -> .)
    PRINCIPAL       reduce using rule 93 (empty -> .)
    $end            reduce using rule 93 (empty -> .)

    functions1                     shift and go to state 207
    empty                          shift and go to state 32

state 204

    (33) for -> FOR assign TO CTEI DO LCURLY statements . RCURLY

    RCURLY          shift and go to state 208


state 205

    (34) while -> WHILE LPAREN exp RPAREN DO LCURLY statements . RCURLY

    RCURLY          shift and go to state 209


state 206

    (35) if -> IF LPAREN exp RPAREN THEN LCURLY statements . RCURLY else

    RCURLY          shift and go to state 210


state 207

    (83) functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY functions1 .

    FUNCTION        reduce using rule 83 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY functions1 .)
    PRINCIPAL       reduce using rule 83 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY functions1 .)
    $end            reduce using rule 83 (functions1 -> ID saveFunction LPAREN args RPAREN vars LCURLY statements RCURLY functions1 .)


state 208

    (33) for -> FOR assign TO CTEI DO LCURLY statements RCURLY .

    ID              reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    READ            reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    WRITE           reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    FOR             reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    WHILE           reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    IF              reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    RETURN          reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    RCURLY          reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 33 (for -> FOR assign TO CTEI DO LCURLY statements RCURLY .)


state 209

    (34) while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .

    ID              reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    READ            reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    WRITE           reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    FOR             reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    WHILE           reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    IF              reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    RETURN          reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    RCURLY          reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 34 (while -> WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY .)


state 210

    (35) if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY . else
    (36) else -> . ELSE LCURLY statements RCURLY
    (37) else -> . empty
    (93) empty -> .

    ELSE            shift and go to state 212
    ID              reduce using rule 93 (empty -> .)
    READ            reduce using rule 93 (empty -> .)
    WRITE           reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)
    SEMMICOLON      reduce using rule 93 (empty -> .)

    else                           shift and go to state 211
    empty                          shift and go to state 213

state 211

    (35) if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .

    ID              reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    READ            reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    WRITE           reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    FOR             reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    WHILE           reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    IF              reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    RETURN          reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    RCURLY          reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)
    SEMMICOLON      reduce using rule 35 (if -> IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else .)


state 212

    (36) else -> ELSE . LCURLY statements RCURLY

    LCURLY          shift and go to state 214


state 213

    (37) else -> empty .

    ID              reduce using rule 37 (else -> empty .)
    READ            reduce using rule 37 (else -> empty .)
    WRITE           reduce using rule 37 (else -> empty .)
    FOR             reduce using rule 37 (else -> empty .)
    WHILE           reduce using rule 37 (else -> empty .)
    IF              reduce using rule 37 (else -> empty .)
    RETURN          reduce using rule 37 (else -> empty .)
    RCURLY          reduce using rule 37 (else -> empty .)
    SEMMICOLON      reduce using rule 37 (else -> empty .)


state 214

    (36) else -> ELSE LCURLY . statements RCURLY
    (8) statements -> . assign SEMMICOLON statements
    (9) statements -> . functionCall SEMMICOLON statements
    (10) statements -> . read statements SEMMICOLON statements
    (11) statements -> . write statements SEMMICOLON statements
    (12) statements -> . for statements
    (13) statements -> . while statements
    (14) statements -> . if statements
    (15) statements -> . return statements
    (16) statements -> . empty
    (17) assign -> . ID add_id EQUALS exp
    (18) assign -> . ID add_id arr EQUALS exp
    (20) functionCall -> . ID LPAREN exp RPAREN
    (21) read -> . READ LPAREN read1 RPAREN
    (26) write -> . WRITE LPAREN write1 RPAREN
    (33) for -> . FOR assign TO CTEI DO LCURLY statements RCURLY
    (34) while -> . WHILE LPAREN exp RPAREN DO LCURLY statements RCURLY
    (35) if -> . IF LPAREN exp RPAREN THEN LCURLY statements RCURLY else
    (91) return -> . RETURN LPAREN exp RPAREN SEMMICOLON
    (92) return -> . RETURN LPAREN exp RPAREN
    (93) empty -> .

    ID              shift and go to state 65
    READ            shift and go to state 66
    WRITE           shift and go to state 67
    FOR             shift and go to state 68
    WHILE           shift and go to state 69
    IF              shift and go to state 70
    RETURN          shift and go to state 71
    RCURLY          reduce using rule 93 (empty -> .)

    statements                     shift and go to state 215
    assign                         shift and go to state 56
    functionCall                   shift and go to state 57
    read                           shift and go to state 58
    write                          shift and go to state 59
    for                            shift and go to state 60
    while                          shift and go to state 61
    if                             shift and go to state 62
    return                         shift and go to state 63
    empty                          shift and go to state 64

state 215

    (36) else -> ELSE LCURLY statements . RCURLY

    RCURLY          shift and go to state 216


state 216

    (36) else -> ELSE LCURLY statements RCURLY .

    ID              reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    READ            reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    WRITE           reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    FOR             reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    WHILE           reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    IF              reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    RETURN          reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    RCURLY          reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)
    SEMMICOLON      reduce using rule 36 (else -> ELSE LCURLY statements RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PRINCIPAL in state 5 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 47 resolved as shift
WARNING: shift/reduce conflict for ID in state 52 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 53 resolved as shift
WARNING: shift/reduce conflict for ID in state 77 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 78 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MUL in state 85 resolved as shift
WARNING: shift/reduce conflict for DIV in state 85 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 90 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 90 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 155 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 155 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 155 resolved as shift
WARNING: shift/reduce conflict for ID in state 155 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 156 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 156 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 156 resolved as shift
WARNING: shift/reduce conflict for ID in state 156 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 157 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 157 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 157 resolved as shift
WARNING: shift/reduce conflict for ID in state 157 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 158 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 158 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 158 resolved as shift
WARNING: shift/reduce conflict for ID in state 158 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 159 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 159 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 159 resolved as shift
WARNING: shift/reduce conflict for ID in state 159 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 160 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 160 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 160 resolved as shift
WARNING: shift/reduce conflict for ID in state 160 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 161 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 161 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 161 resolved as shift
WARNING: shift/reduce conflict for ID in state 161 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 162 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 162 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 162 resolved as shift
WARNING: shift/reduce conflict for ID in state 162 resolved as shift
WARNING: shift/reduce conflict for CTEI in state 163 resolved as shift
WARNING: shift/reduce conflict for CTEF in state 163 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 163 resolved as shift
WARNING: shift/reduce conflict for ID in state 163 resolved as shift
WARNING: shift/reduce conflict for SEMMICOLON in state 179 resolved as shift
WARNING: reduce/reduce conflict in state 141 resolved using rule (write2 -> CTEI)
WARNING: rejected rule (pexp -> CTEI) in state 141
WARNING: reduce/reduce conflict in state 142 resolved using rule (write2 -> CTEF)
WARNING: rejected rule (pexp -> CTEF) in state 142
